__all__=['', 'COMMTIMEOUTS', 'CopyProgressRoutine', 'DOCINFO', 'ExportCallback', 'FORM_INFO_1', 'ImportCallback', 'LARGE_INTEGER', 'NCB', 'PRINTER_DEFAULTS', 'PyACL', 'PyBITMAP', 'PyBLENDFUNCTION', 'PyCEHANDLE', 'PyCERTSTORE', 'PyCERT_ALT_NAME_ENTRY', 'PyCERT_ALT_NAME_INFO', 'PyCERT_AUTHORITY_KEY_ID_INFO', 'PyCERT_BASIC_CONSTRAINTS2_INFO', 'PyCERT_BASIC_CONSTRAINTS_INFO', 'PyCERT_CONTEXT', 'PyCERT_EXTENSION', 'PyCERT_KEY_ATTRIBUTES_INFO', 'PyCERT_NAME_INFO', 'PyCERT_NAME_VALUE', 'PyCERT_OTHER_NAME', 'PyCERT_POLICY_INFO', 'PyCERT_PUBLIC_KEY_INFO', 'PyCOMSTAT', 'PyCOORD', 'PyCREDENTIAL', 'PyCREDENTIAL_ATTRIBUTE', 'PyCREDENTIAL_TARGET_INFORMATION', 'PyCREDUI_INFO', 'PyCRYPTHASH', 'PyCRYPTKEY', 'PyCRYPTMSG', 'PyCRYPTPROTECT_PROMPTSTRUCT', 'PyCRYPTPROV', 'PyCRYPT_ALGORITHM_IDENTIFIER', 'PyCRYPT_ATTRIBUTE', 'PyCRYPT_BIT_BLOB', 'PyCRYPT_DECRYPT_MESSAGE_PARA', 'PyCRYPT_ENCRYPT_MESSAGE_PARA', 'PyCRYPT_SIGN_MESSAGE_PARA', 'PyCRYPT_VERIFY_MESSAGE_PARA', 'PyCTL_CONTEXT', 'PyCTL_USAGE', 'PyConsoleScreenBuffer', 'PyCredHandle', 'PyCtxtHandle', 'PyDCB', 'PyDEVMODE', 'PyDEVMODEW', 'PyDISPLAY_DEVICE', 'PyDLGITEMTEMPLATE', 'PyDLGTEMPLATE', 'PyDS_HANDLE', 'PyDS_NAME_RESULT_ITEM', 'PyDateTime', 'PyDialogTemplate', 'PyEVTLOG_HANDLE', 'PyEVT_HANDLE', 'PyEVT_RPC_LOGIN', 'PyEventLogRecord', 'PyGROUP_INFO_0', 'PyGROUP_INFO_1', 'PyGROUP_INFO_1002', 'PyGROUP_INFO_1005', 'PyGROUP_INFO_2', 'PyGROUP_USERS_INFO_0', 'PyGROUP_USERS_INFO_1', 'PyGdiHANDLE', 'PyGetSignerCertificate', 'PyHANDLE', 'PyHDESK', 'PyHDEVNOTIFY', 'PyHHNTRACK', 'PyHHN_NOTIFY', 'PyHH_AKLINK', 'PyHH_FTS_QUERY', 'PyHH_POPUP', 'PyHH_WINTYPE', 'PyHINTERNET', 'PyHKEY', 'PyHTHEME', 'PyHWINSTA', 'PyICONINFO', 'PyIID', 'PyINPUT_RECORD', 'PyLOCALGROUP_INFO_0', 'PyLOCALGROUP_INFO_1', 'PyLOCALGROUP_INFO_1002', 'PyLOCALGROUP_MEMBERS_INFO_0', 'PyLOCALGROUP_MEMBERS_INFO_1', 'PyLOCALGROUP_MEMBERS_INFO_2', 'PyLOCALGROUP_MEMBERS_INFO_3', 'PyLOGBRUSH', 'PyLOGFONT', 'PyLSA_HANDLE', 'PyLUID_AND_ATTRIBUTES', 'PyLsaLogon_HANDLE', 'PyMSG', 'PyNETRESOURCE', 'PyNET_VALIDATE_AUTHENTICATION_INPUT_ARG', 'PyNET_VALIDATE_PASSWORD_CHANGE_INPUT_ARG', 'PyNET_VALIDATE_PERSISTED_FIELDS', 'PyNMHDR', 'PyNOTIFYICONDATA', 'PyOVERLAPPED', 'PyOVERLAPPEDReadBuffer', 'PyPERF_COUNTER_DEFINITION', 'PyPERF_OBJECT_TYPE', 'PyPOINT', 'PyPROFILEINFO', 'PyPerfMonManager', 'PyPrinterHANDLE', 'PyRECT', 'PyResourceId', 'PySCROLLINFO', 'PySC_HANDLE', 'PySECURITY_ATTRIBUTES', 'PySECURITY_DESCRIPTOR', 'PySERVER_INFO_100', 'PySERVER_INFO_101', 'PySERVER_INFO_102', 'PySERVER_INFO_402', 'PySERVER_INFO_403', 'PySERVER_INFO_502', 'PySERVER_INFO_503', 'PySHARE_INFO_0', 'PySHARE_INFO_1', 'PySHARE_INFO_2', 'PySHARE_INFO_501', 'PySHARE_INFO_502', 'PySID', 'PySID_AND_ATTRIBUTES', 'PySIZE', 'PySMALL_RECT', 'PySTARTUPINFO', 'PySecBuffer', 'PySecBufferDesc', 'PyTOKEN_GROUPS', 'PyTOKEN_PRIVILEGES', 'PyTRIVERTEX', 'PyTRUSTEE', 'PyTS_HANDLE', 'PyTime', 'PyUSER_INFO_0', 'PyUSER_INFO_1', 'PyUSER_INFO_10', 'PyUSER_INFO_1003', 'PyUSER_INFO_1005', 'PyUSER_INFO_1006', 'PyUSER_INFO_1007', 'PyUSER_INFO_1008', 'PyUSER_INFO_1009', 'PyUSER_INFO_1010', 'PyUSER_INFO_1011', 'PyUSER_INFO_11', 'PyUSER_INFO_2', 'PyUSER_INFO_20', 'PyUSER_INFO_3', 'PyUSER_INFO_4', 'PyUSER_MODALS_INFO_0', 'PyUSER_MODALS_INFO_1', 'PyUSER_MODALS_INFO_2', 'PyUSER_MODALS_INFO_3', 'PyUSE_INFO_0', 'PyUSE_INFO_1', 'PyUSE_INFO_2', 'PyUSE_INFO_3', 'PyUnicode', 'PyUrlCacheHANDLE', 'PyWAVEFORMATEX', 'PyWINHTTP_AUTOPROXY_OPTIONS', 'PyWINHTTP_PROXY_INFO', 'PyWKSTA_INFO_100', 'PyWKSTA_INFO_101', 'PyWKSTA_INFO_102', 'PyWKSTA_INFO_302', 'PyWKSTA_INFO_402', 'PyWKSTA_INFO_502', 'PyWKSTA_TRANSPORT_INFO_0', 'PyWKSTA_USER_INFO_0', 'PyWKSTA_USER_INFO_1', 'PyWNDCLASS', 'PyXFORM', 'Pymmapfile', 'RASDIALEXTENSIONS', 'RASDIALPARAMS', 'SC_ACTION', 'SERVICE_FAILURE_ACTIONS', 'SERVICE_STATUS', 'TRACKMOUSEEVENT', 'ULARGE_INTEGER', 'WIN32_FIND_DATA', 'com_error', 'connection', 'cursor', 'error', 'COMPONENT', 'COMPONENTSOPT', 'COMPPOS', 'COMPSTATEINFO', 'DEFCONTENTMENU', 'ELEMDESC', 'EXP_DARWIN_LINK', 'EXP_SPECIAL_FOLDER', 'EXP_SZ_LINK', 'FUNCDESC', 'IDLDESC', 'MAPIINIT_0', 'NT_CONSOLE_PROPS', 'NT_FE_CONSOLE_PROPS', 'PROPSPEC', 'PyADSVALUE', 'PyADS_ATTR_INFO', 'PyADS_OBJECT_INFO', 'PyADS_SEARCHPREF_INFO', 'PyBIND_OPTS', 'PyCMINVOKECOMMANDINFO', 'PyDSBCAPS', 'PyDSBUFFERDESC', 'PyDSCAPS', 'PyDSCBCAPS', 'PyDSCBUFFERDESC', 'PyDSCCAPS', 'PyDSOP_FILTER_FLAGS', 'PyDSOP_SCOPE_INIT_INFO', 'PyDSOP_SCOPE_INIT_INFOs', 'PyDSOP_UPLEVEL_FILTER_FLAGS', 'PyFORMATETC', 'PyGFileOperationProgressSink', 'PyGSecurityInformation', 'PyIADesktopP2', 'PyIADs', 'PyIADsContainer', 'PyIADsUser', 'PyIActiveDesktop', 'PyIActiveDesktopP', 'PyIActiveScriptDebug', 'PyIActiveScriptError', 'PyIActiveScriptErrorDebug', 'PyIActiveScriptParseProcedure', 'PyIActiveScriptSite', 'PyIActiveScriptSiteDebug', 'PyIAddrBook', 'PyIApplicationDebugger', 'PyIApplicationDestinations', 'PyIApplicationDocumentLists', 'PyIAsyncOperation', 'PyIAttach', 'PyIBindCtx', 'PyIBrowserFrameOptions', 'PyICancelMethodCalls', 'PyICatInformation', 'PyICatRegister', 'PyICategoryProvider', 'PyIClassFactory', 'PyIClientSecurity', 'PyIColumnProvider', 'PyIConnectionPoint', 'PyIConnectionPointContainer', 'PyIContext', 'PyIContextMenu', 'PyICopyHookA', 'PyICopyHookW', 'PyICreateTypeInfo', 'PyICreateTypeLib', 'PyICreateTypeLib2', 'PyICurrentItem', 'PyICustomDestinationList', 'PyIDL', 'PyIDataObject', 'PyIDebugApplication', 'PyIDebugApplicationNode', 'PyIDebugApplicationNodeEvents', 'PyIDebugApplicationThread', 'PyIDebugCodeContext', 'PyIDebugDocument', 'PyIDebugDocumentContext', 'PyIDebugDocumentHelper', 'PyIDebugDocumentHost', 'PyIDebugDocumentInfo', 'PyIDebugDocumentProvider', 'PyIDebugDocumentText', 'PyIDebugDocumentTextAuthor', 'PyIDebugDocumentTextEvents', 'PyIDebugDocumentTextExternalAuthor', 'PyIDebugExpression', 'PyIDebugExpressionCallBack', 'PyIDebugExpressionContext', 'PyIDebugProperty', 'PyIDebugSessionProvider', 'PyIDebugStackFrame', 'PyIDebugStackFrameSniffer', 'PyIDebugStackFrameSnifferEx', 'PyIDebugSyncOperation', 'PyIDefaultExtractIconInit', 'PyIDirectSound', 'PyIDirectSoundBuffer', 'PyIDirectSoundCapture', 'PyIDirectSoundCaptureBuffer', 'PyIDirectSoundNotify', 'PyIDirectoryObject', 'PyIDirectorySearch', 'PyIDispatch', 'PyIDispatchEx', 'PyIDisplayItem', 'PyIDocHostUIHandler', 'PyIDropSource', 'PyIDropTarget', 'PyIDropTargetHelper', 'PyIDsObjectPicker', 'PyIEmptyVolumeCache', 'PyIEmptyVolumeCache2', 'PyIEmptyVolumeCacheCallBack', 'PyIEnumCATEGORYINFO', 'PyIEnumConnectionPoints', 'PyIEnumConnections', 'PyIEnumContextProps', 'PyIEnumDebugApplicationNodes', 'PyIEnumDebugCodeContexts', 'PyIEnumDebugExpressionContexts', 'PyIEnumDebugPropertyInfo', 'PyIEnumDebugStackFrames', 'PyIEnumExplorerCommand', 'PyIEnumFORMATETC', 'PyIEnumGUID', 'PyIEnumIDList', 'PyIEnumMoniker', 'PyIEnumObjects', 'PyIEnumRemoteDebugApplicationThreads', 'PyIEnumRemoteDebugApplications', 'PyIEnumResources', 'PyIEnumSTATPROPSETSTG', 'PyIEnumSTATPROPSTG', 'PyIEnumSTATSTG', 'PyIEnumShellItems', 'PyIEnumString', 'PyIErrorLog', 'PyIExplorerBrowser', 'PyIExplorerBrowserEvents', 'PyIExplorerCommand', 'PyIExplorerCommandProvider', 'PyIExplorerPaneVisibility', 'PyIExternalConnection', 'PyIExtractIcon', 'PyIExtractIconW', 'PyIExtractImage', 'PyIFileOperation', 'PyIIdentityName', 'PyIInitializeWithFile', 'PyIInitializeWithStream', 'PyIInputObject', 'PyIInternetBindInfo', 'PyIInternetPriority', 'PyIInternetProtocol', 'PyIInternetProtocolInfo', 'PyIInternetProtocolRoot', 'PyIInternetProtocolSink', 'PyIInternetSecurityManager', 'PyIKnownFolder', 'PyIKnownFolderManager', 'PyILockBytes', 'PyIMAPIContainer', 'PyIMAPIFolder', 'PyIMAPIProp', 'PyIMAPISession', 'PyIMAPIStatus', 'PyIMAPITable', 'PyIMachineDebugManager', 'PyIMachineDebugManagerEvents', 'PyIMessage', 'PyIMoniker', 'PyIMsgServiceAdmin', 'PyIMsgStore', 'PyINameSpaceTreeControl', 'PyINamedPropertyStore', 'PyIObjectArray', 'PyIObjectCollection', 'PyIObjectWithPropertyKey', 'PyIObjectWithSite', 'PyIOleClientSite', 'PyIOleCommandTarget', 'PyIOleControl', 'PyIOleControlSite', 'PyIOleInPlaceActiveObject', 'PyIOleInPlaceFrame', 'PyIOleInPlaceObject', 'PyIOleInPlaceSite', 'PyIOleInPlaceSiteEx', 'PyIOleInPlaceSiteWindowless', 'PyIOleInPlaceUIWindow', 'PyIOleObject', 'PyIOleWindow', 'PyIPersist', 'PyIPersistFile', 'PyIPersistFolder', 'PyIPersistFolder2', 'PyIPersistPropertyBag', 'PyIPersistSerializedPropStorage', 'PyIPersistStorage', 'PyIPersistStream', 'PyIPersistStreamInit', 'PyIProcessDebugManager', 'PyIProfAdmin', 'PyIPropertyBag', 'PyIPropertyChange', 'PyIPropertyChangeArray', 'PyIPropertyDescription', 'PyIPropertyDescriptionAliasInfo', 'PyIPropertyDescriptionList', 'PyIPropertyDescriptionSearchInfo', 'PyIPropertyEnumType', 'PyIPropertyEnumTypeList', 'PyIPropertySetStorage', 'PyIPropertyStorage', 'PyIPropertyStore', 'PyIPropertyStoreCache', 'PyIPropertyStoreCapabilities', 'PyIPropertySystem', 'PyIProvideClassInfo', 'PyIProvideClassInfo2', 'PyIProvideExpressionContexts', 'PyIProvideTaskPage', 'PyIQueryAssociations', 'PyIRelatedItem', 'PyIRemoteDebugApplication', 'PyIRemoteDebugApplicationEvents', 'PyIRemoteDebugApplicationThread', 'PyIRunningObjectTable', 'PyIScheduledWorkItem', 'PyIServerSecurity', 'PyIServiceProvider', 'PyIShellBrowser', 'PyIShellExtInit', 'PyIShellFolder', 'PyIShellFolder2', 'PyIShellIcon', 'PyIShellIconOverlay', 'PyIShellIconOverlayIdentifier', 'PyIShellIconOverlayManager', 'PyIShellItem', 'PyIShellItem2', 'PyIShellItemArray', 'PyIShellItemResources', 'PyIShellLibrary', 'PyIShellLink', 'PyIShellLinkDataList', 'PyIShellView', 'PyISpecifyPropertyPages', 'PyIStorage', 'PyIStream', 'PyITask', 'PyITaskScheduler', 'PyITaskTrigger', 'PyITaskbarList', 'PyITransferAdviseSink', 'PyITransferDestination', 'PyITransferMediumItem', 'PyITransferSource', 'PyITypeComp', 'PyITypeInfo', 'PyITypeLib', 'PyIUniformResourceLocator', 'PyIUnknown', 'PyIViewObject', 'PyIViewObject2', 'PyMAPINAMEIDArray', 'PyOLEMENUGROUPWIDTHS', 'PyPROPERTYKEY', 'PyPROPVARIANT', 'PySAndRestriction', 'PySBinaryArray', 'PySBitMaskRestriction', 'PySContentRestriction', 'PySExistRestriction', 'PySHELL_ITEM_RESOURCE', 'PySNotRestriction', 'PySOrRestriction', 'PySPropTagArray', 'PySPropValue', 'PySPropValueArray', 'PySPropertyRestriction', 'PySRestriction', 'PySRow', 'PySRowSet', 'PySSortOrderItem', 'PySSortOrderSet', 'PySTGMEDIUM', 'PyTASK_TRIGGER', 'RTF_WCSINFO', 'SHFILEINFO', 'SHFILEOPSTRUCT', 'SI_ACCESS', 'SI_INHERIT_TYPE', 'SI_OBJECT_INFO', 'STATSTG', 'TLIBATTR', 'TYPEATTR', 'TYPEDESC', 'VARDESC', 'CHARFORMAT', 'CREATESTRUCT', 'LV_COLUMN', 'LV_ITEM', 'PARAFORMAT', 'PyAssocCObject', 'PyAssocObject', 'PyCBitmap', 'PyCBrush', 'PyCButton', 'PyCCmdTarget', 'PyCCmdUI', 'PyCColorDialog', 'PyCComboBox', 'PyCCommonDialog', 'PyCControl', 'PyCControlBar', 'PyCCtrlView', 'PyCDC', 'PyCDialog', 'PyCDialogBar', 'PyCDocTemplate', 'PyCDockContext', 'PyCDocument', 'PyCEdit', 'PyCEditView', 'PyCFileDialog', 'PyCFont', 'PyCFontDialog', 'PyCFormView', 'PyCFrameWnd', 'PyCGdiObject', 'PyCImageList', 'PyCListBox', 'PyCListCtrl', 'PyCListView', 'PyCMDIChildWnd', 'PyCMDIFrameWnd', 'PyCMenu', 'PyCOleClientItem', 'PyCOleDialog', 'PyCOleDocument', 'PyCOleInsertDialog', 'PyCPrintDialog', 'PyCPrintInfo', 'PyCProgressCtrl', 'PyCPropertyPage', 'PyCPropertySheet', 'PyCRect', 'PyCRgn', 'PyCRichEditCtrl', 'PyCRichEditDoc', 'PyCRichEditDocTemplate', 'PyCRichEditView', 'PyCScrollView', 'PyCSliderCtrl', 'PyCSpinButtonCtrl', 'PyCSplitterWnd', 'PyCStatusBar', 'PyCStatusBarCtrl', 'PyCTabCtrl', 'PyCToolBar', 'PyCToolBarCtrl', 'PyCToolTipCtrl', 'PyCTreeCtrl', 'PyCTreeView', 'PyCView', 'PyCWinApp', 'PyCWinThread', 'PyCWnd', 'PyDDEConv', 'PyDDEServer', 'PyDDEStringItem', 'PyDDETopic', 'PyDLL', 'SCROLLINFO', 'TV_ITEM', 'EXTENSION_CONTROL_BLOCK', 'HSE_VERSION_INFO', 'HTTP_FILTER_AUTHENT', 'HTTP_FILTER_CONTEXT', 'HTTP_FILTER_LOG', 'HTTP_FILTER_PREPROC_HEADERS', 'HTTP_FILTER_RAW_DATA', 'HTTP_FILTER_URL_MAP', 'HTTP_FILTER_VERSION']
import typing

class COMMTIMEOUTS(object):
      """A tuple representing a COMMTIMEOUTS structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class CopyProgressRoutine(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class DOCINFO(object):
      """A tuple of information representing a DOCINFO struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def DocName(self)->'typing.Union[str]':
         """Name of document"""
         pass


      @property
      def Output(self)->'typing.Union[str]':
         """Name of output file when printing to file. Use None for normal printing."""
         pass


      @property
      def DataType(self)->'typing.Union[str]':
         """Type of data to be sent to printer, eg RAW, EMF, TEXT. Use None for printer default."""
         pass


      @property
      def Type(self)->'typing.Any':
         """Flag specifying mode of operation.  Can be DI_APPBANDING, DI_ROPS_READ_DESTINATION, or 0"""
         pass


class ExportCallback(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class FORM_INFO_1(object):
      """A dictionary containing FORM_INFO_1W data"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Flags(self)->'typing.Any':
         """FORM_USER, FORM_BUILTIN, or FORM_PRINTER"""
         pass


      @property
      def Name(self)->'str':
         """Name of form"""
         pass


      @property
      def Size(self)->'typing.Any':
         """A dictionary representing a SIZEL structure {'cx':int,'cy':int}"""
         pass


      @property
      def ImageableArea(self)->'typing.Any':
         """A dictionary representing a RECTL structure {'left':int, 'top':int, 'right':int, 'bottom':int}"""
         pass


class ImportCallback(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class LARGE_INTEGER(object):
      """A Python object used wherever a COM LARGE_INTEGER is used."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class NCB(object):
      """A Python object that encapsulates a Win32 NCB structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Command(self)->'typing.Any':
         """"""
         pass


      @property
      def Retcode(self)->'typing.Any':
         """"""
         pass


      @property
      def Lsn(self)->'typing.Any':
         """"""
         pass


      @property
      def Num(self)->'typing.Any':
         """"""
         pass


      @property
      def Bufflen(self)->'typing.Any':
         """read-only"""
         pass


      @property
      def Callname(self)->'str':
         """- The strings need to be space padded to 16 chars exactly"""
         pass


      @property
      def Name(self)->'str':
         """- The strings need to be space padded to 16 chars exactly"""
         pass


      @property
      def Rto(self)->'str':
         """- The strings need to be space padded to 16 chars exactly"""
         pass


      @property
      def Sto(self)->'str':
         """- The strings need to be space padded to 16 chars exactly"""
         pass


      @property
      def Lana_num(self)->'typing.Any':
         """"""
         pass


      @property
      def Cmd_cplt(self)->'typing.Any':
         """"""
         pass


      @property
      def Event(self)->'typing.Any':
         """"""
         pass


      @property
      def Post(self)->'typing.Any':
         """"""
         pass


class PRINTER_DEFAULTS(object):
      """A dictionary representing a PRINTER_DEFAULTS structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def pDatatype(self)->'str':
         """Data type to be used for print jobs, see win32print::EnumPrintProcessorDatatypes, optional, can be None"""
         pass


      @property
      def pDevMode(self)->'PyDEVMODE':
         """A PyDEVMODE that specifies default printer parameters, optional, can be None"""
         pass


      @property
      def DesiredAccess(self)->'typing.Any':
         """An ACCESS_MASK specifying what level of access is needed, eg PRINTER_ACCESS_ADMINISTER, PRINTER_ACCESS_USE"""
         pass


class PyACL(object):
      """A Python object, representing a ACL structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,) -> 'None':
         """
         Initialize the ACL.

Args:



Returns:

      None
        
         """
         pass


      def IsValid(self,) -> 'None':
         """
         Determines if the ACL is valid (IsValidAcl)

Args:



Returns:

      None
        
         """
         pass


      def AddAccessAllowedAce(self,revision:'typing.Any',access:'typing.Any',sid:'PySID',access1:'typing.Any',sid1:'typing.Any') -> 'None':
         """
         Adds an access-allowed ACE to an DACL object. The access is granted to a 

specified SID.

Args:

      revision(typing.Any):Pre-win2k, must be ACL_REVISION, otherwise also may be ACL_REVISION_DS.
      access(typing.Any):Specifies the mask of access rights to be denied to the specified SID.
      sid(PySID):A SID object representing a user, group, or logon account being denied access.Alternative Parameters
      access1(typing.Any):Specifies the mask of access rights to be denied to the specified SID.
      sid1(typing.Any):A SID object representing a user, group, or logon account being denied access.CommentsNote that early versions of this function supported only two arguments.  This has been deprecated in preference of the three argument version, which reflects the win32 API and the new functions in this module.

Returns:

      None
        
         """
         pass


      def AddAccessAllowedAceEx(self,revision:'typing.Any',aceflags:'typing.Any',access:'typing.Any',sid:'PySID') -> 'None':
         """
         Add access allowed ACE to an ACL with ACE flags (Requires Win2k or higher)

Args:

      revision(typing.Any):Must be at least ACL_REVISION_DS
      aceflags(typing.Any):Combination of ACE inheritance flags (CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE, and OBJECT_INHERIT_ACE)
      access(typing.Any):Specifies the mask of access rights to be granted to the specified SID.
      sid(PySID):A SID object representing a user, group, or logon account being granted access.

Returns:

      None
        
         """
         pass


      def AddAccessAllowedObjectAce(self,AceRevision:'typing.Any',AceFlags:'typing.Any',AccessMask:'typing.Any',ObjectTypeGuid:'PyIID',InheritedObjectTypeGuid:'PyIID',sid:'PySID') -> 'None':
         """
         Adds an ACCESS_ALLOWED_OBJECT_ACE to the ACL

Args:

      AceRevision(typing.Any):Must be at least ACL_REVISION_DS
      AceFlags(typing.Any):Combination of ACE inheritance flags (CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE, and OBJECT_INHERIT_ACE)
      AccessMask(typing.Any):Specifies the mask of access rights to be granted to the specified SID
      ObjectTypeGuid(PyIID):GUID of object type or property set to which ace applies, can be None
      InheritedObjectTypeGuid(PyIID):GUID of object type or property that will inherit ACE, can be None
      sid(PySID):A SID object representing a user, group, or logon account being granted access.

Returns:

      None
        
         """
         pass


      def AddAccessDeniedAce(self,revision:'typing.Any',access:'typing.Any',sid:'PySID',access1:'typing.Any',sid1:'typing.Any') -> 'None':
         """
         Adds an access-denied ACE to an ACL object. The access is denied to a specified 

SID.

Args:

      revision(typing.Any):Pre-win2k, must be ACL_REVISION, otherwise also may be ACL_REVISION_DS.
      access(typing.Any):Specifies the mask of access rights to be denied to the specified SID.
      sid(PySID):A SID object representing a user, group, or logon account being denied access.Alternative Parameters
      access1(typing.Any):Specifies the mask of access rights to be denied to the specified SID.
      sid1(typing.Any):A SID object representing a user, group, or logon account being denied access.CommentsNote that early versions of this function supported only two arguments.  This has been deprecated in preference of the three argument version, which reflects the win32 API and the new functions in this module.

Returns:

      None
        
         """
         pass


      def AddAccessDeniedAceEx(self,revision:'typing.Any',aceflags:'typing.Any',access:'typing.Any',sid:'PySID') -> 'None':
         """
         Add access denied ACE to an ACL with ACE flags (Requires Win2k or higher)

Args:

      revision(typing.Any):Must be at least ACL_REVISION_DS
      aceflags(typing.Any):Combination of ACE inheritance flags (CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE, and OBJECT_INHERIT_ACE)
      access(typing.Any):Specifies the mask of access rights to be denied to the specified SID.
      sid(PySID):A SID object representing a user, group, or logon account being denied access.

Returns:

      None
        
         """
         pass


      def AddMandatoryAce(self,AceRevision:'typing.Any',AceFlags:'typing.Any',MandatoryPolicy:'typing.Any',LabelSid:'PySID') -> 'None':
         """
         Adds a mandatory integrity level ACE to a SACL

Args:

      AceRevision(typing.Any):ACL_REVISION or ACL_REVISION_DS
      AceFlags(typing.Any):Combination of ACE inheritance flags (CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE, and OBJECT_INHERIT_ACE)
      MandatoryPolicy(typing.Any):Access policy for processes with lower integrity level, combination of SYSTEM_MANDATORY_LABEL_* flags
      LabelSid(PySID):Integrity level SID.  This can be created using CreateWellKnownSid with Win*LabelSid. Also can be constructed manually using SECURITY_MANDATORY_LABEL_AUTHORITY and a SECURITY_MANDATORY_*_RID

Returns:

      None
        
         """
         pass


      def AddAuditAccessAce(self,dwAceRevision:'typing.Any',dwAccessMask:'typing.Any',sid:'PySID',bAuditSuccess:'typing.Any',bAuditFailure:'typing.Any') -> 'None':
         """
         Adds an audit ACE to a Sacl

Args:

      dwAceRevision(typing.Any):Revision of ACL: Pre-Win2k, must be ACL_REVISION. Win2K on up, can also be ACL_REVISION_DS
      dwAccessMask(typing.Any):Bitmask of access types to be audited
      sid(PySID):SID for whom system audit messages will be generated
      bAuditSuccess(typing.Any):Set to 1 if access success should be audited, else 0
      bAuditFailure(typing.Any):Set to 1 if access failure should be audited, else 0

Returns:

      None
        
         """
         pass


      def AddAuditAccessAceEx(self,dwAceRevision:'typing.Any',AceFlags:'typing.Any',dwAccessMask:'typing.Any',sid:'PySID',bAuditSuccess:'typing.Any',bAuditFailure:'typing.Any') -> 'None':
         """
         Adds an audit ACE to an Sacl, includes ace flags

Args:

      dwAceRevision(typing.Any):Revision of ACL: Must be at least ACL_REVISION_DS
      AceFlags(typing.Any):Combination of FAILED_ACCESS_ACE_FLAG,SUCCESSFUL_ACCESS_ACE_FLAG,CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE and OBJECT_INHERIT_ACE
      dwAccessMask(typing.Any):Bitmask of access types to be audited
      sid(PySID):SID for whom system audit messages will be generated
      bAuditSuccess(typing.Any):Set to 1 if access success should be audited, else 0
      bAuditFailure(typing.Any):Set to 1 if access failure should be audited, else 0

Returns:

      None
        
         """
         pass


      def AddAuditAccessObjectAce(self,dwAceRevision:'typing.Any',AceFlags:'typing.Any',dwAccessMask:'typing.Any',ObjectTypeGuid:'PyIID',InheritedObjectTypeGuid:'PyIID',sid:'PySID',bAuditSuccess:'typing.Any',bAuditFailure:'typing.Any') -> 'None':
         """
         Adds an audit ACE for an object type identified by GUID

Args:

      dwAceRevision(typing.Any):Revision of ACL: Must be at least ACL_REVISION_DS
      AceFlags(typing.Any):Combination of FAILED_ACCESS_ACE_FLAG,SUCCESSFUL_ACCESS_ACE_FLAG,CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE and OBJECT_INHERIT_ACE
      dwAccessMask(typing.Any):Bitmask of access types to be audited
      ObjectTypeGuid(PyIID):GUID of object type or property set to which ace applies, can be None
      InheritedObjectTypeGuid(PyIID):GUID of object type or property that will inherit ACE, can be None
      sid(PySID):SID for whom system audit messages will be generated
      bAuditSuccess(typing.Any):Set to 1 if access success should be audited, else 0
      bAuditFailure(typing.Any):Set to 1 if access failure should be audited, else 0

Returns:

      None
        
         """
         pass


      def GetAclSize(self,) -> 'typing.Any':
         """
         Returns the storage size of the ACL.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetAclRevision(self,) -> 'typing.Any':
         """
         Returns revision of the ACL.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetAceCount(self,) -> 'typing.Any':
         """
         Returns the number of ACEs in the ACL.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetAce(self,index:'typing.Any') -> 'typing.Any':
         """
         Gets an Ace from the ACL

Args:

      index(typing.Any):Zero-based index of the ACE to retrieve.Return ValueConventional ACE's (types ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE, SYSTEM_AUDIT_ACE) are returned as a tuple of:Items[0] (int, int) : aceType, AceFlags[1] int : Mask[2] PySID : sidObject ACE's (types ACCESS_ALLOWED_OBJECT_ACE, ACCESS_DENIED_OBJECT_ACE, SYSTEM_AUDIT_OBJECT_ACE) are returned as a tuple:[0] (int, int) : aceType, AceFlags[1] int : mask[2] PyIID : ObjectType[3] PyIID : InheritedObjectType[4] PySID : sidFor details see the API documentation.

Returns:

      typing.Any:Zero-based index of the ACE to retrieve.Return ValueConventional ACE's (types ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE, SYSTEM_AUDIT_ACE) are returned 

as a tuple of:
Items[0] (int, int) : aceType, AceFlags

[1] int : Mask

[2] PySID : sid
Object ACE's (types ACCESS_ALLOWED_OBJECT_ACE, ACCESS_DENIED_OBJECT_ACE, SYSTEM_AUDIT_OBJECT_ACE) 

are returned as a tuple:
[0] (int, int) : aceType, AceFlags

[1] int : mask

[2] PyIID : ObjectType

[3] PyIID : InheritedObjectType

[4] PySID : sid
For details see the API documentation.

        
         """
         pass


      def DeleteAce(self,index:'typing.Any') -> 'None':
         """
         Deletes specified Ace from an ACL.

Args:

      index(typing.Any):Zero-based index of the ACE to delete.

Returns:

      None
        
         """
         pass


      def GetEffectiveRightsFromAcl(self,trustee:'PyTRUSTEE') -> 'typing.Any':
         """
         Return access rights (ACCESS_MASK) that the ACL grants to 

specified trustee

Args:

      trustee(PyTRUSTEE):Dictionary representing a TRUSTEE structure

Returns:

      typing.Any
        
         """
         pass


      def GetAuditedPermissionsFromAcl(self,trustee:'PyTRUSTEE') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Return types of access for 

which ACL will generate an audit event for specified trustee

Args:

      trustee(PyTRUSTEE):Dictionary representing a TRUSTEE structureCommentsThis function is known to return the success and failure access masks in the the wrong order on Windows 2000 service pack 4.  Problem has been reported to Microsoft.

Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


class PyBITMAP(object):
      """A Python object, representing an PyBITMAP structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def bmType(self)->'int':
         """"""
         pass


      @property
      def bmWidth(self)->'int':
         """"""
         pass


      @property
      def bmHeight(self)->'int':
         """"""
         pass


      @property
      def bmWidthBytes(self)->'int':
         """"""
         pass


      @property
      def bmPlanes(self)->'int':
         """"""
         pass


class PyBLENDFUNCTION(object):
      """Tuple of four small ints used to fill a BLENDFUNCTION struct 

Each int must fit in a byte (0-255)."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCEHANDLE(object):
      """A Python object, representing a remote Windows CE handle"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCERTSTORE(object):
      """Handle to a certificate store"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def HCERTSTORE(self)->'typing.Any':
         """Integer handle"""
         pass


      def CertCloseStore(self,Flags:'typing.Any'=0) -> 'None':
         """
         Closes the certificate store

Args:

      Flags(typing.Any):Combination of CERT_CLOSE_*_FLAG flags

Returns:

      None
        
         """
         pass


      def CertControlStore(self,Flags:'typing.Any',CtrlType:'typing.Any',CtrlPara:'int') -> 'None':
         """
         Controls sychronization of the certificate store

Args:

      Flags(typing.Any):One of the CERT_STORE_CTRL_*_FLAG flags
      CtrlType(typing.Any):One of the CERT_STORE_CTRL_* flags
      CtrlPara(int):Event handle, can be None (not used with CERT_STORE_CTRL_COMMIT)

Returns:

      None
        
         """
         pass


      def CertEnumCertificatesInStore(self,) -> 'typing.List[PyCERT_CONTEXT]':
         """
         Lists all certificates in the store

Args:



Returns:

      typing.List[PyCERT_CONTEXT]
        
         """
         pass


      def CertEnumCTLsInStore(self,) -> 'typing.List[PyCTL_CONTEXT]':
         """
         Finds all Certificate Trust Lists in store

Args:



Returns:

      typing.List[PyCTL_CONTEXT]
        
         """
         pass


      def CertSaveStore(self,MsgAndCertEncodingType:'typing.Any',SaveAs:'typing.Any',SaveTo:'typing.Any',SaveToPara:'typing.Union[str, int]',Flags:'typing.Any'=0) -> 'None':
         """
         Serializes the store to memory or a file

Args:

      MsgAndCertEncodingType(typing.Any):Only used when saveas is CERT_STORE_SAVE_AS_PKCS7 - usually X509_ASN_ENCODING combined with PKCS_7_ASN_ENCODING
      SaveAs(typing.Any):One of the CERT_STORE_SAVE_AS_* constants
      SaveTo(typing.Any):One of the CERT_STORE_SAVE_TO_* constants (CERT_STORE_SAVE_TO_MEMORY not supported yet)
      SaveToPara(typing.Union[str, int]):File name or open file handle depending on SaveTo parm
      Flags(typing.Any):Reserved, use 0

Returns:

      None
        
         """
         pass


      def CertAddEncodedCertificateToStore(self,CertEncodingType:'typing.Any',CertEncoded:'typing.Any',AddDisposition:'typing.Any') -> 'PyCERT_CONTEXT':
         """
         Imports an encoded certificate into the 

store

Args:

      CertEncodingType(typing.Any):Usually X509_ASN_ENCODING combined with PKCS_7_ASN_ENCODING
      CertEncoded(typing.Any):Data containing a serialized certificate
      AddDisposition(typing.Any):Combination of CERT_STORE_ADD_* flags

Returns:

      PyCERT_CONTEXT
        
         """
         pass


      def CertAddCertificateContextToStore(self,CertContext:'PyCERT_CONTEXT',AddDisposition:'typing.Any') -> 'PyCERT_CONTEXT':
         """
         Adds a certificate context to the store

Args:

      CertContext(PyCERT_CONTEXT):Certificate context to be added
      AddDisposition(typing.Any):CERT_STORE_ADD_* constant

Returns:

      PyCERT_CONTEXT
        
         """
         pass


      def CertAddCertificateLinkToStore(self,CertContext:'PyCERT_CONTEXT',AddDisposition:'typing.Any') -> 'PyCERT_CONTEXT':
         """
         Adds a link to a cert in another store

Args:

      CertContext(PyCERT_CONTEXT):Certificate context to be linked
      AddDisposition(typing.Any):One of the CERT_STORE_ADD_* values

Returns:

      PyCERT_CONTEXT
        
         """
         pass


      def CertAddCTLContextToStore(self,CtlContext:'PyCTL_CONTEXT',AddDisposition:'typing.Any') -> 'PyCTL_CONTEXT':
         """
         Adds a certificate trust list to the store

Args:

      CtlContext(PyCTL_CONTEXT):CTL to be added
      AddDisposition(typing.Any):CERT_STORE_ADD_* constant

Returns:

      PyCTL_CONTEXT
        
         """
         pass


      def CertAddCTLLinkToStore(self,CtlContext:'PyCTL_CONTEXT',AddDisposition:'typing.Any') -> 'PyCTL_CONTEXT':
         """
         Adds a link to a CTL in another store

Args:

      CtlContext(PyCTL_CONTEXT):CTL to be linked
      AddDisposition(typing.Any):One of the CERT_STORE_ADD_* values

Returns:

      PyCTL_CONTEXT
        
         """
         pass


      def CertAddStoreToCollection(self,SiblingStore:'PyCERTSTORE',UpdateFlag:'typing.Any'=0,Priority:'typing.Any'=0) -> 'None':
         """
         Adds a sibling store to a store collection

Args:

      SiblingStore(PyCERTSTORE):Store to be added to the collection
      UpdateFlag(typing.Any):Can be CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG to enable changes to persist
      Priority(typing.Any):Determines order in which store are searched and updatedCommentsA collection store is created by using cryptoapi::CertOpenStore with CERT_STORE_PROV_COLLECTION

Returns:

      None
        
         """
         pass


      def CertRemoveStoreFromCollection(self,SiblingStore:'PyCERTSTORE') -> 'None':
         """
         Removes a sibling store from a collection

Args:

      SiblingStore(PyCERTSTORE):Store to be removed from the collection

Returns:

      None
        
         """
         pass


      def PFXExportCertStoreEx(self,Flags:'typing.Any',Password:'typing.Any'=None) -> 'typing.Any':
         """
         Exports certificates and associated private keys in PKCS#12 format

Args:

      Flags(typing.Any):Options to be used while exporting
      Password(typing.Any):Passphrase to be used to encrypt the output

Returns:

      typing.Any
        
         """
         pass


class PyCERT_ALT_NAME_ENTRY(object):
      """Represented as a 2-tuple"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCERT_ALT_NAME_INFO(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCERT_AUTHORITY_KEY_ID_INFO(object):
      """Dict containing the identity of a CA"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def KeyId(self)->'typing.Any':
         """Unique identifier of private key, usually a hash"""
         pass


      @property
      def CertIssuer(self)->'typing.Any':
         """Encoded DN of the Certificate Authority.  Decode using X509_UNICODE_NAME"""
         pass


      @property
      def CertSerialNumber(self)->'typing.Any':
         """Serial nbr of the CA's signing certificate"""
         pass


class PyCERT_BASIC_CONSTRAINTS2_INFO(object):
      """Dict representing a CERT_BASIC_CONSTRAINTS2_INFO struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def fCA(self)->'typing.Any':
         """Indicates if cert represents a certificate authority"""
         pass


      @property
      def fPathLenConstraint(self)->'typing.Any':
         """Indicates if PathLenConstraint member is used"""
         pass


      @property
      def PathLenConstraint(self)->'typing.Any':
         """Limits number of intermediate CA's between root CA and end user"""
         pass


class PyCERT_BASIC_CONSTRAINTS_INFO(object):
      """Dict representing a CERT_BASIC_CONSTRAINTS_INFO struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def SubjectType(self)->'PyCRYPT_BIT_BLOB':
         """Contains a combination of CERT_CA_SUBJECT_FLAG,CERT_END_ENTITY_SUBJECT_FLAG"""
         pass


      @property
      def fPathLenConstraint(self)->'typing.Any':
         """Indicates if PathLenConstraint member is used"""
         pass


      @property
      def PathLenConstraint(self)->'typing.Any':
         """Limits number of intermediate CA's between root CA and end user"""
         pass


      @property
      def SubtreesConstraint(self)->'typing.Any':
         """Sequence of encoded name blobs"""
         pass


class PyCERT_CONTEXT(object):
      """Handle to a certificate context"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def HANDLE(self)->'typing.Any':
         """Pointer to CERT_CONTEXT struct"""
         pass


      @property
      def CertStore(self)->'PyCERTSTORE':
         """Handle to the certificate store that contains this certificate"""
         pass


      @property
      def CertEncoded(self)->'typing.Any':
         """Content of the certificate as encoded bytes"""
         pass


      @property
      def CertEncodingType(self)->'typing.Any':
         """Method used to encode the certifcate, usually X509_ASN_ENCODING or PKCS_7_ASN_ENCODING"""
         pass


      @property
      def Version(self)->'typing.Any':
         """One of the CERT_V* values"""
         pass


      @property
      def Subject(self)->'str':
         """Encoded CERT_NAME_INFO struct containing the subject name. Can be decoded using cryptoapi::CryptDecodeObjectEx with X509_UNICODE_NAME, or formatted using cryptoapi::CertNameToStr"""
         pass


      @property
      def Issuer(self)->'str':
         """Certificate Authority that issued certificate as encoded CERT_NAME_INFO.  Use cryptoapi::CryptDecodeObjectEx to decode into individual components, or cryptoapi::CertNameToStr to return a single formatted string"""
         pass


      @property
      def NotBefore(self)->'PyTime':
         """Beginning of certificate's period of validity"""
         pass


      @property
      def NotAfter(self)->'PyTime':
         """End of certificate's period of validity"""
         pass


      @property
      def SignatureAlgorithm(self)->'typing.Any':
         """Object id of the certifcate's signature algorithm"""
         pass


      @property
      def Extension(self)->'typing.Tuple[PyCERT_EXTENSION, ...]':
         """Sequence of CERT_EXTENSION dicts containing certificate's extensions"""
         pass


      @property
      def SubjectPublicKeyInfo(self)->'PyCERT_PUBLIC_KEY_INFO':
         """Encoded public key of certificate"""
         pass


      @property
      def SerialNumber(self)->'typing.Any':
         """Serial number assigned by the issuer"""
         pass


      def CertFreeCertificateContext(self,) -> 'None':
         """
         Frees the certificate context

Args:



Returns:

      None
        
         """
         pass


      def CertEnumCertificateContextProperties(self,) -> 'typing.List[typing.Any]':
         """
         Lists property ids for the certificate

Args:



Returns:

      typing.List[typing.Any]
        
         """
         pass


      def CryptAcquireCertificatePrivateKey(self,Flags:'typing.Any'=0) -> 'typing.Tuple[typing.Any, PyCRYPTPROV]':
         """
         Retrieves the private key associated 

with the certificate

Args:

      Flags(typing.Any):Combination of CRYPT_ACQUIRE_*_FLAG constantsCommentsOnly the owner of the certificate can use this methodReturn ValueReturns the KeySpec (AT_KEYEXCHANGE or AT_SIGNATURE) and a CSP handle to the key

Returns:

      typing.Tuple[typing.Any, PyCRYPTPROV]:Combination of CRYPT_ACQUIRE_*_FLAG constants
Comments

Only the owner of the certificate can use this method
Return ValueReturns the KeySpec (AT_KEYEXCHANGE or AT_SIGNATURE) and a CSP handle to the key

        
         """
         pass


      def CertGetIntendedKeyUsage(self,) -> 'typing.Any':
         """
         Returns the intended key usage from the certificate extensions 

(szOID_KEY_USAGE or szOID_KEY_ATTRIBUTES)

Args:



Returns:

      typing.Any:PyCERT_CONTEXT.CertGetIntendedKeyUsage

int = CertGetIntendedKeyUsage()Returns the intended key usage from the certificate extensions 

(szOID_KEY_USAGE or szOID_KEY_ATTRIBUTES)
Return ValueReturns a combination of CERT_*_KEY_USAGE values

        
         """
         pass


      def CertGetEnhancedKeyUsage(self,Flags:'typing.Any'=0) -> 'typing.Any':
         """
         Finds the enhanced key usage property and/or extension for the 

certificate

Args:

      Flags(typing.Any):CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, or 0Return ValueReturns a sequence of usage OIDs

Returns:

      typing.Any:CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, 

CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, or 0
Return ValueReturns a sequence of usage OIDs

        
         """
         pass


      def CertSerializeCertificateStoreElement(self,Flags:'typing.Any'=0) -> 'str':
         """
         Serializes the certificate and its properties

Args:

      Flags(typing.Any):Reserved, use only 0 if passed in

Returns:

      str
        
         """
         pass


      def CertVerifySubjectCertificateContext(self,Issuer:'PyCERT_CONTEXT',Flags:'typing.Any') -> 'typing.Any':
         """
         Checks the validity of the certificate

Args:

      Issuer(PyCERT_CONTEXT):Certificate of authority that issued the certificate
      Flags(typing.Any):Combination of CERT_STORE_REVOCATION_FLAG,CERT_STORE_SIGNATURE_FLAG and CERT_STORE_TIME_VALIDITY_FLAG indicating which checks should be performedReturn ValueReturns flags indicating which validity checks failed, or 0 if all were successful.

Returns:

      typing.Any:Combination of CERT_STORE_REVOCATION_FLAG,CERT_STORE_SIGNATURE_FLAG and 

CERT_STORE_TIME_VALIDITY_FLAG indicating which checks should be performedReturn ValueReturns flags indicating which validity checks failed, or 0 if all were successful.

        
         """
         pass


      def CertDeleteCertificateFromStore(self,) -> 'None':
         """
         Removes the certificate from its store

Args:



Returns:

      None
        
         """
         pass


      def CertGetCertificateContextProperty(self,PropId:'typing.Any') -> 'typing.Any':
         """
         Retrieves the specified property from the 

certificate

Args:

      PropId(typing.Any):One of the CERT_*_PROP_ID constantsPropIdReturned valueCERT_ARCHIVED_PROP_IDBooleanCERT_DATE_STAMP_PROP_IDPyTimeCERT_ACCESS_STATE_PROP_IDintCERT_KEY_SPEC_PROP_IDintCERT_DESCRIPTION_PROP_IDUnicodeCERT_FRIENDLY_NAME_PROP_IDUnicodeCERT_PVK_FILE_PROP_IDUnicodeCERT_AUTO_ENROLL_PROP_IDUnicodeCERT_HASH_PROP_IDString containing a hashCERT_SHA1_HASH_PROP_IDString containing a hashCERT_MD5_HASH_PROP_IDString containing a hashCERT_SIGNATURE_HASH_PROP_IDString containing a hashCERT_KEY_IDENTIFIER_PROP_IDString containing a hashCERT_SUBJECT_NAME_MD5_HASH_PROP_IDString containing a hashCERT_KEY_PROV_HANDLE_PROP_IDPyCRYPTPROVCERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_IDString containing a hashCERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_IDString containing a hashCERT_CTL_USAGE_PROP_IDEncoded CTL_USAGE, decode as X509_ENHANCED_KEY_USAGE (CTL_USAGE and CERT_ENHKEY_USAGE are identical)CERT_ENHKEY_USAGE_PROP_IDEncoded CTL_USAGE. Can be decoded using cryptoapi::CryptDecodeObjectEx with X509_ENHANCED_KEY_USAGECERT_KEY_PROV_INFO_PROP_IDCRYPT_KEY_PROV_INFO dictCERT_KEY_CONTEXT_PROP_IDDict representing CERT_KEY_CONTEXT structCERT_NEXT_UPDATE_LOCATION_PROP_IDEncoded CERT_ALT_NAME_INFO, decode using cryptoapi::CryptDecodeObjectEx with szOID_NEXT_UPDATE_LOCATIONReturn ValueType of object returned is dependent on the property id requested.

Returns:

      typing.Any:One of the CERT_*_PROP_ID constants


PropId


Returned value



CERT_ARCHIVED_PROP_IDBoolean
CERT_DATE_STAMP_PROP_IDPyTime
CERT_ACCESS_STATE_PROP_IDint
CERT_KEY_SPEC_PROP_IDint
CERT_DESCRIPTION_PROP_IDUnicode
CERT_FRIENDLY_NAME_PROP_IDUnicode
CERT_PVK_FILE_PROP_IDUnicode
CERT_AUTO_ENROLL_PROP_IDUnicode
CERT_HASH_PROP_IDString containing a hash
CERT_SHA1_HASH_PROP_IDString containing a hash
CERT_MD5_HASH_PROP_IDString containing a hash
CERT_SIGNATURE_HASH_PROP_IDString containing a hash
CERT_KEY_IDENTIFIER_PROP_IDString containing a hash
CERT_SUBJECT_NAME_MD5_HASH_PROP_IDString containing a hash
CERT_KEY_PROV_HANDLE_PROP_IDPyCRYPTPROV
CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_IDString 

containing a hash
CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_IDString 

containing a hash
CERT_CTL_USAGE_PROP_IDEncoded CTL_USAGE, decode as X509_ENHANCED_KEY_USAGE (CTL_USAGE and 

CERT_ENHKEY_USAGE are identical)
CERT_ENHKEY_USAGE_PROP_IDEncoded CTL_USAGE. Can be decoded using cryptoapi::CryptDecodeObjectEx



 

with X509_ENHANCED_KEY_USAGE
CERT_KEY_PROV_INFO_PROP_IDCRYPT_KEY_PROV_INFO dict
CERT_KEY_CONTEXT_PROP_IDDict representing CERT_KEY_CONTEXT struct
CERT_NEXT_UPDATE_LOCATION_PROP_IDEncoded CERT_ALT_NAME_INFO, decode using cryptoapi::CryptDecodeObjectEx



 with szOID_NEXT_UPDATE_LOCATION
Return ValueType of object returned is dependent on the property id requested.

        
         """
         pass


      def CertSetCertificateContextProperty(self,PropId:'typing.Any',Data:'typing.Any',Flags:'typing.Any'=0) -> 'None':
         """
         Sets a property for a certificate

Args:

      PropId(typing.Any):Id of property to be set, CERT_*_PROP_ID
      Data(typing.Any):The value to be set for the property.  Type is dependent on PropId. Use None to delete a property.
      Flags(typing.Any):Combination of CERT_SET_* flagsPropIdType of inputCERT_ARCHIVED_PROP_IDNone causes Archived flag to be cleared, any other causes it to be set no actual data, non-NULL pvData indicates presence of flagCERT_DATE_STAMP_PROP_IDPyTime specifying when cert was added to storeCERT_DESCRIPTION_PROP_IDUnicode stringCERT_FRIENDLY_NAME_PROP_IDUnicode stringCERT_PVK_FILE_PROP_IDUnicode stringCERT_AUTO_ENROLL_PROP_IDUnicode stringCERT_KEY_SPEC_PROP_IDInt, usually AT_KEYEXCHANGE or AT_SIGNATURECERT_HASH_PROP_IDString containing the hashCERT_SHA1_HASH_PROP_IDString containing the hashCERT_MD5_HASH_PROP_IDString containingg the hashCERT_SIGNATURE_HASH_PROP_IDString containing the hashCERT_KEY_IDENTIFIER_PROP_IDString containing the key idCERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_IDString containing the hashCERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_IDString containing the hashCERT_SUBJECT_NAME_MD5_HASH_PROP_IDString containing the hashCERT_RENEWAL_PROP_IDString containing the hashCERT_ENHKEY_USAGE_PROP_IDString containing an encoded PyCTL_USAGE.  Use cryptoapi::CryptEncodeObjectEx with X509_ENHANCED_KEY_USAGE.CERT_CTL_USAGE_PROP_IDSame as CERT_ENHKEY_USAGE_PROP_ID

Returns:

      None
        
         """
         pass


class PyCERT_EXTENSION(object):
      """Dict containing a certificate extension"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ObjId(self)->'typing.Any':
         """The OID identifying the type of extension"""
         pass


      @property
      def Critical(self)->'typing.Any':
         """If true, any contraints or limits contained in the extension should be considered absolute"""
         pass


      @property
      def Value(self)->'typing.Any':
         """Binary string containing ASN encoded data. To interpret or display extension data, see cryptoapi::CryptDecodeObjectEx and cryptoapi::CryptFormatObject."""
         pass


class PyCERT_KEY_ATTRIBUTES_INFO(object):
      """Dict representing a CERT_KEY_ATTRIBUTES_INFO struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def KeyId(self)->'typing.Any':
         """Usually a hash that uniquely identifies the key"""
         pass


      @property
      def IntendedKeyUsage(self)->'PyCRYPT_BIT_BLOB':
         """Contains a byte with CERT_*_KEY_USAGE flags"""
         pass


      @property
      def PrivateKeyUsagePeriod(self)->'typing.Any':
         """Private key's begin and end effective dates, may be None"""
         pass


class PyCERT_NAME_INFO(object):
      """Sequence of CERT_RDN's"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCERT_NAME_VALUE(object):
      """Dict containing type (CERT_RDN_*) and a unicode string"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCERT_OTHER_NAME(object):
      """Dict containing {ObjId, Value}. 

ObjId is one of the string object id's identifying the type of name. 

Value is a binary string containing an encoded CERT_NAME_VALUE that can be decoded 

using X509_UNICODE_NAME_VALUE to return the actual unicode string"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCERT_POLICY_INFO(object):
      """Dict containing a certificate policy"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def PolicyIdentifier(self)->'typing.Any':
         """OID identifying the policy"""
         pass


      @property
      def PolicyQualifier(self)->'typing.Any':
         """Sequence of CERT_POLICY_QUALIFIER dicts"""
         pass


class PyCERT_PUBLIC_KEY_INFO(object):
      """Dict containing an exported public key"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Algorithm(self)->'PyCRYPT_ALGORITHM_IDENTIFIER':
         """Dict containing OID of the public key algorithm"""
         pass


      @property
      def PublicKey(self)->'PyCRYPT_BIT_BLOB':
         """Dict containing the encoded public key"""
         pass


class PyCOMSTAT(object):
      """A Python object, representing an COMSTAT structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def cbInQue(self)->'int':
         """Specifies the number of bytes received by the serial provider but not yet read by a win32file::ReadFile operation"""
         pass


      @property
      def cbOutQue(self)->'int':
         """Specifies the number of bytes of user data remaining to be transmitted for all write operations. This value will be zero for a nonoverlapped write."""
         pass


      @property
      def fCtsHold(self)->'int':
         """Specifies whether transmission is waiting for the CTS (clear-to-send) signal to be sent. If this member is TRUE, transmission is waiting."""
         pass


      @property
      def fDsrHold(self)->'int':
         """Specifies whether transmission is waiting for the DSR (data-set-ready) signal to be sent. If this member is TRUE, transmission is waiting."""
         pass


      @property
      def fRlsdHold(self)->'int':
         """Specifies whether transmission is waiting for the RLSD (receive-line-signal-detect) signal to be sent. If this member is TRUE, transmission is waiting."""
         pass


      @property
      def fXoffHold(self)->'int':
         """Specifies whether transmission is waiting because the XOFF character was received. If this member is TRUE, transmission is waiting."""
         pass


      @property
      def fXoffSent(self)->'int':
         """Specifies whether transmission is waiting because the XOFF character was transmitted. If this member is TRUE, transmission is waiting. Transmission halts when the XOFF character is transmitted to a system that takes the next character as XON, regardless of the actual character."""
         pass


      @property
      def fEof(self)->'int':
         """Specifies whether the end-of-file (EOF) character has been received. If this member is TRUE, the EOF character has been received."""
         pass


      @property
      def fTxim(self)->'int':
         """If this member is TRUE, there is a character queued for transmission that has come to the communications device by way of the TransmitCommChar function. The communications device transmits such a character ahead of other characters in the device's output buffer."""
         pass


      @property
      def fReserved(self)->'int':
         """Reserved; do not use."""
         pass


class PyCOORD(object):
      """Wrapper for a COORD struct.  Create using PyCOORDType(X,Y)"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def X(self)->'typing.Any':
         """Horizontal coordinate"""
         pass


      @property
      def Y(self)->'typing.Any':
         """Vertical coordinate"""
         pass


class PyCREDENTIAL(object):
      """A dictionary containing information for a CREDENTIAL struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Flags(self)->'typing.Any':
         """Combination of CRED_FLAGS_PROMPT_NOW, CRED_FLAGS_USERNAME_TARGET"""
         pass


      @property
      def Type(self)->'typing.Any':
         """Type of credential, one of CRED_TYPE_* values"""
         pass


      @property
      def TargetName(self)->'str':
         """Target of credential, can end with * for wildcard matching"""
         pass


      @property
      def Comment(self)->'str':
         """Descriptive text"""
         pass


      @property
      def LastWritten(self)->'PyTime':
         """Modification time, ignored on input"""
         pass


      @property
      def CredentialBlob(self)->'str':
         """Contains password for username credential, or PIN for certificate credential. This member is write-only."""
         pass


      @property
      def Persist(self)->'typing.Any':
         """Specifies scope of persistence, one of CRED_PERSIST_* values"""
         pass


      @property
      def Attributes(self)->'typing.Any':
         """Tuple of PyCREDENTIAL_ATTRIBUTE dicts containing application-specific data, can be None"""
         pass


      @property
      def TargetAlias(self)->'str':
         """Alias for TargetName, only valid with CRED_TYPE_GENERIC"""
         pass


      @property
      def UserName(self)->'str':
         """User to be authenticated by target. Can be of the form username@domain or domain\\username. For CRED_TYPE_DOMAIN_CERTIFICATE, use win32cred::CredMarshalCredential to marshal the SHA1 hash of user's certficate"""
         pass


class PyCREDENTIAL_ATTRIBUTE(object):
      """A dictionary containing information for a CREDENTIAL_ATTRIBUTE struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Keyword(self)->'str':
         """Attribute name, at most CRED_MAX_STRING_LENGTH chars"""
         pass


      @property
      def Flags(self)->'typing.Any':
         """Reserved, use only 0"""
         pass


      @property
      def Value(self)->'typing.Any':
         """Attribute value, at most CRED_MAX_VALUE_SIZE bytes.  Unicode objects are treated as raw bytes."""
         pass


class PyCREDENTIAL_TARGET_INFORMATION(object):
      """A dictionary representing a CREDENTIAL_TARGET_INFORMATION struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def TargetName(self)->'str':
         """Target of credentials"""
         pass


      @property
      def NetbiosServerName(self)->'str':
         """"""
         pass


      @property
      def DnsServerName(self)->'str':
         """"""
         pass


      @property
      def NetbiosDomainName(self)->'str':
         """"""
         pass


      @property
      def DnsDomainName(self)->'str':
         """"""
         pass


      @property
      def DnsTreeName(self)->'str':
         """"""
         pass


      @property
      def PackageName(self)->'str':
         """Name of security package which mapped TargetName"""
         pass


      @property
      def Flags(self)->'typing.Any':
         """CRED_TI_* flags"""
         pass


      @property
      def CredTypes(self)->'typing.Tuple[typing.Any, ...]':
         """Tuple of CRED_TYPE_* values indicating which types of credentials are acceptable to target"""
         pass


class PyCREDUI_INFO(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Parent(self)->'int':
         """Handle to parent window, can be None"""
         pass


      @property
      def MessageText(self)->'str':
         """Message to appear in dialog"""
         pass


      @property
      def CaptionText(self)->'str':
         """Title of the dialog window"""
         pass


      @property
      def Banner(self)->'int':
         """Handle to a bitmap to be displayed"""
         pass


class PyCRYPTHASH(object):
      """Handle to a cryptographic hash"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CryptDestroyHash(self,) -> 'None':
         """
         Frees the hash object

Args:



Returns:

      None
        
         """
         pass


      def CryptDuplicateHash(self,Flags:'typing.Any'=0) -> 'PyCRYPTHASH':
         """
         Clones the hash object

Args:

      Flags(typing.Any):Reserved, use 0 if passed

Returns:

      PyCRYPTHASH
        
         """
         pass


      def CryptHashData(self,Data:'str',Flags:'typing.Any'=0) -> 'None':
         """
         Adds data to the hash

Args:

      Data(str):Data to be hashed
      Flags(typing.Any):CRYPT_USERDATA or 0CommentsIf Flags is CRYPT_USERDATA, provider is expected to prompt user to enter data.  MSDN says that MS CSPs ignore this flag

Returns:

      None
        
         """
         pass


      def CryptHashSessionKey(self,Key:'PyCRYPTKEY',Flags:'typing.Any'=0) -> 'None':
         """
         Hashes a session key

Args:

      Key(PyCRYPTKEY):The session key to be hashed
      Flags(typing.Any):CRYPT_LITTLE_ENDIAN or 0

Returns:

      None
        
         """
         pass


      def CryptSignHash(self,KeySpec:'typing.Any',Flags:'typing.Any'=0) -> 'str':
         """
         Signs the hash

Args:

      KeySpec(typing.Any):The key to be used to sign the hash, AT_KEYEXCHANGE,AT_SIGNATURE
      Flags(typing.Any):CRYPT_NOHASHOID,CRYPT_X931_FORMAT or 0CommentsThis methods signs only the hash, not the data that the hash represents

Returns:

      str
        
         """
         pass


      def CryptVerifySignature(self,Signature:'str',PubKey:'PyCRYPTKEY',Flags:'typing.Any'=0) -> 'None':
         """
         Verifies that a signature matches hashed data

Args:

      Signature(str):Signature data to verify
      PubKey(PyCRYPTKEY):Public key of signer
      Flags(typing.Any):CRYPT_NOHASHOID,CRYPT_X931_FORMAT or 0

Returns:

      None
        
         """
         pass


      def CryptGetHashParam(self,Param:'typing.Any',Flags:'typing.Any'=0) -> 'typing.Union[typing.Any]':
         """
         Retrieves the specified attribute of the hash

Args:

      Param(typing.Any):The parameter to retrieve: HP_ALGID, HP_HASHSIZE, or HP_HASHVAL
      Flags(typing.Any):Reserved, use 0 if passed inCommentsAfter this method has been called, no more data can be hashedReturn ValueType of returned object is dependent on the Param passed in

Returns:

      typing.Union[typing.Any]:Reserved, use 0 if passed in
Comments

After this method has been called, no more data can be hashed
Return ValueType of returned object is dependent on the Param passed in

        
         """
         pass


class PyCRYPTKEY(object):
      """Handle to a cryptographic key"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def HCRYPTPROV(self)->'typing.Any':
         """CSP used by the key"""
         pass


      @property
      def HCRYPTKEY(self)->'typing.Any':
         """Plain integer handle to the key"""
         pass


      def CryptDestroyKey(self,) -> 'None':
         """
         Releases the handle to the key (does not delete permanent keys)

Args:



Returns:

      None
        
         """
         pass


      def CryptExportKey(self,ExpKey:'PyCRYPTKEY',BlobType:'typing.Any',Flags:'typing.Any'=0) -> 'typing.Any':
         """
         Exports key or key pair as an encrypted blob

Args:

      ExpKey(PyCRYPTKEY):Public key or session key of destination user.  Use None if exporting a PUBLICKEYBLOB
      BlobType(typing.Any):One of OPAQUEKEYBLOB,PRIVATEKEYBLOB,PUBLICKEYBLOB,SIMPLEBLOB,PLAINTEXTKEYBLOB,SYMMETRICWRAPKEYBLOB
      Flags(typing.Any):Combination of CRYPT_DESTROYKEY,CRYPT_SSL2_FALLBACK,CRYPT_OAEP or 0Return ValueReturns a binary blob that can be imported via PyCRYPTPROV::CryptImportKey

Returns:

      typing.Any:Combination of CRYPT_DESTROYKEY,CRYPT_SSL2_FALLBACK,CRYPT_OAEP or 0
Return ValueReturns a binary blob that can be imported via PyCRYPTPROV::CryptImportKey

        
         """
         pass


      def CryptGetKeyParam(self,Param:'typing.Any',Flags:'typing.Any'=0) -> 'typing.Any':
         """
         Retrieves key parameters

Args:

      Param(typing.Any):One of the KP_* constants
      Flags(typing.Any):Reserved, use only 0Return ValueType of returned object is dependent on the requested attribute

Returns:

      typing.Any:Reserved, use only 0
Return ValueType of returned object is dependent on the requested attribute

        
         """
         pass


      def CryptDuplicateKey(self,Reserved:'typing.Any'=0,Flags:'typing.Any'=0) -> 'PyCRYPTKEY':
         """
         Creates an independent copy of the key

Args:

      Reserved(typing.Any):Use 0 if passed in
      Flags(typing.Any):Also reserved, use 0

Returns:

      PyCRYPTKEY
        
         """
         pass


      def CryptEncrypt(self,Final:'typing.Any',Data:'typing.Any',Hash:'PyCRYPTHASH'=None,Flags:'typing.Any'=0) -> 'typing.Any':
         """
         Encrypts and optionally hashes data

Args:

      Final(typing.Any):Boolean, use True if this is final encryption operation
      Data(typing.Any):Data to be encrypted
      Hash(PyCRYPTHASH):Hash to be updated with data passed in, can be None
      Flags(typing.Any):Reserved, use 0 if passed in

Returns:

      typing.Any
        
         """
         pass


      def CryptDecrypt(self,Final:'typing.Any',Data:'typing.Any',Hash:'PyCRYPTHASH'=None,Flags:'typing.Any'=0) -> 'typing.Any':
         """
         Decrypts data

Args:

      Final(typing.Any):Boolean, use True is this is last (or only) operation
      Data(typing.Any):Data to be decrypted
      Hash(PyCRYPTHASH):Hash to be used in signature verification, can be None
      Flags(typing.Any):Reserved, use only 0

Returns:

      typing.Any
        
         """
         pass


class PyCRYPTMSG(object):
      """Wrapper for a cryptographic message handle"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def HCRYPTMSG(self)->'typing.Any':
         """Raw message handle"""
         pass


      def CryptMsgClose(self,) -> 'None':
         """
         Closes the message handle

Args:



Returns:

      None
        
         """
         pass


class PyCRYPTPROTECT_PROMPTSTRUCT(object):
      """A tuple representing a CRYPTPROTECT_PROMPTSTRUCT structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCRYPTPROV(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CryptReleaseContext(self,Flags:'typing.Any'=0) -> 'None':
         """
         Releases the CSP handle

Args:

      Flags(typing.Any):Reserved, use 0 if passed in

Returns:

      None
        
         """
         pass


      def CryptGenKey(self,Algid:'typing.Any',Flags:'typing.Any',KeyLen:'typing.Any'=0) -> 'PyCRYPTKEY':
         """
         Generates a key pair or a session key

Args:

      Algid(typing.Any):Algorithm identifier, one of the CALG_* values, or AT_KEYEXCHANGE/AT_SIGNATURE
      Flags(typing.Any):Combination of CRYPT_CREATE_SALT,CRYPT_EXPORTABLE,CRYPT_NO_SALT,CRYPT_PREGEN,CRYPT_USER_PROTECTED,CRYPT_ARCHIVABLE
      KeyLen(typing.Any):Length of key to generate, can be 0 to use provider's default key lengthCommentsDiffers from Api call in that the length is passed in separately

Returns:

      PyCRYPTKEY
        
         """
         pass


      def CryptGetProvParam(self,Param:'typing.Any',Flags:'typing.Any'=0) -> 'None':
         """
         Retrieves specified attribute of provider

Args:

      Param(typing.Any):One of the PP_* values
      Flags(typing.Any):If param if PP_KEYSET_SEC_DESCR, can be a combination of OWNER_SECURITY_INFORMATION,GROUP_SECURITY_INFORMATION,DACL_SECURITY_INFORMATION,SACL_SECURITY_INFORMATIONReturn ValueType of returned object is dependent on the attribute requested

Returns:

      None:If param if PP_KEYSET_SEC_DESCR, can be a combination of 

OWNER_SECURITY_INFORMATION,GROUP_SECURITY_INFORMATION,DACL_SECURITY_INFORMATION,SACL_SECURITY_INFORMATION
Return ValueType of returned object is dependent on the attribute requested

        
         """
         pass


      def CryptGetUserKey(self,KeySpec:'typing.Any') -> 'PyCRYPTKEY':
         """
         Returns a handle to one of user's key pairs

Args:

      KeySpec(typing.Any):AT_KEYEXCHANGE or AT_SIGNATURE (some providers may implement extra key specs)

Returns:

      PyCRYPTKEY
        
         """
         pass


      def CryptGenRandom(self,Len:'typing.Any',SeedData:'str'=None) -> 'str':
         """
         Generates random data of specified length

Args:

      Len(typing.Any):Number of bytes to generate
      SeedData(str):Random seed data

Returns:

      str
        
         """
         pass


      def CryptCreateHash(self,Algid:'typing.Any',Key:'PyCRYPTKEY'=None,Flags:'typing.Any'=0) -> 'PyCRYPTHASH':
         """
         Creates a hash object for hashing large amounts of data

Args:

      Algid(typing.Any):An algorithm identifier, CALG_*.
      Key(PyCRYPTKEY):Used only for keyed hashes (MAC or HMAC), use None otherwise
      Flags(typing.Any):Reserved, use 0 if passed in

Returns:

      PyCRYPTHASH
        
         """
         pass


      def CryptImportKey(self,Data:'typing.Any',PubKey:'PyCRYPTKEY'=None,Flags:'typing.Any'=0) -> 'PyCRYPTKEY':
         """
         None

Args:

      Data(typing.Any):The key blob to be imported
      PubKey(PyCRYPTKEY):Key to be used to decrypt the blob, not used for importing public keys
      Flags(typing.Any):Combination of CRYPT_EXPORTABLE, CRYPT_OAEP, CRYPT_NO_SALT, CRYPT_USER_PROTECTED

Returns:

      PyCRYPTKEY
        
         """
         pass


      def CryptExportPublicKeyInfo(self,KeySpec:'typing.Any',CertEncodingType:'typing.Any') -> 'PyCERT_PUBLIC_KEY_INFO':
         """
         Exports a public key to send to other users 

Returned dict can be serialized for sending to another python application using pickle.dump

Args:

      KeySpec(typing.Any):AT_KEYEXCHANGE or AT_SIGNATURE
      CertEncodingType(typing.Any):Specifies encoding for exported key info

Returns:

      PyCERT_PUBLIC_KEY_INFO
        
         """
         pass


      def CryptImportPublicKeyInfo(self,Info:'typing.Any',CertEncodingType:'typing.Any') -> 'PyCRYPTKEY':
         """
         Imports another user's public key

Args:

      Info(typing.Any):PyCERT_PUBLIC_KEY_INFO dictionary as returned by PyCRYPTPROV::CryptExportPublicKeyInfo
      CertEncodingType(typing.Any):Specifies encoding for exported key info

Returns:

      PyCRYPTKEY
        
         """
         pass


class PyCRYPT_ALGORITHM_IDENTIFIER(object):
      """Dictionary containing information that identifies an encryption 

algorithm and any extra parameters it requires"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ObjId(self)->'typing.Any':
         """An szOID_* string identifying the algorithm"""
         pass


      @property
      def Parameters(self)->'typing.Any':
         """Blob of binary data containing encoded parameters"""
         pass


class PyCRYPT_ATTRIBUTE(object):
      """Dict representing a CRYPT_ATTRIBUTE struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ObjId(self)->'typing.Any':
         """An szOID_* string identifying the attribute"""
         pass


      @property
      def Value(self)->'typing.Tuple[typing.Any, ...]':
         """A sequence of buffers containing the attribute values"""
         pass


class PyCRYPT_BIT_BLOB(object):
      """Dict containing raw data of a certain bit length"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Data(self)->'typing.Any':
         """Binary data"""
         pass


      @property
      def UnusedBits(self)->'typing.Any':
         """Nbr of bits of last byte that are unused"""
         pass


class PyCRYPT_DECRYPT_MESSAGE_PARA(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def CertStores(self)->'typing.Tuple[typing.Any, ...]':
         """Sequence of certificate stores to be searched for a certificate with a private key that can be used to decrypt the message"""
         pass


      @property
      def MsgAndCertEncodingType(self)->'typing.Any':
         """Encoding types, optional. Defaults to X509_ASN_ENCODING combined with PKCS_7_ASN_ENCODING"""
         pass


      @property
      def Flags(self)->'typing.Any':
         """Optional.  CRYPT_MESSAGE_SILENT_KEYSET_FLAG can be used to suppress any dialogs that might be triggered by accessing a key container, such as a request for a PIN."""
         pass


class PyCRYPT_ENCRYPT_MESSAGE_PARA(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ContentEncryptionAlgorithm(self)->'PyCRYPT_ALGORITHM_IDENTIFIER':
         """Identifies the algorithm to be used"""
         pass


      @property
      def CryptProv(self)->'PyCRYPTPROV':
         """Optional. Handle to provider that will perform encryption, can be None for default provider"""
         pass


      @property
      def EncryptionAuxInfo(self)->'typing.Any':
         """Optional. Extra info required by some CSP's.  Not supported yet, use only None"""
         pass


      @property
      def Flags(self)->'typing.Any':
         """Optional.  Combination of CRYPT_MESSAGE_*_FLAG constants"""
         pass


      @property
      def InnerContentType(self)->'typing.Any':
         """Optional.  Only used if message to be encrypted is already encoded"""
         pass


      @property
      def MsgEncodingType(self)->'typing.Any':
         """Optional.  Defaults to X509_ASN_ENCODING combined with PKCS_7_ASN_ENCODING"""
         pass


class PyCRYPT_SIGN_MESSAGE_PARA(object):
      """Dict of parms defining how a message will be signed"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def SigningCert(self)->'PyCERT_CONTEXT':
         """Certficate to be used to sign message"""
         pass


      @property
      def HashAlgorithm(self)->'PyCRYPT_ALGORITHM_IDENTIFIER':
         """Algorithm to be used for signed hash"""
         pass


      @property
      def HashAuxInfo(self)->'typing.Any':
         """Optional.  Param is reserved, use only None."""
         pass


      @property
      def MsgCert(self)->'typing.Tuple[PyCERT_CONTEXT, ...]':
         """Optional sequence of certificate to be included in the message."""
         pass


      @property
      def MsgCrl(self)->'typing.Tuple[typing.Any, ...]':
         """Optional. Sequence of certificate revocation lists. Not yet supported, use only None."""
         pass


      @property
      def AuthAttr(self)->'typing.Tuple[PyCRYPT_ATTRIBUTE, ...]':
         """Sequence of canonical attributes to be added to the message"""
         pass


      @property
      def UnauthAttr(self)->'typing.Tuple[PyCRYPT_ATTRIBUTE, ...]':
         """Sequence of arbitrary attributes"""
         pass


      @property
      def Flags(self)->'typing.Any':
         """Optional CRYPT_MESSAGE_*_FLAG that indicates content type if output is to be further encoded."""
         pass


      @property
      def InnerContentType(self)->'typing.Any':
         """Optional, one of the CMSG_* content types if message is already encoded, ."""
         pass


      @property
      def MsgEncodingType(self)->'typing.Any':
         """Encoding types, optional. Defaults to X509_ASN_ENCODING combined with PKCS_7_ASN_ENCODING"""
         pass


class PyCRYPT_VERIFY_MESSAGE_PARA(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def MsgAndCertEncodingType(self)->'typing.Any':
         """Encoding types, defaults to X509_ASN_ENCODING combined with PKCS_7_ASN_ENCODING"""
         pass


      @property
      def CryptProv(self)->'PyCRYPTPROV':
         """CSP to be used to verify signature. Use None for default provider."""
         pass


      @property
      def PyGetSignerCertificate(self)->'typing.Any':
         """Callback function that locates signer's certificate."""
         pass


      @property
      def GetArg(self)->'typing.Any':
         """Argument to be passed to above function, can be any object."""
         pass


class PyCTL_CONTEXT(object):
      """Object containing a Certificate Trust List"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def HCTL_CONTEXT(self)->'typing.Any':
         """Raw message handle"""
         pass


      def CertFreeCTLContext(self,) -> 'None':
         """
         Closes the CTL handle

Args:



Returns:

      None
        
         """
         pass


      def CertEnumCTLContextProperties(self,) -> 'typing.Tuple[typing.Any, ...]':
         """
         Lists property id's for the context

Args:



Returns:

      typing.Tuple[typing.Any, ...]
        
         """
         pass


      def CertEnumSubjectInSortedCTL(self,) -> 'typing.Tuple[typing.Tuple[typing.Any, typing.Any], ...]':
         """
         Retrieves trusted subjects contained in CRL

Args:



Returns:

      typing.Tuple[typing.Tuple[typing.Any, typing.Any], ...]:PyCTL_CONTEXT.CertEnumSubjectInSortedCTL

((str,str),...) = CertEnumSubjectInSortedCTL()Retrieves trusted subjects contained in CRL
Return ValueReturns a sequence of tuples containing two strings (SubjectIdentifier, EncodedAttributes)

        
         """
         pass


      def CertDeleteCTLFromStore(self,) -> 'None':
         """
         Removes the CTL from the store that it is contained in

Args:



Returns:

      None
        
         """
         pass


      def CertSerializeCTLStoreElement(self,Flags:'typing.Any'=0) -> 'str':
         """
         Serializes the CTL and its properties

Args:

      Flags(typing.Any):Reserved, use only 0 if passed in

Returns:

      str
        
         """
         pass


class PyCTL_USAGE(object):
      """Sequence of string OIDs (szOID_*).  This struct is identical to CERT_ENHKEY_USAGE."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyConsoleScreenBuffer(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetConsoleActiveScreenBuffer(self,) -> 'None':
         """
         Sets this handle as the currently displayed screen 

buffer

Args:



Returns:

      None
        
         """
         pass


      def GetConsoleCursorInfo(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Retrieves size and visibility of console's 

cursor

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]:PyConsoleScreenBuffer.GetConsoleCursorInfo

(Size, bVisible) = GetConsoleCursorInfo()Retrieves size and visibility of console's 

cursor
Return ValueReturns the size of the console's cursor expressed as a percentage of character size, and a boolen indicating 

if cursor is visible

        
         """
         pass


      def SetConsoleCursorInfo(self,Size:'typing.Any',Visible:'typing.Any') -> 'None':
         """
         Sets the size and visibility of console's cursor

Args:

      Size(typing.Any):Percentage of character size that cursor will occupy
      Visible(typing.Any):Determines if cursor is visible

Returns:

      None
        
         """
         pass


      def GetConsoleMode(self,) -> 'typing.Any':
         """
         Returns the input or output mode of the console buffer

Args:



Returns:

      typing.Any:PyConsoleScreenBuffer.GetConsoleMode

int = GetConsoleMode()Returns the input or output mode of the console buffer
Return ValueReturns a combination of ENABLE_*_INPUT or ENABLE_*_OUTPUT constants

        
         """
         pass


      def SetConsoleMode(self,Mode:'typing.Any') -> 'None':
         """
         Sets the input or output mode of the console buffer

Args:

      Mode(typing.Any):Combination of ENABLE_*_INPUT or ENABLE_*_OUTPUT constants

Returns:

      None
        
         """
         pass


      def ReadConsole(self,NumberOfCharsToRead:'typing.Any') -> 'typing.Any':
         """
         Reads characters from the console input buffer

Args:

      NumberOfCharsToRead(typing.Any):Characters to read

Returns:

      typing.Any
        
         """
         pass


      def WriteConsole(self,Buffer:'typing.Any') -> 'typing.Any':
         """
         Writes characters at current cursor position

Args:

      Buffer(typing.Any):String or Unicode to be written to consoleReturn ValueReturns the number of characters written

Returns:

      typing.Any:String or Unicode to be written to consoleReturn ValueReturns the number of characters written

        
         """
         pass


      def FlushConsoleInputBuffer(self,) -> 'None':
         """
         Flush input buffer

Args:



Returns:

      None
        
         """
         pass


      def SetConsoleTextAttribute(self,Attributes:'typing.Any') -> 'None':
         """
         Sets character attributes for subsequent write operations

Args:

      Attributes(typing.Any):Attributes to be set, combination of FOREGROUND_*, BACKGROUND_*, and COMMON_LVB_* constants

Returns:

      None
        
         """
         pass


      def SetConsoleCursorPosition(self,CursorPosition:'PyCOORD') -> 'None':
         """
         Sets the console screen buffer's cursor position

Args:

      CursorPosition(PyCOORD):A PyCOORD containing the new cursor position

Returns:

      None
        
         """
         pass


      def SetConsoleScreenBufferSize(self,Size:'PyCOORD') -> 'None':
         """
         Sets the size of the console screen buffer

Args:

      Size(PyCOORD):COORD object containing the new dimensions

Returns:

      None
        
         """
         pass


      def SetConsoleWindowInfo(self,Absolute:'typing.Any',ConsoleWindow:'PySMALL_RECT') -> 'None':
         """
         Changes size and position of a console's window

Args:

      Absolute(typing.Any):If False, coordinates are relative to current position
      ConsoleWindow(PySMALL_RECT):A SMALL_RECT containing the new window coordinates

Returns:

      None
        
         """
         pass


      def GetConsoleScreenBufferInfo(self,) -> 'typing.Any':
         """
         Returns the state of the screen buffer

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetLargestConsoleWindowSize(self,) -> 'PyCOORD':
         """
         Returns the largest possible size for the 

console's window

Args:



Returns:

      PyCOORD
        
         """
         pass


      def FillConsoleOutputAttribute(self,Attribute:'typing.Any',Length:'typing.Any',WriteCoord:'PyCOORD') -> 'typing.Any':
         """
         Set text attributes for a consecutive series of 

characters

Args:

      Attribute(typing.Any):Text attributes to be set, combination of FOREGROUND_*, BACKGROUND_*, and COMMON_LVB_* constants
      Length(typing.Any):The number of characters to set
      WriteCoord(PyCOORD):The screen position to begin atReturn ValueReturns the number of character cells whose attributes were set

Returns:

      typing.Any:The screen position to begin atReturn ValueReturns the number of character cells whose attributes were set

        
         """
         pass


      def FillConsoleOutputCharacter(self,Character:'typing.Any',Length:'typing.Any',WriteCoord:'PyCOORD') -> 'typing.Any':
         """
         Sets consecutive character positions to a specified 

character

Args:

      Character(typing.Any):A single character to be used to fill the specified range
      Length(typing.Any):The number of characters positions to fill
      WriteCoord(PyCOORD):The screen position to begin atReturn ValueReturns the number of characters actually written

Returns:

      typing.Any:The screen position to begin atReturn ValueReturns the number of characters actually written

        
         """
         pass


      def ReadConsoleOutputCharacter(self,Length:'typing.Any',ReadCoord:'PyCOORD') -> 'str':
         """
         Reads consecutive characters from a starting 

position

Args:

      Length(typing.Any):The number of characters positions to read
      ReadCoord(PyCOORD):The screen position start reading from

Returns:

      str
        
         """
         pass


      def ReadConsoleOutputAttribute(self,Length:'typing.Any',ReadCoord:'PyCOORD') -> 'typing.Tuple[typing.Any, ...]':
         """
         Retrieves attributes from consecutive character 

cells

Args:

      Length(typing.Any):The number of attributes to read
      ReadCoord(PyCOORD):The screen position from which to start readingReturn ValueReturns a sequence of ints containing the attributes of a range of characters

Returns:

      typing.Tuple[typing.Any, ...]:The screen position from which to start readingReturn ValueReturns a sequence of ints containing the attributes of a range of characters

        
         """
         pass


      def WriteConsoleOutputCharacter(self,Characters:'typing.Any',WriteCoord:'PyCOORD') -> 'typing.Any':
         """
         Writes a string of characters at a specified position

Args:

      Characters(typing.Any):Characters to be written
      WriteCoord(PyCOORD):The screen position at which to start writingReturn ValueReturns the number of characters actually written

Returns:

      typing.Any:The screen position at which to start writingReturn ValueReturns the number of characters actually written

        
         """
         pass


      def WriteConsoleOutputAttribute(self,Attributes:'typing.Tuple[typing.Any, ...]',WriteCoord:'PyCOORD') -> 'typing.Any':
         """
         Sets the attributes of a range of character cells

Args:

      Attributes(typing.Tuple[typing.Any, ...]):A sequence of ints containing the attributes to be set
      WriteCoord(PyCOORD):The screen position at which to start writingReturn ValueReturns the number of attributes set

Returns:

      typing.Any:The screen position at which to start writingReturn ValueReturns the number of attributes set

        
         """
         pass


      def ScrollConsoleScreenBuffer(self,ScrollRectangle:'PySMALL_RECT',ClipRectangle:'PySMALL_RECT',DestinationOrigin:'PyCOORD',FillCharacter:'typing.Any',FillAttribute:'typing.Any') -> 'None':
         """
         Scrolls a region of the display

Args:

      ScrollRectangle(PySMALL_RECT):The region to be scrolled
      ClipRectangle(PySMALL_RECT):Rectangle that limits display area affected, can be None
      DestinationOrigin(PyCOORD):The position to which ScrollRectangle will be moved
      FillCharacter(typing.Any):Character to fill in the area left blank by scrolling operation
      FillAttribute(typing.Any):Text attributes to apply to FillCharacter

Returns:

      None
        
         """
         pass


      def GetCurrentConsoleFont(self,MaximumWindow:'typing.Any'=False) -> 'typing.Tuple[typing.Any, PyCOORD]':
         """
         Returns currently displayed font

Args:

      MaximumWindow(typing.Any):If True, retrieves font size for maximum window sizeCommentsOnly exists on XP or later. MSDN docs claim the returned COORD is the font size, but it's actually the window size. Use PyConsoleScreenBuffer::GetConsoleFontSize for the font size.Return ValueReturns the index of current font and window size

Returns:

      typing.Tuple[typing.Any, PyCOORD]:If True, retrieves font size for maximum window size
Comments

Only exists on XP or later. 

MSDN docs claim the returned COORD is the font size, but it's actually the window size. 

Use PyConsoleScreenBuffer::GetConsoleFontSize for the font size.
Return ValueReturns the index of current font and window size

        
         """
         pass


      def GetConsoleFontSize(self,Font:'typing.Any') -> 'PyCOORD':
         """
         Returns size of specified font for the console

Args:

      Font(typing.Any):Index of font as returned by GetCurrentConsoleFontCommentsOnly exists on XP or later.

Returns:

      PyCOORD
        
         """
         pass


      def SetConsoleFont(self,Font:'typing.Any') -> 'None':
         """
         Changes the font used by the screen buffer

Args:

      Font(typing.Any):The number of the font to be setCommentsFunction is not documented on MSDN

Returns:

      None
        
         """
         pass


      def SetStdHandle(self,StdHandle:'typing.Any') -> 'None':
         """
         Replaces one of calling process's standard handles with this handle

Args:

      StdHandle(typing.Any):Specifies handle to be replaced - STD_INPUT_HANDLE, STD_OUTPUT_HANDLE, or STD_ERROR_HANDLE

Returns:

      None
        
         """
         pass


      def SetConsoleDisplayMode(self,Flags:'typing.Any',NewScreenBufferDimensions:'PyCOORD') -> 'None':
         """
         Sets the display mode of the console buffer

Args:

      Flags(typing.Any):CONSOLE_FULLSCREEN_MODE or CONSOLE_WINDOWED_MODE
      NewScreenBufferDimensions(PyCOORD):New size of the screen buffer in characters

Returns:

      None
        
         """
         pass


      def WriteConsoleInput(self,Buffer:'typing.Tuple[PyINPUT_RECORD, ...]') -> 'typing.Any':
         """
         Places input records in the console's input queue

Args:

      Buffer(typing.Tuple[PyINPUT_RECORD, ...]):A sequence of PyINPUT_RECORD objectsReturn ValueReturns the number of records written

Returns:

      typing.Any:A sequence of PyINPUT_RECORD objectsReturn ValueReturns the number of records written

        
         """
         pass


      def ReadConsoleInput(self,Length:'typing.Any') -> 'typing.Tuple[PyINPUT_RECORD, ...]':
         """
         Reads input records and removes them from 

the input queue

Args:

      Length(typing.Any):The number of input records to readCommentsThis functions blocks until at least one record is read. The number of records returned may be less than the nbr requestedReturn ValueReturns a sequence of PyINPUT_RECORD objects

Returns:

      typing.Tuple[PyINPUT_RECORD, ...]:The number of input records to readComments

This functions blocks until at least one record is read. 

The number of records returned may be less than the nbr requested
Return ValueReturns a sequence of PyINPUT_RECORD objects

        
         """
         pass


      def PeekConsoleInput(self,Length:'typing.Any') -> 'typing.Tuple[PyINPUT_RECORD, ...]':
         """
         Returns pending input records without 

removing them from the input queue

Args:

      Length(typing.Any):The number of input records to readCommentsThis function does not block as ReadConsoleInput does. The number of records returned may be less than the nbr requestedReturn ValueReturns a sequence of PyINPUT_RECORD objects

Returns:

      typing.Tuple[PyINPUT_RECORD, ...]:The number of input records to readComments

This function does not block as ReadConsoleInput does. 

The number of records returned may be less than the nbr requested
Return ValueReturns a sequence of PyINPUT_RECORD objects

        
         """
         pass


      def GetNumberOfConsoleInputEvents(self,) -> 'typing.Any':
         """
         Returns the number of unread records in the input 

queue

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCredHandle(object):
      """Handle to a set of logon credentials, used with sspi authentication functions"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Detach(self,) -> 'typing.Any':
         """
         Disassociates object from handle and returns integer value of handle,

Args:



Returns:

      typing.Any
        
         """
         pass


      def FreeCredentialsHandle(self,) -> 'None':
         """
         Releases the credentials handle and makes object unusable

Args:



Returns:

      None
        
         """
         pass


      def QueryCredentialsAttributes(self,Attribute:'typing.Any') -> 'None':
         """
         Returns information about the credentials

Args:

      Attribute(typing.Any):SECPKG_* constant specifying which type of information to returnCommentsOnly SECPKG_CRED_ATTR_NAMES currently supportedAttributeReturn typeSECPKG_CRED_ATTR_NAMESPyUnicode - returns username that credentials representSECPKG_ATTR_SUPPORTED_ALGSNot supported yet SecPkgCred_SupportedAlgs:SECPKG_ATTR_CIPHER_STRENGTHSNot supported yet SecPkgCred_CipherStrengths:SECPKG_ATTR_SUPPORTED_PROTOCOLSNot supported yet SecPkgCred_SupportedProtocols:Return ValueType of returned values is dependent on Attribute

Returns:

      None:SECPKG_* constant specifying which type of information to returnComments

Only SECPKG_CRED_ATTR_NAMES currently supported



Attribute


Return type



SECPKG_CRED_ATTR_NAMESPyUnicode - returns username that credentials represent
SECPKG_ATTR_SUPPORTED_ALGSNot supported yet 

SecPkgCred_SupportedAlgs:
SECPKG_ATTR_CIPHER_STRENGTHSNot supported yet 

SecPkgCred_CipherStrengths:
SECPKG_ATTR_SUPPORTED_PROTOCOLSNot supported yet 

SecPkgCred_SupportedProtocols:
Return ValueType of returned values is dependent on Attribute

        
         """
         pass


class PyCtxtHandle(object):
      """Security context handle, as used with sspi functions"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Detach(self,) -> 'typing.Any':
         """
         Disassociates object from handle and returns integer value of handle

Args:



Returns:

      typing.Any
        
         """
         pass


      def CompleteAuthToken(self,Token:'PySecBufferDesc') -> 'None':
         """
         Completes the authentication token

Args:

      Token(PySecBufferDesc):The buffer that contains the token buffer used when the context was initializedCommentsThis method should be invoked on a context handle if the InitializeSecurityContext call that created it returned SEC_I_COMPLETE_NEEDED or SEC_I_COMPLETE_AND_CONTINUE

Returns:

      None
        
         """
         pass


      def QueryContextAttributes(self,Attribute:'typing.Any') -> 'None':
         """
         Retrieves info about a security context

Args:

      Attribute(typing.Any):SECPKG_ATTR_* constantCommentsNot all attributes are available for every security packageAttributeReturn typeSECPKG_ATTR_ACCESS_TOKENPyHANDLE - returns a handle to the context's access tokenSECPKG_ATTR_AUTHORITYPyUnicode - returns the name of the authenticating entitySECPKG_ATTR_CIPHER_STRENGTHS(int,int) - returns the mininum and maximum cipher strengths allowedSECPKG_ATTR_CONNECTION_INFOReturns a dictionary of connection info representing a SecPkgContext_ConnectionInfo structSECPKG_ATTR_SESSION_KEYstring - returns the session key for the contextSECPKG_ATTR_ISSUER_LIST_EX(int, string) - Returns names of trusted certificate issuersSECPKG_ATTR_FLAGSint - returns flags negotiated when context was establishedSECPKG_ATTR_PACKAGE_INFOdict - returns dictionary containing info for context's security packageSECPKG_ATTR_NEGOTIATION_INFO(int, dict) - returns state of negotiation (SECPKG_NEGOTIATION_COMPLETE, SECPKG_NEGOTIATION_OPTIMISTIC,SECPKG_NEGOTIATION_IN_PROGRESS) and info for negotiated packageSECPKG_ATTR_NAMESPyUnicode - returns the user name for the contextSECPKG_ATTR_SIZESdict containing buffer sizes to be used with the contextSECPKG_ATTR_PASSWORD_EXPIRYPyTime - returns time password expiresSECPKG_ATTR_LIFESPAN(PyTime,PyTime) - returns time period during which context is validSECPKG_ATTR_NATIVE_NAMES(PyUnicode,PyUnicode) - returns client and server namesSECPKG_ATTR_TARGET_INFORMATIONstring - returns the target for the contextSECPKG_ATTR_STREAM_SIZESdict (see SecPkgContext_StreamSizes) containing message buffer sizesSECPKG_ATTR_KEY_INFOdict (see SecPkgContext_KeyInfo) containing encryption key parametersSECPKG_ATTR_DCE_INFOnot supported yet SecPkgContext_DceInfoSECPKG_ATTR_LOCAL_CERT_CONTEXTnot supported yet PCCERT_CONTEXTSECPKG_ATTR_REMOTE_CERT_CONTEXTnot supported yet PCCERT_CONTEXTSECPKG_ATTR_ROOT_STOREnot supported yet HCERTCONTEXTSECPKG_ATTR_SUPPORTED_ALGSnot supported yet SecPkgCred_SupportedAlgsSECPKG_ATTR_SUPPORTED_PROTOCOLSnot supported yet SecPkgCred_SupportedProtocols

Returns:

      None
        
         """
         pass


      def DeleteSecurityContext(self,) -> 'None':
         """
         Frees the security context and invalidates the handle

Args:



Returns:

      None
        
         """
         pass


      def QuerySecurityContextToken(self,) -> 'typing.Any':
         """
         Returns the access token for a security context

Args:



Returns:

      typing.Any
        
         """
         pass


      def MakeSignature(self,fqop:'typing.Any',Message:'PySecBufferDesc',MessageSeqNo:'typing.Any') -> 'None':
         """
         Creates a crytographic hash of a message using session key of the security 

context

Args:

      fqop(typing.Any):Flags that indicate quality of protection desired, specific to each security package
      Message(PySecBufferDesc):Buffer set that includes buffers for input data and output signature
      MessageSeqNo(typing.Any):A sequential number used by some packages to verify that no extraneous messages have been receivedCommentsThe buffer configuration is dependent on the security package.  Usually there is one input buffer of type SECBUFFER_DATA and an output buffer of type SECBUFFER_TOKENReturn ValueReturns None on success, and output buffer in Message will contain the signature

Returns:

      None:A sequential number used by some packages to verify that no extraneous messages have 

been receivedComments

The buffer configuration is dependent on the security package.  Usually there is one input buffer of 

type SECBUFFER_DATA and an output buffer of type SECBUFFER_TOKEN
Return ValueReturns None on success, and output buffer in Message will contain the signature

        
         """
         pass


      def VerifySignature(self,Message:'PySecBufferDesc',MessageSeqNo:'typing.Any') -> 'None':
         """
         None

Args:

      Message(PySecBufferDesc):SecBufferDesc that contains data buffer and signature buffer
      MessageSeqNo(typing.Any):A sequential number used by some packages to verify that no extraneous messages have been receivedCommentsThe buffer configuration is dependent on the security package.  Usually there is a data buffer of type SECBUFFER_DATA and a signature buffer of type SECBUFFER_TOKENReturn ValueReturns quality of protection flags used to create signature

Returns:

      None:A sequential number used by some packages to verify that no extraneous messages have 

been receivedComments

The buffer configuration is dependent on the security package.  Usually there is a data buffer of type 

SECBUFFER_DATA 

and a signature buffer of type SECBUFFER_TOKEN
Return ValueReturns quality of protection flags used to create signature

        
         """
         pass


      def EncryptMessage(self,fqop:'typing.Any',Message:'PySecBufferDesc',MessageSeqNo:'typing.Any') -> 'None':
         """
         Encrypts data with session key of security context

Args:

      fqop(typing.Any):Flags that indicate quality of protection desired, specific to each security package
      Message(PySecBufferDesc):PySecBufferDesc that contains data buffer(s) to be encrypted
      MessageSeqNo(typing.Any):A sequential number used by some packages to verify that no extraneous messages have been receivedCommentsThe buffer configuration is dependent on the security package.  Usually there is one input buffer of type SECBUFFER_DATA to be encrypted in-place and another empty buffer of type SECBUFFER_PADDING or SECBUFFER_TOKEN to receive signature or padding dataReturn ValueReturns None on success, and buffer(s) will contain encrypted data

Returns:

      None:A sequential number used by some packages to verify that no extraneous messages have 

been receivedComments

The buffer configuration is dependent on the security package.  Usually there is one input buffer 

of type SECBUFFER_DATA to be encrypted in-place and another empty buffer of type SECBUFFER_PADDING or 

SECBUFFER_TOKEN to receive signature or padding data
Return ValueReturns None on success, and buffer(s) will contain encrypted data

        
         """
         pass


      def DecryptMessage(self,Message:'PySecBufferDesc',MessageSeqNo:'typing.Any') -> 'None':
         """
         None

Args:

      Message(PySecBufferDesc):PySecBufferDesc containing data buffers to be decrypted
      MessageSeqNo(typing.Any):A sequential number used by some packages to verify that no extraneous messages have been receivedCommentsThe buffer configuration is dependent on the security package.  Usually there is one buffer of type SECBUFFER_DATA which is modified in place and a second buffer of type SECBUFFER_TOKEN or SECBUFFER_PADDING containing signature, padding, or other extra data from encryption process that doesn't fit in first bufferReturn ValueReturns flags specfic to security package indicating quality of protection

Returns:

      None:A sequential number used by some packages to verify that no extraneous messages have 

been receivedComments

The buffer configuration is dependent on the security package.  Usually there is one buffer 

of type SECBUFFER_DATA which is modified in place and a second buffer of type SECBUFFER_TOKEN or 

SECBUFFER_PADDING containing signature, padding, or other extra data from encryption process that doesn't fit 

in first buffer
Return ValueReturns flags specfic to security package indicating quality of protection

        
         """
         pass


      def ImpersonateSecurityContext(self,) -> 'None':
         """
         Impersonates a client security context

Args:



Returns:

      None
        
         """
         pass


      def RevertSecurityContext(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


class PyDCB(object):
      """A Python object, representing an DCB structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def BaudRate(self)->'int':
         """current baud rate"""
         pass


      @property
      def wReserved(self)->'int':
         """not currently used"""
         pass


      @property
      def XonLim(self)->'int':
         """transmit XON threshold"""
         pass


      @property
      def XoffLim(self)->'int':
         """transmit XOFF threshold"""
         pass


      @property
      def ByteSize(self)->'int':
         """number of bits/byte, 4-8"""
         pass


      @property
      def Parity(self)->'int':
         """0-4=no,odd,even,mark,space"""
         pass


      @property
      def StopBits(self)->'int':
         """0,1,2 = 1, 1.5, 2"""
         pass


      @property
      def XonChar(self)->'str':
         """Tx and Rx XON character"""
         pass


      @property
      def XoffChar(self)->'str':
         """Tx and Rx XOFF character"""
         pass


      @property
      def ErrorChar(self)->'str':
         """error replacement character"""
         pass


      @property
      def EofChar(self)->'str':
         """end of input character"""
         pass


      @property
      def EvtChar(self)->'str':
         """received event character"""
         pass


      @property
      def wReserved1(self)->'int':
         """reserved; do not use"""
         pass


      @property
      def fBinary(self)->'int':
         """binary mode, no EOF check"""
         pass


      @property
      def fParity(self)->'int':
         """enable parity checking"""
         pass


      @property
      def fOutxCtsFlow(self)->'int':
         """CTS output flow control"""
         pass


      @property
      def fOutxDsrFlow(self)->'int':
         """DSR output flow control"""
         pass


      @property
      def fDtrControl(self)->'int':
         """DTR flow control type"""
         pass


      @property
      def fDsrSensitivity(self)->'int':
         """DSR sensitivity"""
         pass


      @property
      def fTXContinueOnXoff(self)->'int':
         """XOFF continues Tx"""
         pass


      @property
      def fOutX(self)->'int':
         """XON/XOFF out flow control"""
         pass


      @property
      def fInX(self)->'int':
         """XON/XOFF in flow control"""
         pass


      @property
      def fErrorChar(self)->'int':
         """enable error replacement"""
         pass


      @property
      def fNull(self)->'int':
         """enable null stripping"""
         pass


      @property
      def fRtsControl(self)->'int':
         """RTS flow control"""
         pass


      @property
      def fAbortOnError(self)->'int':
         """abort on error"""
         pass


      @property
      def fDummy2(self)->'int':
         """reserved"""
         pass


class PyDEVMODE(object):
      """Python object wrapping a DEVMODE structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def SpecVersion(self)->'typing.Any':
         """Should always be set to DM_SPECVERSION"""
         pass


      @property
      def DriverVersion(self)->'typing.Any':
         """Version nbr assigned to printer driver by vendor"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure"""
         pass


      @property
      def DriverExtra(self)->'typing.Any':
         """Number of extra bytes allocated for driver data, can only be set when new object is created"""
         pass


      @property
      def Fields(self)->'typing.Any':
         """Bitmask of win32con.DM_* constants indicating which members are set"""
         pass


      @property
      def Orientation(self)->'typing.Any':
         """Only applies to printers, DMORIENT_PORTRAIT or DMORIENT_LANDSCAPE"""
         pass


      @property
      def PaperSize(self)->'typing.Any':
         """Use 0 if PaperWidth and PaperLength are set, otherwise win32con.DMPAPER_* constant"""
         pass


      @property
      def PaperLength(self)->'typing.Any':
         """Specified in 1/10 millimeters"""
         pass


      @property
      def PaperWidth(self)->'typing.Any':
         """Specified in 1/10 millimeters"""
         pass


      @property
      def Position_x(self)->'typing.Any':
         """Position of display relative to desktop"""
         pass


      @property
      def Position_y(self)->'typing.Any':
         """Position of display relative to desktop"""
         pass


      @property
      def DisplayOrientation(self)->'typing.Any':
         """Display rotation: DMDO_DEFAULT,DMDO_90, DMDO_180, DMDO_270"""
         pass


      @property
      def DisplayFixedOutput(self)->'typing.Any':
         """DMDFO_DEFAULT, DMDFO_CENTER, DMDFO_STRETCH"""
         pass


      @property
      def Scale(self)->'typing.Any':
         """Specified as percentage, eg 50 means half size of original"""
         pass


      @property
      def Copies(self)->'typing.Any':
         """Nbr of copies to print"""
         pass


      @property
      def DefaultSource(self)->'typing.Any':
         """DMBIN_* constant, or can be a printer-specific value"""
         pass


      @property
      def PrintQuality(self)->'typing.Any':
         """DMRES_* constant, interpreted as DPI if positive"""
         pass


      @property
      def Color(self)->'typing.Any':
         """DMCOLOR_COLOR or DMCOLOR_MONOCHROME"""
         pass


      @property
      def Duplex(self)->'typing.Any':
         """For printers that do two-sided printing: DMDUP_SIMPLEX, DMDUP_HORIZONTAL, DMDUP_VERTICAL"""
         pass


      @property
      def YResolution(self)->'typing.Any':
         """Vertical printer resolution in DPI - if this is set, PrintQuality indicates horizontal DPI"""
         pass


      @property
      def TTOption(self)->'typing.Any':
         """TrueType options: DMTT_BITMAP, DMTT_DOWNLOAD, DMTT_DOWNLOAD_OUTLINE, DMTT_SUBDEV"""
         pass


      @property
      def Collate(self)->'typing.Any':
         """DMCOLLATE_TRUE or DMCOLLATE_FALSE"""
         pass


      @property
      def LogPixels(self)->'typing.Any':
         """Pixels per inch (only for display devices"""
         pass


      @property
      def BitsPerPel(self)->'typing.Any':
         """Color resolution in bits per pixel"""
         pass


      @property
      def PelsWidth(self)->'typing.Any':
         """Pixel width of display"""
         pass


      @property
      def PelsHeight(self)->'typing.Any':
         """Pixel height of display"""
         pass


      @property
      def DisplayFlags(self)->'typing.Any':
         """Combination of DM_GRAYSCALE and DM_INTERLACED"""
         pass


      @property
      def DisplayFrequency(self)->'typing.Any':
         """Refresh rate"""
         pass


      @property
      def ICMMethod(self)->'typing.Any':
         """Indicates where ICM is performed, one of win32con.DMICMMETHOD_* values"""
         pass


      @property
      def ICMIntent(self)->'typing.Any':
         """Intent of ICM, one of win32con.DMICM_* values"""
         pass


      @property
      def MediaType(self)->'typing.Any':
         """win32con.DMMEDIA_*, can also be a printer-specific value greater then DMMEDIA_USER"""
         pass


      @property
      def DitherType(self)->'typing.Any':
         """Dithering option, win32con.DMDITHER_*"""
         pass


      @property
      def Reserved1(self)->'typing.Any':
         """Reserved, use only 0"""
         pass


      @property
      def Reserved2(self)->'typing.Any':
         """Reserved, use only 0"""
         pass


      @property
      def Nup(self)->'typing.Any':
         """Controls printing of multiple logical pages per physical page, DMNUP_SYSTEM or DMNUP_ONEUP"""
         pass


      @property
      def PanningWidth(self)->'typing.Any':
         """Not used, leave as 0"""
         pass


      @property
      def PanningHeight(self)->'typing.Any':
         """Not used, leave as 0"""
         pass


      @property
      def DeviceName(self)->'typing.Any':
         """String of at most 32 chars"""
         pass


      @property
      def FormName(self)->'typing.Any':
         """Name of form as returned by win32print::EnumForms, at most 32 chars"""
         pass


      @property
      def DriverData(self)->'typing.Any':
         """Driver data appended to end of structure"""
         pass


      def Clear(self,) -> 'None':
         """
         Resets all members of the structure

Args:



Returns:

      None
        
         """
         pass


class PyDEVMODEW(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def SpecVersion(self)->'typing.Any':
         """Should always be set to DM_SPECVERSION"""
         pass


      @property
      def DriverVersion(self)->'typing.Any':
         """Version nbr assigned to printer driver by vendor"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure"""
         pass


      @property
      def DriverExtra(self)->'typing.Any':
         """Number of extra bytes allocated for driver data, can only be set when new object is created"""
         pass


      @property
      def Fields(self)->'typing.Any':
         """Bitmask of win32con.DM_* constants indicating which members are set"""
         pass


      @property
      def Orientation(self)->'typing.Any':
         """Only applies to printers, DMORIENT_PORTRAIT or DMORIENT_LANDSCAPE"""
         pass


      @property
      def PaperSize(self)->'typing.Any':
         """Use 0 if PaperWidth and PaperLength are set, otherwise win32con.DMPAPER_* constant"""
         pass


      @property
      def PaperLength(self)->'typing.Any':
         """Specified in 1/10 millimeters"""
         pass


      @property
      def PaperWidth(self)->'typing.Any':
         """Specified in 1/10 millimeters"""
         pass


      @property
      def Position_x(self)->'typing.Any':
         """Position of display relative to desktop"""
         pass


      @property
      def Position_y(self)->'typing.Any':
         """Position of display relative to desktop"""
         pass


      @property
      def DisplayOrientation(self)->'typing.Any':
         """Display rotation: DMDO_DEFAULT,DMDO_90, DMDO_180, DMDO_270"""
         pass


      @property
      def DisplayFixedOutput(self)->'typing.Any':
         """DMDFO_DEFAULT, DMDFO_CENTER, DMDFO_STRETCH"""
         pass


      @property
      def Scale(self)->'typing.Any':
         """Specified as percentage, eg 50 means half size of original"""
         pass


      @property
      def Copies(self)->'typing.Any':
         """Nbr of copies to print"""
         pass


      @property
      def DefaultSource(self)->'typing.Any':
         """DMBIN_* constant, or can be a printer-specific value"""
         pass


      @property
      def PrintQuality(self)->'typing.Any':
         """DMRES_* constant, interpreted as DPI if positive"""
         pass


      @property
      def Color(self)->'typing.Any':
         """DMCOLOR_COLOR or DMCOLOR_MONOCHROME"""
         pass


      @property
      def Duplex(self)->'typing.Any':
         """For printers that do two-sided printing: DMDUP_SIMPLEX, DMDUP_HORIZONTAL, DMDUP_VERTICAL"""
         pass


      @property
      def YResolution(self)->'typing.Any':
         """Vertical printer resolution in DPI - if this is set, PrintQuality indicates horizontal DPI"""
         pass


      @property
      def TTOption(self)->'typing.Any':
         """TrueType options: DMTT_BITMAP, DMTT_DOWNLOAD, DMTT_DOWNLOAD_OUTLINE, DMTT_SUBDEV"""
         pass


      @property
      def Collate(self)->'typing.Any':
         """DMCOLLATE_TRUE or DMCOLLATE_FALSE"""
         pass


      @property
      def LogPixels(self)->'typing.Any':
         """Pixels per inch (only for display devices"""
         pass


      @property
      def BitsPerPel(self)->'typing.Any':
         """Color resolution in bits per pixel"""
         pass


      @property
      def PelsWidth(self)->'typing.Any':
         """Pixel width of display"""
         pass


      @property
      def PelsHeight(self)->'typing.Any':
         """Pixel height of display"""
         pass


      @property
      def DisplayFlags(self)->'typing.Any':
         """Combination of DM_GRAYSCALE and DM_INTERLACED"""
         pass


      @property
      def DisplayFrequency(self)->'typing.Any':
         """Refresh rate"""
         pass


      @property
      def ICMMethod(self)->'typing.Any':
         """Indicates where ICM is performed, one of win32con.DMICMMETHOD_* values"""
         pass


      @property
      def ICMIntent(self)->'typing.Any':
         """Intent of ICM, one of win32con.DMICM_* values"""
         pass


      @property
      def MediaType(self)->'typing.Any':
         """win32con.DMMEDIA_*, can also be a printer-specific value greater then DMMEDIA_USER"""
         pass


      @property
      def DitherType(self)->'typing.Any':
         """Dithering option, win32con.DMDITHER_*"""
         pass


      @property
      def Reserved1(self)->'typing.Any':
         """Reserved, use only 0"""
         pass


      @property
      def Reserved2(self)->'typing.Any':
         """Reserved, use only 0"""
         pass


      @property
      def Nup(self)->'typing.Any':
         """Controls printing of multiple logical pages per physical page, DMNUP_SYSTEM or DMNUP_ONEUP"""
         pass


      @property
      def PanningWidth(self)->'typing.Any':
         """Not used, leave as 0"""
         pass


      @property
      def PanningHeight(self)->'typing.Any':
         """Not used, leave as 0"""
         pass


      @property
      def DeviceName(self)->'str':
         """String of at most 32 chars"""
         pass


      @property
      def FormName(self)->'typing.Any':
         """Name of form as returned by win32print::EnumForms, at most 32 chars"""
         pass


      @property
      def DriverData(self)->'typing.Any':
         """Driver data appended to end of structure"""
         pass


class PyDISPLAY_DEVICE(object):
      """Python object wrapping a DISPLAY_DEVICE structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Size(self)->'typing.Any':
         """Size of structure"""
         pass


      @property
      def DeviceName(self)->'typing.Any':
         """String of at most 32 chars"""
         pass


      @property
      def DeviceString(self)->'typing.Any':
         """String of at most 128 chars"""
         pass


      @property
      def StateFlags(self)->'typing.Any':
         """Bitmask of win32con.DISPLAY_DEVICE_* constants indicating current device status"""
         pass


      @property
      def DeviceID(self)->'typing.Any':
         """String of at most 128 chars"""
         pass


      @property
      def DeviceKey(self)->'typing.Any':
         """String of at most 128 chars"""
         pass


      def Clear(self,) -> 'None':
         """
         Resets all members of the structure

Args:



Returns:

      None
        
         """
         pass


class PyDLGITEMTEMPLATE(object):
      """A tuple describing a control in a dialog box."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyDLGTEMPLATE(object):
      """A tuple of items describing a dialog box, that can be used to create the dialog."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyDS_HANDLE(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyDS_NAME_RESULT_ITEM(object):
      """A tuple representing a DS_NAME_RESULT_ITEM"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyDateTime(object):
      """A Python object, representing an instant in time."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Format(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


class PyDialogTemplate(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyEVTLOG_HANDLE(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyEVT_HANDLE(object):
      """Handle to an event log, session, query, or any other object used with 

the Evt* event log functions on Vista and later. 

When the object is destroyed, EvtClose is called."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyEVT_RPC_LOGIN(object):
      """Tuple containing login credentials for a remote Event Log connection"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyEventLogRecord(object):
      """An object containing the data in an EVENTLOGRECORD."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Reserved(self)->'int':
         """"""
         pass


      @property
      def RecordNumber(self)->'int':
         """"""
         pass


      @property
      def TimeGenerated(self)->'PyTime':
         """"""
         pass


      @property
      def TimeWritten(self)->'PyTime':
         """"""
         pass


      @property
      def EventID(self)->'int':
         """"""
         pass


      @property
      def EventType(self)->'int':
         """"""
         pass


      @property
      def EventCategory(self)->'int':
         """"""
         pass


      @property
      def ReservedFlags(self)->'int':
         """"""
         pass


      @property
      def ClosingRecordNumber(self)->'int':
         """"""
         pass


      @property
      def SourceName(self)->'str':
         """"""
         pass


      @property
      def StringInserts(self)->'typing.Tuple[str, ...]':
         """"""
         pass


      @property
      def Sid(self)->'PySID':
         """"""
         pass


      @property
      def Data(self)->'str':
         """"""
         pass


      @property
      def ComputerName(self)->'str':
         """"""
         pass


class PyGROUP_INFO_0(object):
      """A dictionary holding the information in a Win32 GROUP_INFO_0 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """Name of the group"""
         pass


class PyGROUP_INFO_1(object):
      """A dictionary holding the information in a Win32 GROUP_INFO_1 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """Name of the group"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """The group's comment."""
         pass


class PyGROUP_INFO_1002(object):
      """A dictionary holding the information in a Win32 GROUP_INFO_1002 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


class PyGROUP_INFO_1005(object):
      """A dictionary holding the information in a Win32 GROUP_INFO_1005 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def attributes(self)->'typing.Any':
         """"""
         pass


class PyGROUP_INFO_2(object):
      """A dictionary holding the information in a Win32 GROUP_INFO_2 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """Name of the group"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """The group's comment."""
         pass


      @property
      def group_id(self)->'typing.Any':
         """"""
         pass


      @property
      def attributes(self)->'typing.Any':
         """"""
         pass


class PyGROUP_USERS_INFO_0(object):
      """A dictionary holding the information in a Win32 GROUP_USERS_INFO_0 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """Name of the group or user"""
         pass


class PyGROUP_USERS_INFO_1(object):
      """A dictionary holding the information in a Win32 GROUP_USERS_INFO_1 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """Name of the group or user"""
         pass


      @property
      def attributes(self)->'typing.Any':
         """"""
         pass


class PyGdiHANDLE(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyGetSignerCertificate(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyHANDLE(object):
      """A Python object, representing a win32 HANDLE."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def handle(self)->'typing.Any':
         """Integer value of the handleMethodsCloseCloses the handle closeSynonym for PyHANDLE::Close DetachDetaches the Win32 handle from the handle object. __nonzero__Used for detecting true/false. is nb_bool in Python 3.0 __int__Used when an integer representation of the handle object is required. __print__Used when the object is printed. tp_print __hash__Used when the hash value of an object is required tp_hash __str__Used when a string representation is required tp_str """
         pass


      def Close(self,) -> 'None':
         """
         Closes the underlying Win32 handle.

Args:



Returns:

      None
        
         """
         pass


      def close(self,) -> 'None':
         """
         Closes the underlying Win32 handle.

Args:



Returns:

      None
        
         """
         pass


      def Detach(self,) -> 'typing.Any':
         """
         Detaches the Win32 handle from the handle object.

Args:



Returns:

      typing.Any:PyHANDLE.Detach

int = Detach()Detaches the Win32 handle from the handle object.
Comments

After calling this function, the handle is effectively invalidated, 

but the handle is not closed.  You would call this function when you 

need the underlying win32 handle to exist beyond the lifetime of the 

handle object.
Return ValueThe result is the value of the handle before it is detached.  If the 

handle is already detached, this will return zero.

        
         """
         pass


class PyHDESK(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetThreadDesktop(self,) -> 'None':
         """
         Assigns this desktop to the calling thread

Args:



Returns:

      None
        
         """
         pass


      def EnumDesktopWindows(self,) -> 'typing.Tuple[int, ...]':
         """
         Returns a list of handles to all top-level windows on desktop

Args:



Returns:

      typing.Tuple[int, ...]
        
         """
         pass


      def SwitchDesktop(self,) -> 'None':
         """
         Activates the desktop

Args:



Returns:

      None
        
         """
         pass


      def CloseDesktop(self,) -> 'None':
         """
         Closes the desktop handle

Args:



Returns:

      None
        
         """
         pass


class PyHDEVNOTIFY(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyHHNTRACK(object):
      """A Python object, representing an HHNTRACK 

structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def action(self)->'typing.Any':
         """Specifies the action the user is about to take. This is an HHACT_ constant."""
         pass


      @property
      def hdr(self)->'typing.Any':
         """Standard WM_NOTIFY header(win32help::NMHDR)."""
         pass


      @property
      def curUrl(self)->'str':
         """A multi-byte, zero-terminated string that specifies the topic navigated to, or the name of the help window being created."""
         pass


      @property
      def winType(self)->'typing.Any':
         """A pointer to the current HH_WINTYPE structure (win32help::HH_WINTYPE)."""
         pass


class PyHHN_NOTIFY(object):
      """A Python object, representing an HHN_NOTIFY 

structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def hdr(self)->'typing.Any':
         """Standard WM_NOTIFY header.(win32help::NMHDR)"""
         pass


      @property
      def url(self)->'str':
         """A multi-byte, zero-terminated string that specifies the topic navigated to, or the name of the help window being created."""
         pass


class PyHH_AKLINK(object):
      """A Python object, representing an HH_AKLINK structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def indexOnFail(self)->'typing.Any':
         """Specifies whether to display the keyword in the Index tab of the HTML Help Viewer if the lookup fails. The value of window specifies the Help Viewer."""
         pass


      @property
      def keywords(self)->'str':
         """Specifies one or more ALink names or KLink keywords to look up. Multiple entries are delimited by a semicolon."""
         pass


      @property
      def url(self)->'str':
         """Specifies the topic file to navigate to if the lookup fails. url refers to a valid topic within the specified compiled help (.chm) file and does not support Internet protocols that point to an HTML file."""
         pass


      @property
      def msgText(self)->'str':
         """Specifies the text to display in a message box if the lookup fails and indexOnFail is FALSE and url is NULL."""
         pass


      @property
      def msgTitle(self)->'str':
         """Specifies the caption of the message box in which the msgText parameter appears."""
         pass


      @property
      def window(self)->'str':
         """Specifies the name of the window type in which to display one of the following: The selected topic, if the lookup yields one or more matching topics. The topic specified in url, if the lookup fails and a topic is specified in url. The Index tab, if the lookup fails and indexOnFail is specified as TRUE."""
         pass


class PyHH_FTS_QUERY(object):
      """A Python object, representing an HH_FTS_QUERY 

structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def uniCodeStrings(self)->'typing.Any':
         """TRUE if all strings are Unicode."""
         pass


      @property
      def proximity(self)->'typing.Any':
         """Word proximity."""
         pass


      @property
      def stemmedSearch(self)->'typing.Any':
         """TRUE for StemmedSearch only."""
         pass


      @property
      def titleOnly(self)->'typing.Any':
         """TRUE for Title search only."""
         pass


      @property
      def execute(self)->'typing.Any':
         """TRUE to initiate the search."""
         pass


      @property
      def searchQuery(self)->'str':
         """String containing the search query."""
         pass


class PyHH_POPUP(object):
      """A Python object, representing an HH_POPUP structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def hinst(self)->'typing.Any':
         """Instance handle of the program or DLL to retrieve the string resource from. Ignored if idString is zero."""
         pass


      @property
      def idString(self)->'typing.Any':
         """Specifies zero, or a resource ID in the program or DLL specified in hinst."""
         pass


      @property
      def clrForeground(self)->'typing.Any':
         """Specifies the RGB value to use for the foreground color of the pop-up window. To use the system color for the window text, specify -1."""
         pass


      @property
      def clrBackground(self)->'typing.Any':
         """Specifies the RGB value to use for the background color of the pop-up window. To use the system color for the window background, specify -1."""
         pass


      @property
      def text(self)->'str':
         """Specifies the text to display if idString is zero."""
         pass


      @property
      def font(self)->'str':
         """Specifies the font attributes to use for the text in the pop-up window. Use the following format to specify font family, point size, character set, and font format: facename[, point size[, charset[ BOLD ITALIC UNDERLINE]]] To omit an attribute, enter a comma. For example, to specify bold, 10-pt, MS Sans Serif font, font would be: MS Sans Serif, 10, , BOLD"""
         pass


      @property
      def pt(self)->'typing.Any':
         """(x,y). Specifies (in pixels) where the top center of the pop-up window should be located."""
         pass


      @property
      def margins(self)->'typing.Any':
         """(left,top,right,bottom). Specifies (in pixels) the margins to use on the left, top, right, and bottom sides of the pop-up window. The default for all rectangle members is -1."""
         pass


class PyHH_WINTYPE(object):
      """A Python object, representing an HH_WINTYPE structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def uniCodeStrings(self)->'typing.Any':
         """Specifies whether the strings used in this structure are UNICODE."""
         pass


      @property
      def validMembers(self)->'typing.Any':
         """Specifies which members in the structure are valid."""
         pass


      @property
      def winProperties(self)->'typing.Any':
         """Specifies the properties of the window, such as whether it is the standard HTML Help Viewer or whether it includes a Search tab."""
         pass


      @property
      def styles(self)->'typing.Any':
         """Specifies the styles used to create the window. These styles can be ignored, combined with extended styles, or used exclusively depending on the value of the validMembers and winProperties parameters."""
         pass


      @property
      def exStyles(self)->'typing.Any':
         """Specifies the extended styles used to create the window. These styles can be ignored, combined with default styles, or used exclusively depending on the value of the validMembers and winProperties parameters."""
         pass


      @property
      def showState(self)->'typing.Any':
         """Specifies the initial display state of the window. Valid values are the same as those for the Win32 API ShowWindow function."""
         pass


      @property
      def hwndHelp(self)->'typing.Any':
         """Specifies the handle of the window if the window has been created."""
         pass


      @property
      def hwndCaller(self)->'typing.Any':
         """Specifies the window that will receive HTML Help notification messages. Notification messages are sent via Windows WM_NOTIFY messages."""
         pass


      @property
      def hwndToolBar(self)->'typing.Any':
         """Specifies the handle of the toolbar."""
         pass


      @property
      def hwndNavigation(self)->'typing.Any':
         """Specifies the handle of the Navigation pane."""
         pass


      @property
      def hwndHTML(self)->'typing.Any':
         """Specifies the handle of the Topic pane, which hosts Shdocvw.dll."""
         pass


      @property
      def navWidth(self)->'typing.Any':
         """Specifies the width of the Navigation pane when the Help Viewer is expanded."""
         pass


      @property
      def toolBarFlags(self)->'typing.Any':
         """Specifies which buttons to include on the toolbar."""
         pass


      @property
      def notExpanded(self)->'typing.Any':
         """Specifies that the Help Viewer open with the Navigation pane closed."""
         pass


      @property
      def curNavType(self)->'typing.Any':
         """Specifies the default tab to display on the Navigation pane."""
         pass


      @property
      def idNotify(self)->'typing.Any':
         """Specifies a non-zero ID for enabling HTML Help notification messages. This ID is passed as the wParam value of Windows WM_NOTIFY messages."""
         pass


      @property
      def typeName(self)->'str':
         """A null-terminated string that specifies the name of the window type."""
         pass


      @property
      def caption(self)->'str':
         """A null-terminated string that specifies the caption to display in the title bar of the window."""
         pass


      @property
      def windowPos(self)->'typing.Any':
         """(left,top,right,bottom). Specifies the coordinates of the window in pixels."""
         pass


      @property
      def HTMLPos(self)->'typing.Any':
         """(left,top,right,bottom). Specifies the coordinates of the Topic pane."""
         pass


      @property
      def toc(self)->'str':
         """Specifies the contents (.hhc) file to display in the Navigation pane."""
         pass


      @property
      def index(self)->'str':
         """Specifies the index (.hhk) file to display in the Navigation pane."""
         pass


      @property
      def file(self)->'str':
         """Specifies the default HTML file to display in the Topic pane."""
         pass


      @property
      def home(self)->'str':
         """Specifies the file or URL to display in the Topic pane when the Home button is clicked."""
         pass


      @property
      def jump1(self)->'str':
         """Specifies the text to display underneath the Jump1 button."""
         pass


      @property
      def jump2(self)->'str':
         """Specifies the text to display underneath the Jump2 button."""
         pass


      @property
      def urlJump1(self)->'str':
         """Specifies the URL to jump to when the Jump1 button is clicked."""
         pass


      @property
      def urlJump2(self)->'str':
         """Specifies the URL to jump to when the Jump2 button is clicked."""
         pass


class PyHINTERNET(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyHKEY(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyHTHEME(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyHWINSTA(object):
      """Wrapper for a handle to a window station - returned by CreateWindowStation, OpenWindowStation, or GetProcessWindowStation"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def EnumDesktops(self,) -> 'typing.Tuple[typing.Any, ...]':
         """
         Lists names of desktops in the window station

Args:



Returns:

      typing.Tuple[typing.Any, ...]
        
         """
         pass


      def SetProcessWindowStation(self,) -> 'None':
         """
         Associates the calling process with the window station

Args:



Returns:

      None
        
         """
         pass


      def CloseWindowStation(self,) -> 'None':
         """
         Closes the window station handle

Args:



Returns:

      None
        
         """
         pass


class PyICONINFO(object):
      """Tuple describing an icon or cursor"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyIID(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyINPUT_RECORD(object):
      """Interface to the INPUT_RECORD struct used with console IO functions.  Create using 

PyINPUT_RECORDType(EventType)"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def EventType(self)->'typing.Any':
         """One of KEY_EVENT, MOUSE_EVENT, WINDOW_BUFFER_SIZE_EVENT, MENU_EVENT, FOCUS_EVENT. Cannot be changed after object is created"""
         pass


      @property
      def KeyDown(self)->'typing.Any':
         """True for a key press, False for key release"""
         pass


      @property
      def RepeatCount(self)->'typing.Any':
         """Nbr of repeats generated (key was held down if &gt1)"""
         pass


      @property
      def VirtualKeyCode(self)->'typing.Any':
         """Device-independent key code, win32con.VK_*"""
         pass


      @property
      def VirtualScanCode(self)->'typing.Any':
         """Device-dependent scan code generated by keyboard"""
         pass


      @property
      def Char(self)->'str':
         """Single unicode character generated by the keypress"""
         pass


      @property
      def ControlKeyState(self)->'typing.Any':
         """State of modifier keys, combination of CAPSLOCK_ON, ENHANCED_KEY, LEFT_ALT_PRESSED, LEFT_CTRL_PRESSED, NUMLOCK_ON, RIGHT_ALT_PRESSED, RIGHT_CTRL_PRESSED, SCROLLLOCK_ON, SHIFT_PRESSED"""
         pass


      @property
      def ButtonState(self)->'typing.Any':
         """Bitmask representing which mouse buttons were pressed."""
         pass


      @property
      def EventFlags(self)->'typing.Any':
         """DOUBLE_CLICK, MOUSE_MOVED or MOUSE_WHEELED, or 0.  If 0, indicates a mouse button press"""
         pass


      @property
      def MousePosition(self)->'PyCOORD':
         """Position in character coordinates"""
         pass


      @property
      def Size(self)->'PyCOORD':
         """New size of screen buffer in character rows/columns"""
         pass


      @property
      def SetFocus(self)->'typing.Any':
         """Reserved - Used only with type FOCUS_EVENT.  This event is Reserved, and should be ignored."""
         pass


      @property
      def CommandId(self)->'typing.Any':
         """Used only with event type MENU_EVENT, which is reserved and should not be used"""
         pass


class PyLOCALGROUP_INFO_0(object):
      """A dictionary holding the information in a Win32 LOCALGROUP_INFO_0 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """Name of the group"""
         pass


class PyLOCALGROUP_INFO_1(object):
      """A dictionary holding the information in a Win32 LOCALGROUP_INFO_1 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """Name of the group"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """The group's comment."""
         pass


class PyLOCALGROUP_INFO_1002(object):
      """A dictionary holding the information in a Win32 LOCALGROUP_INFO_1002 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


class PyLOCALGROUP_MEMBERS_INFO_0(object):
      """A dictionary holding the information in a Win32 LOCALGROUP_MEMBERS_INFO_0 

structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def sid(self)->'PySID':
         """"""
         pass


class PyLOCALGROUP_MEMBERS_INFO_1(object):
      """A dictionary holding the information in a Win32 LOCALGROUP_MEMBERS_INFO_1 

structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def sid(self)->'PySID':
         """"""
         pass


      @property
      def sidusage(self)->'typing.Any':
         """"""
         pass


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


class PyLOCALGROUP_MEMBERS_INFO_2(object):
      """A dictionary holding the information in a Win32 LOCALGROUP_MEMBERS_INFO_2 

structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def sid(self)->'PySID':
         """"""
         pass


      @property
      def sidusage(self)->'typing.Any':
         """"""
         pass


      @property
      def domainandname(self)->'typing.Union[str]':
         """string containing the name of the member prefixed by the domain name and the "\\" separator character"""
         pass


class PyLOCALGROUP_MEMBERS_INFO_3(object):
      """A dictionary holding the information in a Win32 LOCALGROUP_MEMBERS_INFO_3 

structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def domainandname(self)->'typing.Union[str]':
         """string containing the name of the member prefixed by the domain name and the "\\" separator character"""
         pass


class PyLOGBRUSH(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Style(self)->'typing.Any':
         """Brush style, one of win32con.BS_* values"""
         pass


      @property
      def Color(self)->'typing.Any':
         """RGB color value.  Can also be DIB_PAL_COLORS or DIB_RGB_COLORS if Style is BS_DIBPATTERN or BS_DIBPATTERNPT="""
         pass


      @property
      def Hatch(self)->'typing.Union[int, typing.Any]':
         """For BS_HATCH style, one of win32con.HS_*. Not used For BS_SOLID or BS_HOLLOW. For a pattern brush, this should be a handle to a bitmap"""
         pass


class PyLOGFONT(object):
      """A Python object, representing an PyLOGFONT structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def lfHeight(self)->'int':
         """"""
         pass


      @property
      def lfWidth(self)->'int':
         """"""
         pass


      @property
      def lfEscapement(self)->'int':
         """"""
         pass


      @property
      def lfOrientation(self)->'int':
         """"""
         pass


      @property
      def lfWeight(self)->'int':
         """"""
         pass


      @property
      def lfItalic(self)->'int':
         """"""
         pass


      @property
      def lfUnderline(self)->'int':
         """"""
         pass


      @property
      def lfStrikeOut(self)->'int':
         """"""
         pass


      @property
      def lfCharSet(self)->'int':
         """"""
         pass


      @property
      def lfOutPrecision(self)->'int':
         """"""
         pass


      @property
      def lfClipPrecision(self)->'int':
         """"""
         pass


      @property
      def lfQuality(self)->'int':
         """"""
         pass


      @property
      def lfPitchAndFamily(self)->'int':
         """"""
         pass


      @property
      def lfFaceName(self)->'str':
         """Name of the typeface, at most 31 characters"""
         pass


class PyLSA_HANDLE(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyLUID_AND_ATTRIBUTES(object):
      """A sequence containing (LUID,Attributes) representing an LUID_AND_ATTRIBUTES structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyLsaLogon_HANDLE(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyMSG(object):
      """A tuple representing a win32 MSG structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyNETRESOURCE(object):
      """A Python object that encapsulates a Win32 NETRESOURCE structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def dwScope(self)->'int':
         """"""
         pass


      @property
      def dwType(self)->'int':
         """"""
         pass


      @property
      def dwDisplayType(self)->'int':
         """"""
         pass


      @property
      def dwUsage(self)->'int':
         """"""
         pass


      @property
      def localName(self)->'str':
         """"""
         pass


      @property
      def remoteName(self)->'str':
         """"""
         pass


      @property
      def comment(self)->'str':
         """"""
         pass


      @property
      def provider(self)->'str':
         """"""
         pass


class PyNET_VALIDATE_AUTHENTICATION_INPUT_ARG(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyNET_VALIDATE_PASSWORD_CHANGE_INPUT_ARG(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyNET_VALIDATE_PERSISTED_FIELDS(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyNMHDR(object):
      """A Python object, representing an NMHDR 

structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def hwndFrom(self)->'typing.Any':
         """Window handle to the control sending a message. ??? 64-bit problem here ???"""
         pass


      @property
      def idFrom(self)->'typing.Any':
         """Identifier of the control sending a message."""
         pass


      @property
      def code(self)->'typing.Any':
         """Notification code. This member can be a control-specific notification code or it can be one of the common notification codes."""
         pass


class PyNOTIFYICONDATA(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyOVERLAPPED(object):
      """A Python object, representing an overlapped structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Offset(self)->'int':
         """Specifies a file position at which to start the transfer. The file position is a byte offset from the start of the file. The calling process sets this member before calling the ReadFile or WriteFile function. This member is ignored when reading from or writing to named pipes and communications devices."""
         pass


      @property
      def OffsetHigh(self)->'int':
         """Specifies the high word of the byte offset at which to start the transfer."""
         pass


      @property
      def object(self)->'typing.Any':
         """Any python object that you want to attach to your overlapped I/O request."""
         pass


      @property
      def dword(self)->'typing.Any':
         """An integer buffer that may be used by overlapped functions (eg, win32file::WaitCommEvent)"""
         pass


      @property
      def hEvent(self)->'int':
         """Identifies an event set to the signaled state when the transfer has been completed. The calling process sets this member before calling the win32file::ReadFile, win32file::WriteFile, win32pipe::ConnectNamedPipe, or win32pipe::TransactNamedPipe function."""
         pass


      @property
      def Internal(self)->'int':
         """Reserved for operating system use. (pointer-sized value)"""
         pass


      @property
      def InternalHigh(self)->'int':
         """Reserved for operating system use. (pointer-sized value)"""
         pass


class PyOVERLAPPEDReadBuffer(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyPERF_COUNTER_DEFINITION(object):
      """An object encapsulating a Windows NT Performance Monitor counter definition 

(PERF_COUNTER_DEFINITION)."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def DefaultScale(self)->'int':
         """The default scale of the counter."""
         pass


      @property
      def DetailLevel(self)->'int':
         """The detail level of the counter."""
         pass


      @property
      def CounterType(self)->'int':
         """The counter type."""
         pass


      @property
      def CounterNameTitleIndex(self)->'int':
         """"""
         pass


      @property
      def CounterHelpTitleIndex(self)->'int':
         """Sentinel"""
         pass


      def Increment(self,) -> 'None':
         """
         Increments the value of the performance counter

Args:



Returns:

      None
        
         """
         pass


      def Decrement(self,) -> 'None':
         """
         Decrements the value of the performance counter

Args:



Returns:

      None
        
         """
         pass


      def Set(self,) -> 'None':
         """
         Sets the counter to a specific value

Args:



Returns:

      None
        
         """
         pass


      def Get(self,) -> 'None':
         """
         Gets the current value of the counter

Args:



Returns:

      None
        
         """
         pass


class PyPERF_OBJECT_TYPE(object):
      """A Python object, representing a PERF_OBJECT_TYPE structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ObjectNameTitleIndex(self)->'int':
         """"""
         pass


      @property
      def ObjectHelpTitleIndex(self)->'int':
         """"""
         pass


      @property
      def DefaultCounterIndex(self)->'int':
         """"""
         pass


      def Close(self,) -> 'None':
         """
         Closes the object.

Args:



Returns:

      None
        
         """
         pass


class PyPOINT(object):
      """Tuple of two ints (x,y) representing a POINT struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyPROFILEINFO(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def UserName(self)->'str':
         """Name of user for which to load profile"""
         pass


      @property
      def Flags(self)->'typing.Any':
         """Combination of PI_* flags"""
         pass


      @property
      def ProfilePath(self)->'str':
         """Path to roaming profile, can be None.  Use win32net::NetUserGetInfo to retrieve user's profile path"""
         pass


      @property
      def DefaultPath(self)->'str':
         """Path to Default user profile, can be None"""
         pass


      @property
      def ServerName(self)->'str':
         """Domain controller, can be None"""
         pass


      @property
      def PolicyPath(self)->'str':
         """Location of policy file, can be None"""
         pass


      @property
      def Profile(self)->'PyHKEY':
         """Handle to root of user's registry key. This member is output."""
         pass


class PyPerfMonManager(object):
      """A Python object"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Close(self,) -> 'None':
         """
         Closes the performance monitor manager.

Args:



Returns:

      None
        
         """
         pass


class PyPrinterHANDLE(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyRECT(object):
      """Tuple of 4 ints defining a rectangle: (left, top, right, bottom)"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyResourceId(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySCROLLINFO(object):
      """A tuple representing a SCROLLINFO structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySC_HANDLE(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySECURITY_ATTRIBUTES(object):
      """A Python object, representing a SECURITY_ATTRIBUTES structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def bInheritHandle(self)->'typing.Any':
         """Specifies whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle."""
         pass


      @property
      def SECURITY_DESCRIPTOR(self)->'PySECURITY_DESCRIPTOR':
         """A PySECURITY_DESCRIPTOR, or None"""
         pass


class PySECURITY_DESCRIPTOR(object):
      """A Python object, representing a SECURITY_DESCRIPTOR structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,) -> 'None':
         """
         Initialize the SD.

Args:



Returns:

      None
        
         """
         pass


      def GetSecurityDescriptorOwner(self,) -> 'PySID':
         """
         Return the owner of the security descriptor.

Args:



Returns:

      PySID
        
         """
         pass


      def GetSecurityDescriptorDacl(self,) -> 'PyACL':
         """
         Return the discretionary ACL of the security 

descriptor.

Args:



Returns:

      PyACL
        
         """
         pass


      def GetSecurityDescriptorSacl(self,) -> 'PyACL':
         """
         Return system access control list (SACL) of SD

Args:



Returns:

      PyACL
        
         """
         pass


      def GetSecurityDescriptorControl(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Returns tuple of Control bit flags and 

revision of SD.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def SetSecurityDescriptorOwner(self,sid:'PySID',bOwnerDefaulted:'typing.Any') -> 'None':
         """
         Set owner SID.

Args:

      sid(PySID):The sid to be set as owner in the security descriptor.
      bOwnerDefaulted(typing.Any):Normally set to false since this explicitely set the owner.

Returns:

      None
        
         """
         pass


      def SetSecurityDescriptorGroup(self,sid:'PySID',bOwnerDefaulted:'typing.Any') -> 'typing.Any':
         """
         Set group SID.

Args:

      sid(PySID):The group sid to be set in the security descriptor.
      bOwnerDefaulted(typing.Any):Normally set to false since this explicitely set the owner.

Returns:

      typing.Any
        
         """
         pass


      def SetSecurityDescriptorSacl(self,bSaclPresent:'typing.Any',SACL:'PyACL',bSaclDefaulted:'typing.Any') -> 'None':
         """
         Replaces system access control list (SACL) in the security 

descriptor.

Args:

      bSaclPresent(typing.Any):A flag indicating if SACL is to be used. If false, last 2 parms are ignored.
      SACL(PyACL):The SACL to set in the security descriptor
      bSaclDefaulted(typing.Any):Flag, set to false if user has specifically set the SACL.

Returns:

      None
        
         """
         pass


      def IsValid(self,) -> 'None':
         """
         Determines if the security descriptor is valid.

Args:



Returns:

      None
        
         """
         pass


      def GetLength(self,) -> 'None':
         """
         return length of security descriptor (GetSecurityDescriptorLenght).

Args:



Returns:

      None
        
         """
         pass


      def IsSelfRelative(self,) -> 'None':
         """
         Returns 1 if security descriptor is self relative, 0 if absolute

Args:



Returns:

      None
        
         """
         pass


      def SetSecurityDescriptorControl(self,ControlBitsOfInterest:'typing.Any',ControlBitsToSet:'typing.Any') -> 'None':
         """
         Sets the control bit flags related to inheritance for a 

security descriptor

Args:

      ControlBitsOfInterest(typing.Any):Bitmask of flags to be modified
      ControlBitsToSet(typing.Any):Bitmask containing flag values to setCommentsOnly exists on Windows 2000 or later

Returns:

      None
        
         """
         pass


class PySERVER_INFO_100(object):
      """A dictionary holding the information in a Win32 SERVER_INFO_100 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def platform_id(self)->'typing.Any':
         """"""
         pass


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


class PySERVER_INFO_101(object):
      """A dictionary holding the information in a Win32 SERVER_INFO_101 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def platform_id(self)->'typing.Any':
         """"""
         pass


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def version_major(self)->'typing.Any':
         """"""
         pass


      @property
      def version_minor(self)->'typing.Any':
         """"""
         pass


      @property
      def type(self)->'typing.Any':
         """one of the SV_TYPE_* constants"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


class PySERVER_INFO_102(object):
      """A dictionary holding the information in a Win32 SERVER_INFO_102 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def platform_id(self)->'typing.Any':
         """"""
         pass


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def version_major(self)->'typing.Any':
         """"""
         pass


      @property
      def version_minor(self)->'typing.Any':
         """"""
         pass


      @property
      def type(self)->'typing.Any':
         """one of the SV_TYPE_* constants"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def users(self)->'typing.Any':
         """"""
         pass


      @property
      def disc(self)->'typing.Any':
         """"""
         pass


      @property
      def hidden(self)->'typing.Any':
         """"""
         pass


      @property
      def announce(self)->'typing.Any':
         """"""
         pass


      @property
      def anndelta(self)->'typing.Any':
         """"""
         pass


      @property
      def userpath(self)->'typing.Union[str]':
         """"""
         pass


class PySERVER_INFO_402(object):
      """A dictionary holding the information in a Win32 SERVER_INFO_402 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ulist_mtime(self)->'typing.Any':
         """"""
         pass


      @property
      def glist_mtime(self)->'typing.Any':
         """"""
         pass


      @property
      def alist_mtime(self)->'typing.Any':
         """"""
         pass


      @property
      def security(self)->'typing.Any':
         """"""
         pass


      @property
      def numadmin(self)->'typing.Any':
         """"""
         pass


      @property
      def lanmask(self)->'typing.Any':
         """"""
         pass


      @property
      def guestacct(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def chdevs(self)->'typing.Any':
         """"""
         pass


      @property
      def chdevq(self)->'typing.Any':
         """"""
         pass


      @property
      def chdevjobs(self)->'typing.Any':
         """"""
         pass


      @property
      def connections(self)->'typing.Any':
         """"""
         pass


      @property
      def shares(self)->'typing.Any':
         """"""
         pass


      @property
      def openfiles(self)->'typing.Any':
         """"""
         pass


      @property
      def sessopens(self)->'typing.Any':
         """"""
         pass


      @property
      def sessvcs(self)->'typing.Any':
         """"""
         pass


      @property
      def sessreqs(self)->'typing.Any':
         """"""
         pass


      @property
      def opensearch(self)->'typing.Any':
         """"""
         pass


      @property
      def activelocks(self)->'typing.Any':
         """"""
         pass


      @property
      def numreqbuf(self)->'typing.Any':
         """"""
         pass


      @property
      def sizreqbuf(self)->'typing.Any':
         """"""
         pass


      @property
      def numbigbuf(self)->'typing.Any':
         """"""
         pass


      @property
      def numfiletasks(self)->'typing.Any':
         """"""
         pass


      @property
      def alertsched(self)->'typing.Any':
         """"""
         pass


      @property
      def erroralert(self)->'typing.Any':
         """"""
         pass


      @property
      def logonalert(self)->'typing.Any':
         """"""
         pass


      @property
      def accessalert(self)->'typing.Any':
         """"""
         pass


      @property
      def diskalert(self)->'typing.Any':
         """"""
         pass


      @property
      def netioalert(self)->'typing.Any':
         """"""
         pass


      @property
      def maxauditsz(self)->'typing.Any':
         """"""
         pass


      @property
      def srvheuristics(self)->'typing.Union[str]':
         """"""
         pass


class PySERVER_INFO_403(object):
      """A dictionary holding the information in a Win32 SERVER_INFO_403 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ulist_mtime(self)->'typing.Any':
         """"""
         pass


      @property
      def glist_mtime(self)->'typing.Any':
         """"""
         pass


      @property
      def alist_mtime(self)->'typing.Any':
         """"""
         pass


      @property
      def security(self)->'typing.Any':
         """"""
         pass


      @property
      def numadmin(self)->'typing.Any':
         """"""
         pass


      @property
      def lanmask(self)->'typing.Any':
         """"""
         pass


      @property
      def guestacct(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def chdevs(self)->'typing.Any':
         """"""
         pass


      @property
      def chdevq(self)->'typing.Any':
         """"""
         pass


      @property
      def chdevjobs(self)->'typing.Any':
         """"""
         pass


      @property
      def connections(self)->'typing.Any':
         """"""
         pass


      @property
      def shares(self)->'typing.Any':
         """"""
         pass


      @property
      def openfiles(self)->'typing.Any':
         """"""
         pass


      @property
      def sessopens(self)->'typing.Any':
         """"""
         pass


      @property
      def sessvcs(self)->'typing.Any':
         """"""
         pass


      @property
      def sessreqs(self)->'typing.Any':
         """"""
         pass


      @property
      def opensearch(self)->'typing.Any':
         """"""
         pass


      @property
      def activelocks(self)->'typing.Any':
         """"""
         pass


      @property
      def numreqbuf(self)->'typing.Any':
         """"""
         pass


      @property
      def sizreqbuf(self)->'typing.Any':
         """"""
         pass


      @property
      def numbigbuf(self)->'typing.Any':
         """"""
         pass


      @property
      def numfiletasks(self)->'typing.Any':
         """"""
         pass


      @property
      def alertsched(self)->'typing.Any':
         """"""
         pass


      @property
      def erroralert(self)->'typing.Any':
         """"""
         pass


      @property
      def logonalert(self)->'typing.Any':
         """"""
         pass


      @property
      def accessalert(self)->'typing.Any':
         """"""
         pass


      @property
      def diskalert(self)->'typing.Any':
         """"""
         pass


      @property
      def netioalert(self)->'typing.Any':
         """"""
         pass


      @property
      def maxauditsz(self)->'typing.Any':
         """"""
         pass


      @property
      def srvheuristics(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def auditedevents(self)->'typing.Any':
         """"""
         pass


      @property
      def autoprofile(self)->'typing.Any':
         """"""
         pass


      @property
      def autopath(self)->'typing.Union[str]':
         """"""
         pass


class PySERVER_INFO_502(object):
      """A dictionary holding the information in a Win32 SERVER_INFO_502 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def sessopens(self)->'typing.Any':
         """"""
         pass


      @property
      def sessvcs(self)->'typing.Any':
         """"""
         pass


      @property
      def opensearch(self)->'typing.Any':
         """"""
         pass


      @property
      def sizreqbuf(self)->'typing.Any':
         """"""
         pass


      @property
      def initworkitems(self)->'typing.Any':
         """"""
         pass


      @property
      def maxworkitems(self)->'typing.Any':
         """"""
         pass


      @property
      def rawworkitems(self)->'typing.Any':
         """"""
         pass


      @property
      def irpstacksize(self)->'typing.Any':
         """"""
         pass


      @property
      def maxrawbuflen(self)->'typing.Any':
         """"""
         pass


      @property
      def sessusers(self)->'typing.Any':
         """"""
         pass


      @property
      def sessconns(self)->'typing.Any':
         """"""
         pass


      @property
      def maxpagedmemoryusage(self)->'typing.Any':
         """"""
         pass


      @property
      def maxnonpagedmemoryusage(self)->'typing.Any':
         """"""
         pass


      @property
      def enableforcedlogoff(self)->'typing.Any':
         """"""
         pass


      @property
      def timesource(self)->'typing.Any':
         """"""
         pass


      @property
      def acceptdownlevelapis(self)->'typing.Any':
         """"""
         pass


      @property
      def lmannounce(self)->'typing.Any':
         """"""
         pass


class PySERVER_INFO_503(object):
      """A dictionary holding the information in a Win32 SERVER_INFO_503 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def sessopens(self)->'typing.Any':
         """"""
         pass


      @property
      def sessvcs(self)->'typing.Any':
         """"""
         pass


      @property
      def opensearch(self)->'typing.Any':
         """"""
         pass


      @property
      def sizreqbuf(self)->'typing.Any':
         """"""
         pass


      @property
      def initworkitems(self)->'typing.Any':
         """"""
         pass


      @property
      def maxworkitems(self)->'typing.Any':
         """"""
         pass


      @property
      def rawworkitems(self)->'typing.Any':
         """"""
         pass


      @property
      def irpstacksize(self)->'typing.Any':
         """"""
         pass


      @property
      def maxrawbuflen(self)->'typing.Any':
         """"""
         pass


      @property
      def sessusers(self)->'typing.Any':
         """"""
         pass


      @property
      def sessconns(self)->'typing.Any':
         """"""
         pass


      @property
      def maxpagedmemoryusage(self)->'typing.Any':
         """"""
         pass


      @property
      def maxnonpagedmemoryusage(self)->'typing.Any':
         """"""
         pass


      @property
      def enableforcedlogoff(self)->'typing.Any':
         """"""
         pass


      @property
      def timesource(self)->'typing.Any':
         """"""
         pass


      @property
      def acceptdownlevelapis(self)->'typing.Any':
         """"""
         pass


      @property
      def lmannounce(self)->'typing.Any':
         """"""
         pass


      @property
      def domain(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def maxkeepsearch(self)->'typing.Any':
         """"""
         pass


      @property
      def scavtimeout(self)->'typing.Any':
         """"""
         pass


      @property
      def minrcvqueue(self)->'typing.Any':
         """"""
         pass


      @property
      def minfreeworkitems(self)->'typing.Any':
         """"""
         pass


      @property
      def xactmemsize(self)->'typing.Any':
         """"""
         pass


      @property
      def threadpriority(self)->'typing.Any':
         """"""
         pass


      @property
      def maxmpxct(self)->'typing.Any':
         """"""
         pass


      @property
      def oplockbreakwait(self)->'typing.Any':
         """"""
         pass


      @property
      def oplockbreakresponsewait(self)->'typing.Any':
         """"""
         pass


      @property
      def enableoplocks(self)->'typing.Any':
         """"""
         pass


      @property
      def enablefcbopens(self)->'typing.Any':
         """"""
         pass


      @property
      def enableraw(self)->'typing.Any':
         """"""
         pass


      @property
      def enablesharednetdrives(self)->'typing.Any':
         """"""
         pass


      @property
      def minfreeconnections(self)->'typing.Any':
         """"""
         pass


      @property
      def maxfreeconnections(self)->'typing.Any':
         """"""
         pass


class PySHARE_INFO_0(object):
      """A dictionary holding the infomation in a Win32 SHARE_INFO_0 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def netname(self)->'typing.Union[str]':
         """"""
         pass


class PySHARE_INFO_1(object):
      """A dictionary holding the infomation in a Win32 SHARE_INFO_1 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def netname(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def type(self)->'typing.Any':
         """"""
         pass


      @property
      def remark(self)->'typing.Union[str]':
         """"""
         pass


class PySHARE_INFO_2(object):
      """A dictionary holding the infomation in a Win32 SHARE_INFO_2 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def netname(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def type(self)->'typing.Any':
         """"""
         pass


      @property
      def remark(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def permissions(self)->'typing.Any':
         """"""
         pass


      @property
      def max_uses(self)->'typing.Any':
         """"""
         pass


      @property
      def current_uses(self)->'typing.Any':
         """"""
         pass


      @property
      def path(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def passwd(self)->'typing.Union[str]':
         """"""
         pass


class PySHARE_INFO_501(object):
      """A dictionary holding the infomation in a Win32 SHARE_INFO_501 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def netname(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def type(self)->'typing.Any':
         """"""
         pass


      @property
      def remark(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def flags(self)->'typing.Any':
         """"""
         pass


class PySHARE_INFO_502(object):
      """A dictionary holding the infomation in a Win32 SHARE_INFO_502 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def netname(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def type(self)->'typing.Any':
         """"""
         pass


      @property
      def remark(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def permissions(self)->'typing.Any':
         """"""
         pass


      @property
      def max_uses(self)->'typing.Any':
         """"""
         pass


      @property
      def current_uses(self)->'typing.Any':
         """"""
         pass


      @property
      def path(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def passwd(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def reserved(self)->'typing.Any':
         """"""
         pass


      @property
      def security_descriptor(self)->'PySECURITY_DESCRIPTOR':
         """"""
         pass


class PySID(object):
      """A Python object, representing a SID structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,idAuthority:'typing.Any',numSubauthorities:'typing.Any') -> 'None':
         """
         Initialize the SID.

Args:

      idAuthority(typing.Any):The identifier authority.
      numSubauthorities(typing.Any):The number of sub authorities to allocate.

Returns:

      None
        
         """
         pass


      def IsValid(self,) -> 'None':
         """
         Determines if the SID is valid.

Args:



Returns:

      None
        
         """
         pass


      def SetSubAuthority(self,index:'typing.Any',val:'typing.Any') -> 'None':
         """
         Sets a SID SubAuthority

Args:

      index(typing.Any):The index of the sub authority to set
      val(typing.Any):The value for the sub authorityCommentsSee the function SetSidSubAuthority

Returns:

      None
        
         """
         pass


      def GetLength(self,) -> 'typing.Any':
         """
         return length of SID (GetLengthSid).

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSubAuthorityCount(self,) -> 'typing.Any':
         """
         return nbr of subauthorities from SID

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSubAuthority(self,) -> 'typing.Any':
         """
         Returns specified subauthority from SID

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSidIdentifierAuthority(self,) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Returns a tuple of 6 SID_IDENTIFIER_AUTHORITY 

constants

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


class PySID_AND_ATTRIBUTES(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySIZE(object):
      """Tuple of two ints (cx,cy) representing a SIZE struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySMALL_RECT(object):
      """Wrapper for a SMALL_RECT struct 

Create using PySMALL_RECTType(Left, Top, Right, Bottom). All params optional, defaulting to 0"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Left(self)->'typing.Any':
         """Left side of rectangle"""
         pass


      @property
      def Top(self)->'typing.Any':
         """Top edge of rectangle"""
         pass


      @property
      def Right(self)->'typing.Any':
         """Right edge of rectangle"""
         pass


      @property
      def Bottom(self)->'typing.Any':
         """Bottome edge of rectangle"""
         pass


class PySTARTUPINFO(object):
      """A Python object, representing an STARTUPINFO structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def dwX(self)->'int':
         """Specifies the x offset, in pixels, of the upper left corner of a window if a new window is created. The offset is from the upper left corner of the screen."""
         pass


      @property
      def dwY(self)->'int':
         """Specifies the y offset, in pixels, of the upper left corner of a window if a new window is created. The offset is from the upper left corner of the screen."""
         pass


      @property
      def dwXSize(self)->'int':
         """Specifies the width, in pixels, of the window if a new window is created."""
         pass


      @property
      def dwYSize(self)->'int':
         """Specifies the height, in pixels, of the window if a new window is created."""
         pass


      @property
      def dwXCountChars(self)->'int':
         """For console processes, if a new console window is created, specifies the screen buffer width in character columns. This value is ignored in a GUI process."""
         pass


      @property
      def dwYCountChars(self)->'int':
         """For console processes, if a new console window is created, specifies the screen buffer height in character rows."""
         pass


      @property
      def dwFillAttribute(self)->'int':
         """Specifies the initial text and background colors if a new console window is created in a console application. These values are ignored in GUI applications"""
         pass


      @property
      def dwFlags(self)->'int':
         """This is a bit field that determines whether certain STARTUPINFO attributes are used when the process creates a window. To use many of the additional attributes, you typically must set the appropriate mask in this attribute, and also set the attributes themselves. Any combination of the win32con.STARTF_* flags can be specified."""
         pass


      @property
      def wShowWindow(self)->'int':
         """Can be any of the SW_ constants defined in win32con. For GUI processes, this specifies the default value the first time ShowWindow is called."""
         pass


      @property
      def hStdInput(self)->'typing.Union[int]':
         """"""
         pass


      @property
      def hStdOutput(self)->'typing.Union[int]':
         """"""
         pass


      @property
      def hStdError(self)->'typing.Union[int]':
         """"""
         pass


      @property
      def lpDesktop(self)->'typing.Union[str, typing.Any]':
         """"""
         pass


      @property
      def lpTitle(self)->'typing.Union[str, typing.Any]':
         """"""
         pass


class PySecBuffer(object):
      """Python object wrapping a SecBuffer structure 

Created using win32security.PySecBufferType(type,size) where type is a SECBUFFER_* constant"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def BufferType(self)->'typing.Any':
         """"""
         pass


      @property
      def Buffer(self)->'str':
         """"""
         pass


      @property
      def BufferSize(self)->'typing.Any':
         """"""
         pass


      @property
      def MaxBufferSize(self)->'typing.Any':
         """"""
         pass


      def Clear(self,) -> 'None':
         """
         Resets the buffer to all NULL's, and set the current size to maximum

Args:



Returns:

      None
        
         """
         pass


class PySecBufferDesc(object):
      """Sequence-like object that contains a group of buffers to be used with SSPI functions."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def append(self,buffer:'typing.Any') -> 'None':
         """
         None

Args:

      buffer(typing.Any):PySecBuffer object to be attached to the group of buffers

Returns:

      None
        
         """
         pass


class PyTOKEN_GROUPS(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyTOKEN_PRIVILEGES(object):
      """An object representing Win32 token privileges."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyTRIVERTEX(object):
      """Dict representing a TRIVERTEX struct containing color information at a point"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def x(self)->'typing.Any':
         """X coord in logical units"""
         pass


      @property
      def y(self)->'typing.Any':
         """Y coord in logical units"""
         pass


      @property
      def Red(self)->'typing.Any':
         """Red component"""
         pass


      @property
      def Green(self)->'typing.Any':
         """Green component"""
         pass


      @property
      def Blue(self)->'typing.Any':
         """Blue component"""
         pass


      @property
      def Alpha(self)->'typing.Any':
         """Transparency value"""
         pass


class PyTRUSTEE(object):
      """A dictionary representing a TRUSTEE structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def TrusteeForm(self)->'typing.Any':
         """"""
         pass


      @property
      def TrusteeType(self)->'typing.Any':
         """"""
         pass


      @property
      def Identifier(self)->'typing.Any':
         """Depends on the value of TrusteeForm (string or sid)"""
         pass


      @property
      def MultipleTrustee(self)->'typing.Any':
         """default is None"""
         pass


      @property
      def MultipleTrusteeOperation(self)->'typing.Any':
         """default is None"""
         pass


class PyTS_HANDLE(object):
      """Handle to a Terminal Server"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyTime(object):
      """A Python object, representing an instant in time."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def year(self)->'typing.Any':
         """"""
         pass


      @property
      def month(self)->'typing.Any':
         """"""
         pass


      @property
      def weekday(self)->'typing.Any':
         """"""
         pass


      @property
      def day(self)->'typing.Any':
         """"""
         pass


      @property
      def hour(self)->'typing.Any':
         """"""
         pass


      @property
      def minute(self)->'typing.Any':
         """"""
         pass


      @property
      def second(self)->'typing.Any':
         """"""
         pass


      @property
      def msec(self)->'typing.Any':
         """"""
         pass


      def Format(self,_format:'str') -> 'str':
         """
         Formats the time value.

Args:

      _format(str):The format.  See the comments section for a description of the supported flags.CommentsThe following format characters are supported.CharacterDescription%aAbbreviated weekday name%AFull weekday name%bAbbreviated month name%BFull month name%cDate and time representation appropriate for locale%dDay of month as decimal number (01 - 31)%HHour in 24-hour format (00 - 23)%IHour in 12-hour format (01 - 12)%jDay of year as decimal number (001 - 366)%mMonth as decimal number (01 - 12)%MMinute as decimal number (00 - 59)%pCurrent locale's A.M./P.M. indicator for 12-hour clock%SSecond as decimal number (00 - 59)%UWeek of year as decimal number, with Sunday as first day of week (00 - 51)%wWeekday as decimal number (0 - 6; Sunday is 0)%WWeek of year as decimal number, with Monday as first day of week (00 - 51)%xDate representation for current locale%XTime representation for current locale%yYear without century, as decimal number (00 - 99)%YYear with century, as decimal number%z, %ZTime-zone name or abbreviation; no characters if time zone is unknown%%Percent signAs in the printf function, the # flag may prefix any formatting code. In that case, the meaning of the format code is changed as follows.Format CodeMeaning%#a, %#A, %#b, %#B, %#p, %#X, %#z, %#Z, %#%# flag is ignored.%#cLong date and time representation, appropriate for current locale. For example: "Tuesday, March 14, 1995, 12:41:29".%#xLong date representation, appropriate to current locale. For example: "Tuesday, March 14, 1995".%#d, %#H, %#I, %#j, %#m, %#M, %#S, %#U, %#w, %#W, %#y, %#YRemove leading zeros (if any).

Returns:

      str
        
         """
         pass


class PyUSER_INFO_0(object):
      """A dictionary holding the information in a Win32 USER_INFO_0 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


class PyUSER_INFO_1(object):
      """A dictionary holding the information in a Win32 USER_INFO_1 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password_age(self)->'typing.Any':
         """"""
         pass


      @property
      def priv(self)->'typing.Any':
         """"""
         pass


      @property
      def home_dir(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def flags(self)->'typing.Any':
         """"""
         pass


      @property
      def script_path(self)->'typing.Union[str]':
         """"""
         pass


class PyUSER_INFO_10(object):
      """A dictionary holding the information in a Win32 USER_INFO_10 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def usr_comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def full_name(self)->'typing.Union[str]':
         """"""
         pass


class PyUSER_INFO_1003(object):
      """A dictionary holding the information in a Win32 USER_INFO_1003 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def password(self)->'typing.Union[str]':
         """"""
         pass


class PyUSER_INFO_1005(object):
      """A dictionary holding the information in a Win32 USER_INFO_1005 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def priv(self)->'typing.Any':
         """"""
         pass


class PyUSER_INFO_1006(object):
      """A dictionary holding the information in a Win32 USER_INFO_1006 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def home_dir(self)->'typing.Union[str]':
         """"""
         pass


class PyUSER_INFO_1007(object):
      """A dictionary holding the information in a Win32 USER_INFO_1007 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


class PyUSER_INFO_1008(object):
      """A dictionary holding the information in a Win32 USER_INFO_1008 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def flags(self)->'typing.Any':
         """"""
         pass


class PyUSER_INFO_1009(object):
      """A dictionary holding the information in a Win32 USER_INFO_1009 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def script_path(self)->'typing.Union[str]':
         """"""
         pass


class PyUSER_INFO_1010(object):
      """A dictionary holding the information in a Win32 USER_INFO_1010 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def auth_flags(self)->'typing.Any':
         """"""
         pass


class PyUSER_INFO_1011(object):
      """A dictionary holding the information in a Win32 USER_INFO_1011 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def full_name(self)->'typing.Union[str]':
         """"""
         pass


class PyUSER_INFO_11(object):
      """A dictionary holding the information in a Win32 USER_INFO_11 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def usr_comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def full_name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def priv(self)->'typing.Any':
         """"""
         pass


      @property
      def auth_flags(self)->'typing.Any':
         """"""
         pass


      @property
      def password_age(self)->'typing.Any':
         """"""
         pass


      @property
      def home_dir(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def parms(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def last_logon(self)->'typing.Any':
         """"""
         pass


      @property
      def last_logoff(self)->'typing.Any':
         """"""
         pass


      @property
      def bad_pw_count(self)->'typing.Any':
         """"""
         pass


      @property
      def num_logons(self)->'typing.Any':
         """"""
         pass


      @property
      def logon_server(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def country_code(self)->'typing.Any':
         """"""
         pass


      @property
      def workstations(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def max_storage(self)->'typing.Any':
         """"""
         pass


      @property
      def units_per_week(self)->'typing.Any':
         """"""
         pass


      @property
      def logon_hours(self)->'str':
         """"""
         pass


      @property
      def code_page(self)->'typing.Any':
         """"""
         pass


class PyUSER_INFO_2(object):
      """A dictionary holding the information in a Win32 USER_INFO_2 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password_age(self)->'typing.Any':
         """"""
         pass


      @property
      def priv(self)->'typing.Any':
         """"""
         pass


      @property
      def home_dir(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def flags(self)->'typing.Any':
         """"""
         pass


      @property
      def script_path(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def auth_flags(self)->'typing.Any':
         """"""
         pass


      @property
      def full_name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def usr_comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def parms(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def workstations(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def last_logon(self)->'typing.Any':
         """"""
         pass


      @property
      def last_logoff(self)->'typing.Any':
         """"""
         pass


      @property
      def acct_expires(self)->'typing.Any':
         """"""
         pass


      @property
      def max_storage(self)->'typing.Any':
         """"""
         pass


      @property
      def units_per_week(self)->'typing.Any':
         """"""
         pass


      @property
      def logon_hours(self)->'str':
         """"""
         pass


      @property
      def bad_pw_count(self)->'typing.Any':
         """"""
         pass


      @property
      def num_logons(self)->'typing.Any':
         """"""
         pass


      @property
      def logon_server(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def country_code(self)->'typing.Any':
         """"""
         pass


      @property
      def code_page(self)->'typing.Any':
         """"""
         pass


class PyUSER_INFO_20(object):
      """A dictionary holding the information in a Win32 USER_INFO_20 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def full_name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def flags(self)->'typing.Any':
         """"""
         pass


      @property
      def user_id(self)->'typing.Any':
         """"""
         pass


class PyUSER_INFO_3(object):
      """A dictionary holding the information in a Win32 USER_INFO_3 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password_age(self)->'typing.Any':
         """"""
         pass


      @property
      def priv(self)->'typing.Any':
         """"""
         pass


      @property
      def home_dir(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def flags(self)->'typing.Any':
         """"""
         pass


      @property
      def script_path(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def auth_flags(self)->'typing.Any':
         """"""
         pass


      @property
      def full_name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def usr_comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def parms(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def workstations(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def last_logon(self)->'typing.Any':
         """"""
         pass


      @property
      def last_logoff(self)->'typing.Any':
         """"""
         pass


      @property
      def acct_expires(self)->'typing.Any':
         """"""
         pass


      @property
      def max_storage(self)->'typing.Any':
         """"""
         pass


      @property
      def units_per_week(self)->'typing.Any':
         """"""
         pass


      @property
      def logon_hours(self)->'str':
         """"""
         pass


      @property
      def bad_pw_count(self)->'typing.Any':
         """"""
         pass


      @property
      def num_logons(self)->'typing.Any':
         """"""
         pass


      @property
      def logon_server(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def country_code(self)->'typing.Any':
         """"""
         pass


      @property
      def code_page(self)->'typing.Any':
         """"""
         pass


      @property
      def user_id(self)->'typing.Any':
         """"""
         pass


      @property
      def primary_group_id(self)->'typing.Any':
         """"""
         pass


      @property
      def profile(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def home_dir_drive(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password_expired(self)->'typing.Any':
         """"""
         pass


class PyUSER_INFO_4(object):
      """A dictionary holding the information in a Win32 USER_INFO_4 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password_age(self)->'typing.Any':
         """"""
         pass


      @property
      def priv(self)->'typing.Any':
         """"""
         pass


      @property
      def home_dir(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def flags(self)->'typing.Any':
         """"""
         pass


      @property
      def script_path(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def auth_flags(self)->'typing.Any':
         """"""
         pass


      @property
      def full_name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def usr_comment(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def parms(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def workstations(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def last_logon(self)->'typing.Any':
         """"""
         pass


      @property
      def last_logoff(self)->'typing.Any':
         """"""
         pass


      @property
      def acct_expires(self)->'typing.Any':
         """"""
         pass


      @property
      def max_storage(self)->'typing.Any':
         """"""
         pass


      @property
      def units_per_week(self)->'typing.Any':
         """"""
         pass


      @property
      def logon_hours(self)->'str':
         """"""
         pass


      @property
      def bad_pw_count(self)->'typing.Any':
         """"""
         pass


      @property
      def num_logons(self)->'typing.Any':
         """"""
         pass


      @property
      def logon_server(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def country_code(self)->'typing.Any':
         """"""
         pass


      @property
      def code_page(self)->'typing.Any':
         """"""
         pass


      @property
      def user_sid(self)->'PySID':
         """"""
         pass


      @property
      def primary_group_id(self)->'typing.Any':
         """"""
         pass


      @property
      def profile(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def home_dir_drive(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password_expired(self)->'typing.Any':
         """"""
         pass


class PyUSER_MODALS_INFO_0(object):
      """A dictionary holding the information in a Win32 USER_MODALS_INFO_0 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def min_passwd_len(self)->'typing.Any':
         """"""
         pass


      @property
      def max_passwd_age(self)->'typing.Any':
         """"""
         pass


      @property
      def min_passwd_age(self)->'typing.Any':
         """"""
         pass


      @property
      def force_logoff(self)->'typing.Any':
         """"""
         pass


      @property
      def password_hist_len(self)->'typing.Any':
         """"""
         pass


class PyUSER_MODALS_INFO_1(object):
      """A dictionary holding the information in a Win32 USER_MODALS_INFO_1 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def role(self)->'typing.Any':
         """"""
         pass


      @property
      def primary(self)->'typing.Union[str]':
         """"""
         pass


class PyUSER_MODALS_INFO_2(object):
      """A dictionary holding the information in a Win32 USER_MODALS_INFO_2 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def domain_name(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def domain_id(self)->'PySID':
         """"""
         pass


class PyUSER_MODALS_INFO_3(object):
      """A dictionary holding the information in a Win32 USER_MODALS_INFO_3 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def lockout_duration(self)->'typing.Any':
         """"""
         pass


      @property
      def lockout_observation_window(self)->'typing.Any':
         """"""
         pass


      @property
      def usrmod3_lockout_threshold(self)->'typing.Any':
         """"""
         pass


class PyUSE_INFO_0(object):
      """A dictionary holding the infomation in a Win32 USE_INFO_0 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def local(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def remote(self)->'typing.Union[str]':
         """"""
         pass


class PyUSE_INFO_1(object):
      """A dictionary holding the infomation in a Win32 USE_INFO_1 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def local(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def remote(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password(self)->'typing.Union[str, typing.Any]':
         """"""
         pass


      @property
      def status(self)->'typing.Any':
         """"""
         pass


      @property
      def asg_type(self)->'typing.Any':
         """"""
         pass


      @property
      def refcount(self)->'typing.Any':
         """"""
         pass


      @property
      def usecount(self)->'typing.Any':
         """"""
         pass


class PyUSE_INFO_2(object):
      """A dictionary holding the infomation in a Win32 USE_INFO_2 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def local(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def remote(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password(self)->'typing.Union[str, typing.Any]':
         """"""
         pass


      @property
      def status(self)->'typing.Any':
         """"""
         pass


      @property
      def asg_type(self)->'typing.Any':
         """"""
         pass


      @property
      def refcount(self)->'typing.Any':
         """"""
         pass


      @property
      def usecount(self)->'typing.Any':
         """"""
         pass


      @property
      def username(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def domainname(self)->'typing.Union[str]':
         """"""
         pass


class PyUSE_INFO_3(object):
      """A dictionary holding the infomation in a Win32 USE_INFO_3 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def local(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def remote(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def password(self)->'typing.Union[str, typing.Any]':
         """"""
         pass


      @property
      def status(self)->'typing.Any':
         """"""
         pass


      @property
      def asg_type(self)->'typing.Any':
         """"""
         pass


      @property
      def refcount(self)->'typing.Any':
         """"""
         pass


      @property
      def usecount(self)->'typing.Any':
         """"""
         pass


      @property
      def username(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def domainname(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def flags(self)->'typing.Any':
         """"""
         pass


class PyUnicode(object):
      """A Python object, representing a Unicode string."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyUrlCacheHANDLE(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyWAVEFORMATEX(object):
      """A Python object, representing a WAVEFORMATEX structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def wFormatTag(self)->'int':
         """Waveform-audio format type. pywintypes only defines WAVE_FORMAT_PCM as a constant. Other values must be looked up in the mmsystem.h header file."""
         pass


      @property
      def nChannels(self)->'int':
         """Number of channels. 1 for Mono, 2 for Stereo, anything, but never 5.1."""
         pass


      @property
      def nSamplesPerSec(self)->'int':
         """Sample rate, in samples per second (hertz), that each channel should be played or recorded. If wFormatTag is WAVE_FORMAT_PCM, then common values for nSamplesPerSec are 8000, 11025, 22050, and 44100 Hz"""
         pass


      @property
      def nAvgBytesPerSec(self)->'int':
         """Required average data-transfer rate, in bytes per second, for the format tag. If wFormatTag is WAVE_FORMAT_PCM, nAvgBytesPerSec should be equal to the product of nSamplesPerSec and nBlockAlign."""
         pass


      @property
      def nBlockAlign(self)->'int':
         """Block alignment, in bytes. The block alignment is the minimum atomic unit of data for the wFormatTag format type. If wFormatTag is WAVE_FORMAT_PCM, nBlockAlign should be equal to the product of nChannels and wBitsPerSample divided by 8 (bits per byte). For non-PCM formats, this member must be computed according to the manufacturers specification of the format tag."""
         pass


      @property
      def wBitsPerSample(self)->'int':
         """Bits per sample for the wFormatTag format type. If wFormatTag is WAVE_FORMAT_PCM, then wBitsPerSample should be equal to 8 or 16. Sentinel"""
         pass


class PyWINHTTP_AUTOPROXY_OPTIONS(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyWINHTTP_PROXY_INFO(object):
      """A tuple representing a WINHTTP_PROXY_INFO structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyWKSTA_INFO_100(object):
      """A dictionary holding the infomation in a Win32 WKSTA_INFO_100 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def platform_id(self)->'typing.Any':
         """Indicates platform level to use to retrieve platform specific information"""
         pass


      @property
      def computername(self)->'typing.Union[str]':
         """Name of the local computer"""
         pass


      @property
      def langroup(self)->'typing.Union[str]':
         """Name of the domain to which computer belongs"""
         pass


      @property
      def ver_major(self)->'typing.Any':
         """Major version number of operating system running on the computer"""
         pass


      @property
      def ver_minor(self)->'typing.Any':
         """Minor version number of operating system running on the computer"""
         pass


class PyWKSTA_INFO_101(object):
      """A dictionary holding the infomation in a Win32 WKSTA_INFO_101 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def platform_id(self)->'typing.Any':
         """Indicates platform level to use to retrieve platform specific information"""
         pass


      @property
      def computername(self)->'typing.Union[str]':
         """Name of the local computer"""
         pass


      @property
      def langroup(self)->'typing.Union[str]':
         """Name of the domain to which computer belongs"""
         pass


      @property
      def ver_major(self)->'typing.Any':
         """Major version number of operating system running on the computer"""
         pass


      @property
      def ver_minor(self)->'typing.Any':
         """Minor version number of operating system running on the computer"""
         pass


      @property
      def lanroot(self)->'typing.Union[str]':
         """Path to the LANMAN directory"""
         pass


class PyWKSTA_INFO_102(object):
      """A dictionary holding the infomation in a Win32 WKSTA_INFO_102 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def platform_id(self)->'typing.Any':
         """Indicate platform level to use to retrieve platform specific information"""
         pass


      @property
      def computername(self)->'typing.Union[str]':
         """Name of the local computer"""
         pass


      @property
      def langroup(self)->'typing.Union[str]':
         """Name of the domain to which computer belongs"""
         pass


      @property
      def ver_major(self)->'typing.Any':
         """Major version number of operating system running on the computer"""
         pass


      @property
      def ver_minor(self)->'typing.Any':
         """Minor version number of operating system running on the computer"""
         pass


      @property
      def lanroot(self)->'typing.Union[str]':
         """Path to the LANMAN directory"""
         pass


      @property
      def logged_on_users(self)->'typing.Any':
         """Number of users who are logged on to the local computer"""
         pass


class PyWKSTA_INFO_302(object):
      """A dictionary holding the infomation in a Win32 WKSTA_INFO_302 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def char_wait(self)->'typing.Any':
         """number of seconds the computer will wait for a remote resource to become available"""
         pass


      @property
      def collection_time(self)->'typing.Any':
         """number of milliseconds the computer will collect data before sending the data to a character device resource. The workstation waits the specified time or collects the number of characters specified by wki302_maximum_collection_count, whichever comes first."""
         pass


      @property
      def maximum_collection_count(self)->'typing.Any':
         """Specifies the number of bytes of information the computer will collect before sending the data to a character device resource. The workstation collects the specified number of bytes or waits the time specified by wki302_collection_time, whichever comes first."""
         pass


      @property
      def keep_conn(self)->'typing.Any':
         """Specifies the number of seconds the server will maintain an inactive connection to a resource."""
         pass


      @property
      def keep_search(self)->'typing.Any':
         """Defines the number of seconds an inactive search will continue."""
         pass


      @property
      def max_cmds(self)->'typing.Any':
         """Specifies the number of simultaneous network device driver commands that can be sent to the network."""
         pass


      @property
      def num_work_buf(self)->'typing.Any':
         """Specifies the number of internal buffers the computer has."""
         pass


      @property
      def siz_work_buf(self)->'typing.Any':
         """Specifies the size, in bytes, of each internal buffer."""
         pass


      @property
      def max_wrk_cache(self)->'typing.Any':
         """Specifies the maximum size, in bytes, of an internal cache buffer."""
         pass


      @property
      def siz_error(self)->'typing.Any':
         """Specifies the size, in bytes, of an internal error buffer."""
         pass


      @property
      def num_alerts(self)->'typing.Any':
         """Specifies the maximum number of clients that can receive alert messages. (This member is not supported under MS-DOS.) The Alerter service registers at least three clients when it begins to run."""
         pass


      @property
      def num_services(self)->'typing.Any':
         """Specifies the number of services that can be installed on the computer at any time."""
         pass


      @property
      def errlog_sz(self)->'typing.Any':
         """Specifies the maximum size, in kilobytes, of the client's error log file."""
         pass


      @property
      def print_buf_time(self)->'typing.Any':
         """Specifies the number of seconds the server waits before closing inactive compatibility-mode print jobs."""
         pass


      @property
      def num_char_buf(self)->'typing.Any':
         """Specifies the number of character pipe buffers and device buffers the client can have."""
         pass


      @property
      def siz_char_buf(self)->'typing.Any':
         """Specifies the maximum size, in bytes, of a character pipe buffer and device buffer."""
         pass


      @property
      def wrk_heuristics(self)->'typing.Union[str]':
         """Pointer to a Unicode string of flags used to control a client's operation."""
         pass


      @property
      def mailslots(self)->'typing.Any':
         """Specifies the maximum number of mailslots allowed."""
         pass


      @property
      def num_dgram_buf(self)->'typing.Any':
         """Specifies the number of buffers to allocate for receiving datagrams."""
         pass


class PyWKSTA_INFO_402(object):
      """A dictionary holding the infomation in a Win32 WKSTA_INFO_402 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def char_wait(self)->'typing.Any':
         """number of seconds the computer will wait for a remote resource to become available"""
         pass


      @property
      def collection_time(self)->'typing.Any':
         """number of milliseconds the computer will collect data before sending the data to a character device resource. The workstation waits the specified time or collects the number of characters specified by wki402_maximum_collection_count, whichever comes first."""
         pass


      @property
      def maximum_collection_count(self)->'typing.Union[str]':
         """Name of the domain to which computer belongs"""
         pass


      @property
      def keep_conn(self)->'typing.Any':
         """Major version number of operating system running on the computer"""
         pass


      @property
      def keep_search(self)->'typing.Any':
         """Minor version number of operating system running on the computer"""
         pass


      @property
      def max_cmds(self)->'typing.Any':
         """.."""
         pass


      @property
      def num_work_buf(self)->'typing.Any':
         """Number of users who are logged on to the local computer"""
         pass


      @property
      def siz_work_buf(self)->'typing.Any':
         """Number of users who are logged on to the local computer"""
         pass


      @property
      def max_wrk_cache(self)->'typing.Any':
         """.."""
         pass


      @property
      def sess_timeout(self)->'typing.Any':
         """.."""
         pass


      @property
      def siz_error(self)->'typing.Any':
         """.."""
         pass


      @property
      def num_alerts(self)->'typing.Any':
         """.."""
         pass


      @property
      def num_services(self)->'typing.Any':
         """.."""
         pass


      @property
      def errlog_sz(self)->'typing.Any':
         """.."""
         pass


      @property
      def print_buf_time(self)->'typing.Any':
         """.."""
         pass


      @property
      def num_char_buf(self)->'typing.Any':
         """.."""
         pass


      @property
      def siz_char_buf(self)->'typing.Any':
         """Specifies the maximum size, in bytes, of a character pipe buffer and device buffer."""
         pass


      @property
      def mailslots(self)->'typing.Any':
         """.."""
         pass


      @property
      def num_dgram_buf(self)->'typing.Any':
         """.."""
         pass


      @property
      def max_threads(self)->'typing.Any':
         """Number of threads the computer can dedicate to the network"""
         pass


class PyWKSTA_INFO_502(object):
      """A dictionary holding the infomation in a Win32 WKSTA_INFO_502 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def char_wait(self)->'typing.Any':
         """number of seconds the computer will wait for a remote resource to become available"""
         pass


      @property
      def collection_time(self)->'typing.Any':
         """number of milliseconds the computer will collect data before sending the data to a character device resource. The workstation waits the specified time or collects the number of characters specified by wki502_maximum_collection_count, whichever comes first."""
         pass


      @property
      def maximum_collection_count(self)->'typing.Any':
         """Specifies the number of bytes of information the computer will collect before sending the data to a character device resource. The workstation collects the specified number of bytes or waits the time specified by wki302_collection_time, whichever comes first."""
         pass


      @property
      def keep_conn(self)->'typing.Any':
         """Specifies the number of seconds the server will maintain an inactive connection to a resource."""
         pass


      @property
      def max_cmds(self)->'typing.Any':
         """Specifies the number of simultaneous network device driver commands that can be sent to the network."""
         pass


      @property
      def max_wrk_cache(self)->'typing.Any':
         """Indicates the number of seconds the server waits before disconnecting an inactive session."""
         pass


      @property
      def siz_char_buf(self)->'typing.Any':
         """Specifies the maximum size, in bytes, of a character pipe buffer and device buffer."""
         pass


      @property
      def lock_quota(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def lock_increment(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def lock_maximum(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def pipe_increment(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def pipe_maximum(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def cache_file_timeout(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def dormant_file_limit(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def read_ahead_throughput(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def num_mailslot_buffers(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def num_srv_announce_buffers(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def max_illegal_datagram_events(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def illegal_datagram_event_reset_frequency(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def log_election_packets(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def use_opportunistic_locking(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def use_unlock_behind(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def use_close_behind(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def buf_named_pipes(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def use_lock_read_unlock(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def utilize_nt_caching(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def use_raw_read(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def use_raw_write(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def use_write_raw_data(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def use_encryption(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def buf_files_deny_write(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def buf_read_only_files(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def force_core_create_mode(self)->'typing.Any':
         """TODO"""
         pass


      @property
      def use_512_byte_max_transfer(self)->'typing.Any':
         """TODO"""
         pass


class PyWKSTA_TRANSPORT_INFO_0(object):
      """A dictionary holding the infomation in a Win32 WKSTA_TRANSPORT_INFO_0 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def quality_of_service(self)->'typing.Any':
         """Supplies a value that specifies the search order of the transport protocol with respect to other transport protocols. The highest value is searched first."""
         pass


      @property
      def number_of_vcs(self)->'typing.Any':
         """Specifies the number of clients communicating with the server using this transport protocol."""
         pass


      @property
      def transport_name(self)->'typing.Union[str]':
         """Specifies the device name of the transport protocol."""
         pass


      @property
      def transport_address(self)->'typing.Union[str]':
         """Specifies the address of the server on this transport protocol."""
         pass


      @property
      def wan_ish(self)->'typing.Any':
         """This member is ignored by the NetWkstaTransportAdd function. For the NetWkstaTransportEnum function, this member indicates that this transport protocol is a WAN transport protocol. This member is set TRUE for NetBIOS/TCIP; it is set FALSE for NetBEUI and NetBIOS/IPX."""
         pass


class PyWKSTA_USER_INFO_0(object):
      """A dictionary holding the infomation in a Win32 WKSTA_USER_INFO_0 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def username(self)->'typing.Union[str]':
         """Name of user currently logged on to the workstation"""
         pass


class PyWKSTA_USER_INFO_1(object):
      """A dictionary holding the infomation in a Win32 WKSTA_USER_INFO_1 structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def username(self)->'typing.Union[str]':
         """Name of user currently logged on to the workstation"""
         pass


      @property
      def logon_domain(self)->'typing.Union[str]':
         """Returns the domain name of the user account of the user currently logged on to the workstation."""
         pass


      @property
      def oth_domains(self)->'typing.Union[str]':
         """Returns the list of other operating system domains browsed by the workstation. The domain names are separated by blanks."""
         pass


      @property
      def logon_server(self)->'typing.Union[str]':
         """Returns the name of the computer that authenticated the server."""
         pass


class PyWNDCLASS(object):
      """A Python object, representing an WNDCLASS structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def style(self)->'int':
         """"""
         pass


      @property
      def cbWndExtra(self)->'int':
         """"""
         pass


      @property
      def hInstance(self)->'int':
         """"""
         pass


      @property
      def hIcon(self)->'int':
         """"""
         pass


      @property
      def hCursor(self)->'int':
         """"""
         pass


      @property
      def hbrBackground(self)->'int':
         """These 3 handled manually in PyWNDCLASS::getattro/setattro.  The pymeth below is used as an end tag, so these props will be lost if below it"""
         pass


      @property
      def lpszMenuName(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def lpszClassName(self)->'typing.Union[str]':
         """"""
         pass


      @property
      def lpfnWndProc(self)->'typing.Any':
         """MethodsSetDialogProcSets the WNDCLASS to be for a dialog box. """
         pass


      def SetDialogProc(self,) -> 'None':
         """
         Sets the WNDCLASS to be for a dialog box

Args:



Returns:

      None
        
         """
         pass


class PyXFORM(object):
      """Dict representing an XFORM struct used as a world transformation matrix 

All members are optional, defaulting to 0.0."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def M11(self)->'float':
         """Usage is dependent on operation performed, see MSDN docs"""
         pass


      @property
      def M12(self)->'float':
         """Usage is dependent on operation performed, see MSDN docs"""
         pass


      @property
      def M21(self)->'float':
         """Usage is dependent on operation performed, see MSDN docs"""
         pass


      @property
      def M22(self)->'float':
         """Usage is dependent on operation performed, see MSDN docs"""
         pass


      @property
      def Dx(self)->'float':
         """Horizontal offset in logical units"""
         pass


      @property
      def Dy(self)->'float':
         """Vertical offset in logical units"""
         pass


class Pymmapfile(object):
      """Object that provides access to memory-mapped file operations."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def close(self,) -> 'None':
         """
         Closes the file mapping handle and releases mapped view

Args:



Returns:

      None
        
         """
         pass


      def find(self,needle:'typing.Any',start:'typing.Any') -> 'typing.Any':
         """
         Finds a string in the buffer.

Args:

      needle(typing.Any):String to be located
      start(typing.Any):Pos at which to start search, current pos assumed if not specifiedReturn ValueReturns pos of string, or -1 if not found

Returns:

      typing.Any:Pos at which to start search, current pos assumed if not specifiedReturn ValueReturns pos of string, or -1 if not found

        
         """
         pass


      def flush(self,offset:'typing.Any'=0,size:'typing.Any'=0) -> 'None':
         """
         Flushes memory buffer to disk

Args:

      offset(typing.Any):Position in buffer at which to flush
      size(typing.Any):Number of bytes to flush, 0 to flush remainder of buffer past the offset

Returns:

      None
        
         """
         pass


      def move(self,dest:'typing.Any',src:'typing.Any',count:'typing.Any') -> 'None':
         """
         Moves data from one place in buffer to another

Args:

      dest(typing.Any):Destination position in buffer
      src(typing.Any):Source position in buffer
      count(typing.Any):Number of bytes to move

Returns:

      None
        
         """
         pass


      def read(self,num_bytes:'typing.Any') -> 'typing.Any':
         """
         Returns specified number of bytes from buffer, and advances current position

Args:

      num_bytes(typing.Any):Number of bytes to read

Returns:

      typing.Any
        
         """
         pass


      def read_byte(self,) -> 'typing.Any':
         """
         Reads a single character from current pos

Args:



Returns:

      typing.Any
        
         """
         pass


      def read_line(self,) -> 'typing.Any':
         """
         Reads data from current pos up to next EOL.

Args:



Returns:

      typing.Any
        
         """
         pass


      def resize(self,MaximumSize:'typing.Any',FileOffset:'typing.Any'=0,NumberOfBytesToMap:'typing.Any'=0) -> 'None':
         """
         Resizes the file mapping and view.

Args:

      MaximumSize(typing.Any):New size for file mapping. Use a multiple of system page size (see win32api::GetSystemInfo)
      FileOffset(typing.Any):Offset into file mapping.  Must be multiple of allocation granularity.
      NumberOfBytesToMap(typing.Any):New view size.  Specify a multiple of system page size.CommentsIf MaximumSize is 0, only the mapped view will be affected.Accepts keyword args.

Returns:

      None
        
         """
         pass


      def seek(self,dist:'typing.Any',how:'typing.Any'=0) -> 'None':
         """
         Changes current position

Args:

      dist(typing.Any):Distance to seek
      how(typing.Any):Pos from which to seekhowmeaning0Seek from start of buffer1Seek from current position2Seek backwards from end of buffer

Returns:

      None
        
         """
         pass


      def size(self,) -> 'typing.Any':
         """
         Returns size of current view

Args:



Returns:

      typing.Any
        
         """
         pass


      def tell(self,) -> 'typing.Any':
         """
         Returns current position in buffer

Args:



Returns:

      typing.Any
        
         """
         pass


      def write(self,data:'typing.Any') -> 'None':
         """
         Places data at current pos in buffer.

Args:

      data(typing.Any):Data to be written

Returns:

      None
        
         """
         pass


      def write_byte(self,char:'typing.Any') -> 'None':
         """
         Writes a single character of data

Args:

      char(typing.Any):Single byte to be placed in buffer

Returns:

      None
        
         """
         pass


class RASDIALEXTENSIONS(object):
      """An object that describes a Win32 RASDIALEXTENSIONS structure 

TRUE*/)"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def dwfOptions(self)->'int':
         """(fOptions may also be used)"""
         pass


      @property
      def hwndParent(self)->'int':
         """"""
         pass


      @property
      def reserved(self)->'int':
         """"""
         pass


      @property
      def reserved1(self)->'int':
         """"""
         pass


      @property
      def RasEapInfo(self)->'typing.Any':
         """"""
         pass


class RASDIALPARAMS(object):
      """A tuple that describes a Win32 RASDIALPARAMS structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class SC_ACTION(object):
      """Tuple of 2 ints (Type,Delay) used to represent an SC_ACTION structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Type(self)->'typing.Any':
         """One of SC_ACTION_NONE, SC_ACTION_REBOOT, SC_ACTION_RESTART, SC_ACTION_RUN_COMMAND"""
         pass


      @property
      def Delay(self)->'typing.Any':
         """Time delay before specified action is taken (in milliseconds)"""
         pass


class SERVICE_FAILURE_ACTIONS(object):
      """A dictionary representing a SERVICE_FAILURE_ACTIONS structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ResetPeriod(self)->'typing.Any':
         """Indicates how many seconds to wait to reset the failure count, can be INFINITE"""
         pass


      @property
      def RebootMsg(self)->'typing.Union[str, typing.Any]':
         """Message displayed when reboot action is taken"""
         pass


      @property
      def Command(self)->'typing.Union[str, typing.Any]':
         """Command line to execute for SC_ACTION_RUN_COMMAND"""
         pass


      @property
      def Actions(self)->'typing.Any':
         """A tuple of SC_ACTION tuples"""
         pass


class SERVICE_STATUS(object):
      """A Win32 service status object is represented by a tuple:"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class TRACKMOUSEEVENT(object):
      """A tuple of (dwFlags, hwndTrack, dwHoverTime)"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class ULARGE_INTEGER(object):
      """A Python object used wherever a COM ULARGE_INTEGER is used."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class WIN32_FIND_DATA(object):
      """A tuple representing a WIN32_FIND_DATA structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class com_error(object):
      """An exception raised when a COM exception occurs."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class connection(object):
      """An object representing an ODBC connection"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def setautocommit(self,c:'typing.Any') -> 'None':
         """
         Sets the autocommit mode.

Args:

      c(typing.Any):The boolean autocommit mode.

Returns:

      None
        
         """
         pass


      def commit(self,) -> 'None':
         """
         Commits a transaction.

Args:



Returns:

      None
        
         """
         pass


      def rollback(self,) -> 'None':
         """
         Rollsback a transaction.

Args:



Returns:

      None
        
         """
         pass


      def cursor(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def close(self,) -> 'None':
         """
         Closes the connection.

Args:



Returns:

      None
        
         """
         pass


class cursor(object):
      """An object representing an ODBC cursor."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def close(self,) -> 'None':
         """
         Closes the cursor

Args:



Returns:

      None
        
         """
         pass


      def execute(self,sql:'str',arg:'typing.Any') -> 'typing.Any':
         """
         Execute some SQL

Args:

      sql(str):The SQL to execute
      arg(typing.Any):Input variables.

Returns:

      typing.Any
        
         """
         pass


      def fetchone(self,) -> 'typing.Any':
         """
         Fetch one row of data

Args:



Returns:

      typing.Any
        
         """
         pass


      def fetchmany(self,) -> 'typing.List[typing.Any]':
         """
         Fetch many rows of data

Args:



Returns:

      typing.List[typing.Any]
        
         """
         pass


      def fetchall(self,) -> 'typing.List[typing.Any]':
         """
         Fetch all rows of data

Args:



Returns:

      typing.List[typing.Any]
        
         """
         pass


      def setinputsizes(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def setoutputsize(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


class error(object):
      """An exception raised when a win32 error occurs"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class COMPONENT(object):
      """A dictionary containing data to fill a COMPPOS struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ID(self)->'typing.Any':
         """Id of component, ignored when adding a new component"""
         pass


      @property
      def ComponentType(self)->'typing.Any':
         """One of shellcon.COMP_TYPE_* values"""
         pass


      @property
      def Checked(self)->'typing.Any':
         """True indicates item is currently displayed"""
         pass


      @property
      def fDirty(self)->'typing.Any':
         """Indicates if unsaved changes exist"""
         pass


      @property
      def NoScroll(self)->'typing.Any':
         """True disables scrolling"""
         pass


      @property
      def Pos(self)->'typing.Any':
         """COMPPOS dictionary determining window size and placement"""
         pass


      @property
      def FriendlyName(self)->'typing.Any':
         """String of at most MAX_PATH-1 characters, truncated if longer"""
         pass


      @property
      def Source(self)->'typing.Any':
         """String of at most INTERNET_MAX_URL_LENGTH-1 characters"""
         pass


      @property
      def SubscribedURL(self)->'typing.Any':
         """String of at most INTERNET_MAX_URL_LENGTH-1 characters"""
         pass


      @property
      def CurItemState(self)->'typing.Any':
         """One of shellcon.IS_* flags"""
         pass


      @property
      def Original(self)->'typing.Any':
         """COMPSTATEINFO dictionary"""
         pass


      @property
      def Restored(self)->'typing.Any':
         """COMPSTATEINFO dictionary"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure, ignored on input"""
         pass


class COMPONENTSOPT(object):
      """A dictionary containing data to fill a COMPONENTSOPT struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def EnableComponents(self)->'typing.Any':
         """True if components are enabled"""
         pass


      @property
      def ActiveDesktop(self)->'typing.Any':
         """True if Active Desktop is enabled"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure, ignored on input"""
         pass


class COMPPOS(object):
      """A dictionary containing data to fill a COMPPOS struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Left(self)->'typing.Any':
         """"""
         pass


      @property
      def Top(self)->'typing.Any':
         """"""
         pass


      @property
      def Width(self)->'typing.Any':
         """"""
         pass


      @property
      def Height(self)->'typing.Any':
         """"""
         pass


      @property
      def Index(self)->'typing.Any':
         """"""
         pass


      @property
      def CanResize(self)->'typing.Any':
         """"""
         pass


      @property
      def CanResizeX(self)->'typing.Any':
         """"""
         pass


      @property
      def CanResizeY(self)->'typing.Any':
         """"""
         pass


      @property
      def PreferredLeftPercent(self)->'typing.Any':
         """"""
         pass


      @property
      def PreferredTopPercent(self)->'typing.Any':
         """"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure, ignored on input"""
         pass


class COMPSTATEINFO(object):
      """A dictionary containing data to fill a COMPSTATEINFO struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Left(self)->'typing.Any':
         """Specified as screen coordinates"""
         pass


      @property
      def Top(self)->'typing.Any':
         """Specified as screen coordinates"""
         pass


      @property
      def Width(self)->'typing.Any':
         """Measured in pixels"""
         pass


      @property
      def Height(self)->'typing.Any':
         """Measured in pixels"""
         pass


      @property
      def dwItemState(self)->'typing.Any':
         """One of IS_NORMAL, IS_FULLSCREEN  IS_SPLIT"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure, ignored on input"""
         pass


class DEFCONTENTMENU(object):
      """A tuple representing a DEFCONTEXTMENU structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class ELEMDESC(object):
      """An ELEMDESC is respresented as a tuple of"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class EXP_DARWIN_LINK(object):
      """Dictionary containing information for a EXP_DARWIN_LINK struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Signature(self)->'typing.Any':
         """The type of data block, one of shellcon.*_SIG values"""
         pass


      @property
      def DarwinID(self)->'typing.Any':
         """The Windows Installer id for the link"""
         pass


      @property
      def wDarwinID(self)->'typing.Any':
         """The installer id as Unicode"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure, ignored on input"""
         pass


class EXP_SPECIAL_FOLDER(object):
      """Dictionary containing information for a EXP_SPECIAL_FOLDER struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Signature(self)->'typing.Any':
         """The type of data block, one of shellcon.*_SIG values"""
         pass


      @property
      def idSpecialFolder(self)->'typing.Any':
         """The special folder id of the target (shellcon.CSIDL_*)"""
         pass


      @property
      def Offset(self)->'typing.Any':
         """Offset into the link's PIDL"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure, ignored on input"""
         pass


class EXP_SZ_LINK(object):
      """Dictionary containing information for an EXP_SZ_LINK or EXP_SZ_ICON struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Signature(self)->'typing.Any':
         """The type of data block, one of shellcon.*_SIG values"""
         pass


      @property
      def Target(self)->'typing.Any':
         """The link's target or icon location"""
         pass


      @property
      def wTarget(self)->'typing.Any':
         """The target in Unicode form"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure, ignored on input"""
         pass


class FUNCDESC(object):
      """A FUNCDESC object represents a COM TYPEATTR structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def memid(self)->'int':
         """"""
         pass


      @property
      def scodeArray(self)->'typing.Tuple[typing.Any, ...]':
         """"""
         pass


      @property
      def args(self)->'typing.Tuple[ELEMDESC, ...]':
         """"""
         pass


      @property
      def funckind(self)->'typing.Any':
         """"""
         pass


      @property
      def invkind(self)->'typing.Any':
         """"""
         pass


      @property
      def callconv(self)->'typing.Any':
         """"""
         pass


      @property
      def cParamsOpt(self)->'typing.Any':
         """"""
         pass


      @property
      def oVft(self)->'typing.Any':
         """"""
         pass


      @property
      def rettype(self)->'ELEMDESC':
         """"""
         pass


      @property
      def wFuncFlags(self)->'typing.Any':
         """"""
         pass


class IDLDESC(object):
      """An IDLDESC is respresented as"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class MAPIINIT_0(object):
      """A MAPIINIT_0 is represented as a tuple of:"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class NT_CONSOLE_PROPS(object):
      """Dictionary containing information for a NT_CONSOLE_PROPS struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Signature(self)->'typing.Any':
         """The type of data block, one of shellcon.*_SIG values"""
         pass


      @property
      def FillAttribute(self)->'typing.Any':
         """Character attributes for fill operations"""
         pass


      @property
      def PopupFillAttribute(self)->'typing.Any':
         """Fill attributes for popups"""
         pass


      @property
      def ScreenBufferSize(self)->'typing.Tuple[typing.Any, typing.Any]':
         """Size of console screen buffer, in character cells"""
         pass


      @property
      def WindowSize(self)->'typing.Tuple[typing.Any, typing.Any]':
         """Size of console window in character cells"""
         pass


      @property
      def WindowOrigin(self)->'typing.Tuple[typing.Any, typing.Any]':
         """Window position, in screen coordinates"""
         pass


      @property
      def nFont(self)->'typing.Any':
         """Number of font to be displayed.  See win32console::GetNumberOfConsoleFonts"""
         pass


      @property
      def InputBufferSize(self)->'typing.Any':
         """Size of console's input buffer"""
         pass


      @property
      def FontSize(self)->'typing.Tuple[typing.Any, typing.Any]':
         """Size of font"""
         pass


      @property
      def FontFamily(self)->'typing.Any':
         """Font family"""
         pass


      @property
      def FontWeight(self)->'typing.Any':
         """Controls thickness of displayed font"""
         pass


      @property
      def FaceName(self)->'typing.Any':
         """Name of font face, 31 characters at most"""
         pass


      @property
      def CursorSize(self)->'typing.Any':
         """Relative size of cursor, expressed as percent of character size"""
         pass


      @property
      def FullScreen(self)->'typing.Any':
         """Causes console to run in full screen mode"""
         pass


      @property
      def QuickEdit(self)->'typing.Any':
         """"""
         pass


      @property
      def InsertMode(self)->'typing.Any':
         """"""
         pass


      @property
      def AutoPosition(self)->'typing.Any':
         """Lets system determine window placement"""
         pass


      @property
      def HistoryBufferSize(self)->'typing.Any':
         """Size of command line history buffer"""
         pass


      @property
      def NumberOfHistoryBuffers(self)->'typing.Any':
         """"""
         pass


      @property
      def HistoryNoDup(self)->'typing.Any':
         """"""
         pass


      @property
      def ColorTable(self)->'typing.Any':
         """Tuple of 16 ints containing console's color attributes"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure, ignored on input"""
         pass


class NT_FE_CONSOLE_PROPS(object):
      """Dictionary containing information for a NT_FE_CONSOLE_PROPS struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Signature(self)->'typing.Any':
         """The type of data block, one of shellcon.*_SIG values"""
         pass


      @property
      def CodePage(self)->'typing.Any':
         """The codepage to be used for console text"""
         pass


      @property
      def Size(self)->'typing.Any':
         """Size of structure, ignored on input"""
         pass


class PROPSPEC(object):
      """Identifies a property.  Can be either an int property id, or a str/unicode property name."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyADSVALUE(object):
      """A tuple:"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyADS_ATTR_INFO(object):
      """Represents a ADS_ATTR_INFO structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def AttrName(self)->'typing.Any':
         """The name"""
         pass


      @property
      def ControlCode(self)->'int':
         """"""
         pass


      @property
      def ADsType(self)->'int':
         """"""
         pass


      @property
      def Values(self)->'typing.List[typing.Any]':
         """"""
         pass


class PyADS_OBJECT_INFO(object):
      """Represents a ADS_OBJECT_INFO structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def RDN(self)->'typing.Any':
         """The name"""
         pass


      @property
      def ObjectDN(self)->'typing.Any':
         """"""
         pass


      @property
      def ParentDN(self)->'typing.Any':
         """"""
         pass


      @property
      def ClassName(self)->'typing.Any':
         """"""
         pass


class PyADS_SEARCHPREF_INFO(object):
      """A tuple of:"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyBIND_OPTS(object):
      """Dictionary representation of a BIND_OPTS struct 

May eventually be extended to include BIND_OPTS2 members"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Flags(self)->'typing.Any':
         """Value from BIND_FLAGS enum: BIND_MAYBOTHERUSER, BIND_JUSTTESTEXISTENCE or 0"""
         pass


      @property
      def Mode(self)->'typing.Any':
         """Combination of storagecon.STGM_* values"""
         pass


      @property
      def TickCountDeadline(self)->'typing.Any':
         """Operation timeout in milliseconds"""
         pass


      @property
      def cbStruct(self)->'typing.Any':
         """Size of struct, ignored on input"""
         pass


class PyCMINVOKECOMMANDINFO(object):
      """A tuple of parameters to be converted to a CMINVOKECOMMANDINFO struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyDSBCAPS(object):
      """A Python object, representing a DSBCAPS structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def dwFlags(self)->'int':
         """Flags that specify buffer-object capabilities.FlagDescriptionDSBCAPS_PRIMARYBUFFERIndicates that the buffer is a primary sound buffer. If this value is not specified, a secondary sound buffer will be created.DSBCAPS_STATICIndicates that the buffer will be used for static sound data. Typically, these buffers are loaded once and played many times. These buffers are candidates for hardware memory.DSBCAPS_LOCHARDWAREThe buffer is in hardware memory and uses hardware mixing.DSBCAPS_LOCSOFTWAREThe buffer is in software memory and uses software mixing.DSBCAPS_CTRL3DThe buffer is either a primary buffer or a secondary buffer that uses 3-D control. To create a primary buffer, the dwFlags member of the DSBUFFERDESC structure should include the DSBCAPS_PRIMARYBUFFER flag.DSBCAPS_CTRLFREQUENCYThe buffer must have frequency control capability.DSBCAPS_CTRLPANThe buffer must have pan control capability.DSBCAPS_CTRLVOLUMEThe buffer must have volume control capability.DSBCAPS_CTRLPOSITIONNOTIFYThe buffer must have control position notify capability.DSBCAPS_STICKYFOCUSChanges the focus behavior of the sound buffer. This flag can be specified in an IDirectSound::CreateSoundBuffer call. With this flag set, an application using DirectSound can continue to play its sticky focus buffers if the user switches to another application not using DirectSound. In this situation, the application's normal buffers are muted, but the sticky focus buffers are still audible. This is useful for nongame applications, such as movie playback (DirectShow), when the user wants to hear the soundtrack while typing in Microsoft Word or Microsoft® Excel, for example. However, if the user switches to another DirectSound application, all sound buffers, both normal and sticky focus, in the previous application are muted.DSBCAPS_GLOBALFOCUSThe buffer is a global sound buffer. With this flag set, an application using DirectSound can continue to play its buffers if the user switches focus to another application, even if the new application uses DirectSound. The one exception is if you switch focus to a DirectSound application that uses the DSSCL_EXCLUSIVE or DSSCL_WRITEPRIMARY flag for its cooperative level. In this case, the global sounds from other applications will not be audible.DSBCAPS_GETCURRENTPOSITION2Indicates that IDirectSoundBuffer::GetCurrentPosition should use the new behavior of the play cursor. In DirectSound in DirectX 1, the play cursor was significantly ahead of the actual playing sound on emulated sound cards; it was directly behind the write cursor. Now, if the DSBCAPS_GETCURRENTPOSITION2 flag is specified, the application can get a more accurate play position. If this flag is not specified, the old behavior is preserved for compatibility. Note that this flag affects only emulated sound cards; if a DirectSound driver is present, the play cursor is accurate for DirectSound in all versions of DirectX.DSBCAPS_MUTE3DATMAXDISTANCEThe sound is reduced to silence at the maximum distance. The buffer will stop playing when the maximum distance is exceeded, so that processor time is not wasted."""
         pass


      @property
      def nChannels(self)->'int':
         """Size of the buffer, in bytes."""
         pass


      @property
      def dwUnlockTransferRate(self)->'int':
         """Specifies the rate, in kilobytes per second, at which data is transferred to the buffer memory when IDirectSoundBuffer::Unlock is called. High-performance applications can use this value to determine the time required for IDirectSoundBuffer::Unlock to execute. For software buffers located in system memory, the rate will be very high because no processing is required. For hardware buffers, the rate might be slower because the buffer might have to be downloaded to the sound card, which might have a limited transfer rate."""
         pass


      @property
      def nAvgBytesPerSec(self)->'int':
         """Specifies whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle. Sentinel"""
         pass


class PyDSBUFFERDESC(object):
      """A Python object, representing a DSBUFFERDESC structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def dwFlags(self)->'int':
         """Identifies the capabilities to include when creating a new DirectSoundBuffer object. Specify one or more of the following:FlagDescriptionDSBCAPS_PRIMARYBUFFERIndicates that the buffer is a primary sound buffer. If this value is not specified, a secondary sound buffer will be created.DSBCAPS_STATICIndicates that the buffer will be used for static sound data. Typically, these buffers are loaded once and played many times. These buffers are candidates for hardware memory.DSBCAPS_LOCHARDWAREThe buffer is in hardware memory and uses hardware mixing.DSBCAPS_LOCSOFTWAREThe buffer is in software memory and uses software mixing.DSBCAPS_CTRL3DThe buffer is either a primary buffer or a secondary buffer that uses 3-D control. To create a primary buffer, the dwFlags member of the DSBUFFERDESC structure should include the DSBCAPS_PRIMARYBUFFER flag.DSBCAPS_CTRLFREQUENCYThe buffer must have frequency control capability.DSBCAPS_CTRLPANThe buffer must have pan control capability.DSBCAPS_CTRLVOLUMEThe buffer must have volume control capability.DSBCAPS_CTRLPOSITIONNOTIFYThe buffer must have control position notify capability.DSBCAPS_STICKYFOCUSChanges the focus behavior of the sound buffer. This flag can be specified in an IDirectSound::CreateSoundBuffer call. With this flag set, an application using DirectSound can continue to play its sticky focus buffers if the user switches to another application not using DirectSound. In this situation, the application's normal buffers are muted, but the sticky focus buffers are still audible. This is useful for nongame applications, such as movie playback (DirectShow), when the user wants to hear the soundtrack while typing in Microsoft Word or Microsoft® Excel, for example. However, if the user switches to another DirectSound application, all sound buffers, both normal and sticky focus, in the previous application are muted.DSBCAPS_GLOBALFOCUSThe buffer is a global sound buffer. With this flag set, an application using DirectSound can continue to play its buffers if the user switches focus to another application, even if the new application uses DirectSound. The one exception is if you switch focus to a DirectSound application that uses the DSSCL_EXCLUSIVE or DSSCL_WRITEPRIMARY flag for its cooperative level. In this case, the global sounds from other applications will not be audible.DSBCAPS_GETCURRENTPOSITION2Indicates that IDirectSoundBuffer::GetCurrentPosition should use the new behavior of the play cursor. In DirectSound in DirectX 1, the play cursor was significantly ahead of the actual playing sound on emulated sound cards; it was directly behind the write cursor. Now, if the DSBCAPS_GETCURRENTPOSITION2 flag is specified, the application can get a more accurate play position. If this flag is not specified, the old behavior is preserved for compatibility. Note that this flag affects only emulated sound cards; if a DirectSound driver is present, the play cursor is accurate for DirectSound in all versions of DirectX.DSBCAPS_MUTE3DATMAXDISTANCEThe sound is reduced to silence at the maximum distance. The buffer will stop playing when the maximum distance is exceeded, so that processor time is not wasted."""
         pass


      @property
      def dwBufferBytes(self)->'int':
         """Size of the new buffer, in bytes. This value must be 0 when creating primary buffers. For secondary buffers, the minimum and maximum sizes allowed are specified by DSBSIZE_MIN and DSBSIZE_MAX."""
         pass


      @property
      def lpwfxFormat(self)->'typing.Any':
         """Structure specifying the waveform format for the buffer. This value must be None for primary buffers. The application can use IDirectSoundBuffer::SetFormat to set the format of the primary buffer. Sentinel"""
         pass


class PyDSCAPS(object):
      """A Python object, representing a DSCAPS structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def dwFlags(self)->'int':
         """Specifies device capabilities. Can be one or more of the following:FlagDescriptionDSCAPS_PRIMARYMONOThe device supports monophonic primary buffers.DSCAPS_PRIMARYSTEREOThe device supports stereo primary buffers.DSCAPS_PRIMARY8BITThe device supports hardware-mixed secondary buffers with 8-bit samples.DSCAPS_PRIMARY16BITThe device supports primary sound buffers with 16-bit samples.DSCAPS_CONTINUOUSRATEThe device supports all sample rates between the dwMinSecondarySampleRate and dwMaxSecondarySampleRate member values. Typically, this means that the actual output rate will be within +/- 10 hertz (Hz) of the requested frequency.DSCAPS_EMULDRIVERThe device does not have a DirectSound driver installed, so it is being emulated through the waveform-audio functions. Performance degradation should be expected.DSCAPS_CERTIFIEDThis driver has been tested and certified by Microsoft.DSCAPS_SECONDARYMONOThe device supports hardware-mixed monophonic secondary buffers.DSCAPS_SECONDARYSTEREOThe device supports hardware-mixed stereo secondary buffers.DSCAPS_SECONDARY8BITThe device supports hardware-mixed secondary buffers with 8-bit samples.DSCAPS_SECONDARY16BITThe device supports hardware-mixed secondary sound buffers with 16-bit samples."""
         pass


      @property
      def dwMinSecondarySampleRate(self)->'int':
         """Minimum sample rate supported by this device's hardware secondary sound buffers."""
         pass


      @property
      def dwMaxSecondarySampleRate(self)->'int':
         """Maximum sample rate supported by this device's hardware secondary sound buffers."""
         pass


      @property
      def dwPrimaryBuffers(self)->'int':
         """Number of primary buffers supported. This value will always be 1."""
         pass


      @property
      def dwMaxHwMixingAllBuffers(self)->'int':
         """Specifies the total number of buffers that can be mixed in hardware. This member can be less than the sum of dwMaxHwMixingStaticBuffers and dwMaxHwMixingStreamingBuffers. Resource tradeoffs frequently occur."""
         pass


      @property
      def dwMaxHwMixingStaticBuffers(self)->'int':
         """Specifies the maximum number of static sound buffers."""
         pass


      @property
      def dwMaxHwMixingStreamingBuffers(self)->'int':
         """Specifies the maximum number of streaming sound buffers."""
         pass


      @property
      def dwFreeHwMixingAllBuffers(self)->'int':
         """Description of the free hardware mixing capabilities of the device. An application can use this value to determine whether hardware resources are available for allocation to a secondary sound buffer. Also, by comparing these values to the members that specify maximum mixing capabilities, the resources that are already allocated can be determined."""
         pass


      @property
      def dwFreeHwMixingStaticBuffers(self)->'int':
         """Description of the free hardware mixing capabilities of the device. An application can use this value to determine whether hardware resources are available for allocation to a secondary sound buffer. Also, by comparing these values to the members that specify maximum mixing capabilities, the resources that are already allocated can be determined."""
         pass


      @property
      def dwFreeHwMixingStreamingBuffers(self)->'int':
         """Description of the free hardware mixing capabilities of the device. An application can use this value to determine whether hardware resources are available for allocation to a secondary sound buffer. Also, by comparing these values to the members that specify maximum mixing capabilities, the resources that are already allocated can be determined."""
         pass


      @property
      def dwMaxHw3DAllBuffers(self)->'int':
         """Description of the hardware 3-D positional capabilities of the device."""
         pass


      @property
      def dwMaxHw3DStaticBuffers(self)->'int':
         """Description of the hardware 3-D positional capabilities of the device."""
         pass


      @property
      def dwMaxHw3DStreamingBuffers(self)->'int':
         """Description of the hardware 3-D positional capabilities of the device."""
         pass


      @property
      def dwFreeHw3DAllBuffers(self)->'int':
         """Description of the free, or unallocated, hardware 3-D positional capabilities of the device."""
         pass


      @property
      def dwFreeHw3DStaticBuffers(self)->'int':
         """Description of the free, or unallocated, hardware 3-D positional capabilities of the device."""
         pass


      @property
      def dwFreeHw3DStreamingBuffers(self)->'int':
         """Description of the free, or unallocated, hardware 3-D positional capabilities of the device."""
         pass


      @property
      def dwTotalHwMemBytes(self)->'int':
         """Size, in bytes, of the amount of memory on the sound card that stores static sound buffers."""
         pass


      @property
      def dwFreeHwMemBytes(self)->'int':
         """Size, in bytes, of the free memory on the sound card."""
         pass


      @property
      def dwMaxContigFreeHwMemBytes(self)->'int':
         """Size, in bytes, of the largest contiguous block of free memory on the sound card."""
         pass


      @property
      def dwUnlockTransferRateHwBuffers(self)->'int':
         """Description of the rate, in kilobytes per second, at which data can be transferred to hardware static sound buffers. This and the number of bytes transferred determines the duration of a call to the IDirectSoundBuffer::Update method."""
         pass


      @property
      def dwPlayCpuOverheadSwBuffers(self)->'int':
         """Description of the processing overhead, as a percentage of the central processing unit, needed to mix software buffers (those located in main system memory). This varies according to the bus type, the processor type, and the clock speed. The unlock transfer rate for software buffers is 0 because the data need not be transferred anywhere. Similarly, the play processing overhead for hardware buffers is 0 because the mixing is done by the sound device."""
         pass


class PyDSCBCAPS(object):
      """A Python object, representing a DSCBCAPS structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def dwFlags(self)->'int':
         """Specifies device capabilities. Can be 0 or DSCBCAPS_EMULDRIVER (indicates that no DirectSound Device is available and standard wave audio functions are being used)."""
         pass


      @property
      def dwBufferBytes(self)->'int':
         """The size, in bytes, of the capture buffer."""
         pass


class PyDSCBUFFERDESC(object):
      """A Python object, representing a DSCBUFFERDESC structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def dwFlags(self)->'int':
         """Identifies the capabilities to include when creating a new DirectSoundBuffer object. Can be zero or the following flag:FlagDescriptionDSCBCAPS_WAVEMAPPEDThe Win32 wave mapper will be used for formats not supported by the device."""
         pass


      @property
      def dwBufferBytes(self)->'int':
         """Size of the new buffer, in bytes. This value must be 0 when creating primary buffers. For secondary buffers, the minimum and maximum sizes allowed are specified by DSBSIZE_MIN and DSBSIZE_MAX."""
         pass


      @property
      def lpwfxFormat(self)->'typing.Any':
         """Structure specifying the waveform format for the buffer. This value must be None for primary buffers. The application can use IDirectSoundBuffer::SetFormat to set the format of the primary buffer. Sentinel"""
         pass


class PyDSCCAPS(object):
      """A Python object, representing a DSCCAPS structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def dwFlags(self)->'int':
         """Specifies device capabilities. Can be zero or the following flag:FlagDescriptionDSCCAPS_EMULDRIVERIndicates that no DirectSound Device is available and standard wave audio functions are being used."""
         pass


      @property
      def dwFormats(self)->'int':
         """Bitset of supported WAVE_FORMAT formats."""
         pass


      @property
      def dwChannels(self)->'int':
         """Number of channels supported by the device."""
         pass


class PyDSOP_FILTER_FLAGS(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def uplevel(self)->'PyDSOP_UPLEVEL_FILTER_FLAGS':
         """"""
         pass


      @property
      def downlevel(self)->'typing.Any':
         """"""
         pass


class PyDSOP_SCOPE_INIT_INFO(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def type(self)->'typing.Any':
         """"""
         pass


      @property
      def scope(self)->'typing.Any':
         """"""
         pass


      @property
      def hr(self)->'typing.Any':
         """"""
         pass


      @property
      def dcName(self)->'str':
         """"""
         pass


      @property
      def filterFlags(self)->'PyDSOP_FILTER_FLAGS':
         """"""
         pass


class PyDSOP_SCOPE_INIT_INFOs(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyDSOP_UPLEVEL_FILTER_FLAGS(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def bothModes(self)->'typing.Any':
         """"""
         pass


      @property
      def mixedModeOnly(self)->'typing.Any':
         """"""
         pass


      @property
      def nativeModeOnly(self)->'typing.Any':
         """"""
         pass


class PyFORMATETC(object):
      """Tuple representing a FORMATETC struct describing an OLE data format"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyGFileOperationProgressSink(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def StartOperations(self,) -> 'None':
         """
         Called as operation begins, before any modifications are done

Args:



Returns:

      None
        
         """
         pass


      def FinishOperations(self,Result:'typing.Any') -> 'None':
         """
         Called after all actions have been performed

Args:

      Result(typing.Any):HRESULT of last operation performed

Returns:

      None
        
         """
         pass


      def PreRenameItem(self,Flags:'typing.Any',Item:'PyIShellItem',NewName:'typing.Any') -> 'None':
         """
         Called before each file rename

Args:

      Flags(typing.Any):Flags specifying copy behaviour, combination of shellcon.TSF_* flags
      Item(PyIShellItem):Shell interface of the copied item
      NewName(typing.Any):New display name of the item

Returns:

      None
        
         """
         pass


      def PostRenameItem(self,Flags:'typing.Any',Item:'PyIShellItem',NewName:'typing.Any',hrRename:'typing.Any',NewlyCreated:'PyIShellItem') -> 'None':
         """
         Called after each file rename

Args:

      Flags(typing.Any):Flags specifying rename behaviour, combination of shellcon.TSF_* flags
      Item(PyIShellItem):Shell interface of item before rename
      NewName(typing.Any):The new name of the item, may be mangled to resolve filename conflicts
      hrRename(typing.Any):HRESULT of the rename operation
      NewlyCreated(PyIShellItem):Shell interface of the item after rename

Returns:

      None
        
         """
         pass


      def PreMoveItem(self,Flags:'typing.Any',Item:'PyIShellItem',DestinationFolder:'PyIShellItem',NewName:'typing.Any') -> 'None':
         """
         Called before each move operation

Args:

      Flags(typing.Any):Flags specifying move behaviour, combination of shellcon.TSF_* flags
      Item(PyIShellItem):The item to be moved
      DestinationFolder(PyIShellItem):The folder into which it will be moved
      NewName(typing.Any):Name of moved item, may be None if not to be changed

Returns:

      None
        
         """
         pass


      def PostMoveItem(self,Flags:'typing.Any',Item:'PyIShellItem',DestinationFolder:'PyIShellItem',NewName:'typing.Any',hrMove:'typing.Any',NewlyCreated:'PyIShellItem') -> 'None':
         """
         Called after each move operation

Args:

      Flags(typing.Any):Flags specifying move behaviour, combination of shellcon.TSF_* flags
      Item(PyIShellItem):Interface of the item before it was moved
      DestinationFolder(PyIShellItem):The folder into which it was moved
      NewName(typing.Any):Name of item in its new location, may be mangled in case of conflict
      hrMove(typing.Any):HRESULT of the move operation
      NewlyCreated(PyIShellItem):Shell interface of the item in its new location

Returns:

      None
        
         """
         pass


      def PreCopyItem(self,Flags:'typing.Any',Item:'PyIShellItem',DestinationFolder:'PyIShellItem',NewName:'typing.Any') -> 'None':
         """
         Called before each copy operation

Args:

      Flags(typing.Any):Flags specifying copy behaviour, combination of shellcon.TSF_* flags
      Item(PyIShellItem):The item to be copied
      DestinationFolder(PyIShellItem):Folder into which it will be copied
      NewName(typing.Any):Name to be given to the copy, will be None if keeping original name

Returns:

      None
        
         """
         pass


      def PostCopyItem(self,Flags:'typing.Any',Item:'PyIShellItem',DestinationFolder:'PyIShellItem',NewName:'typing.Any',hrCopy:'typing.Any',NewlyCreated:'PyIShellItem') -> 'None':
         """
         Called after each copy operation

Args:

      Flags(typing.Any):Flags specifying copy behaviour, combination of shellcon.TSF_* flags
      Item(PyIShellItem):The original item
      DestinationFolder(PyIShellItem):Folder into which it was copied
      NewName(typing.Any):Name of item after copy, may be mangled in case of name conflict
      hrCopy(typing.Any):HRESULT of the copy operation
      NewlyCreated(PyIShellItem):Shell interface of the copy

Returns:

      None
        
         """
         pass


      def PreDeleteItem(self,Flags:'typing.Any',Item:'PyIShellItem') -> 'None':
         """
         Called before each delete operation

Args:

      Flags(typing.Any):Flags specifying delete behaviour, combination of shellcon.TSF_* flags
      Item(PyIShellItem):Item to be deleted

Returns:

      None
        
         """
         pass


      def PostDeleteItem(self,Flags:'typing.Any',Item:'PyIShellItem',hrDelete:'typing.Any',NewlyCreated:'PyIShellItem') -> 'None':
         """
         Called after each delete operation

Args:

      Flags(typing.Any):Flags specifying delete behaviour, combination of shellcon.TSF_* flags
      Item(PyIShellItem):Item that was deleted
      hrDelete(typing.Any):HRESULT of the delete operation
      NewlyCreated(PyIShellItem):Item in the recycle bin, or None if deleted without recycling

Returns:

      None
        
         """
         pass


      def PreNewItem(self,Flags:'typing.Any',DestinationFolder:'PyIShellItem',NewName:'typing.Any') -> 'None':
         """
         Called before each new file is created

Args:

      Flags(typing.Any):Flags specifying creation behaviour, combination of shellcon.TSF_* flags
      DestinationFolder(PyIShellItem):Folder where item will be created
      NewName(typing.Any):Name of item to be created

Returns:

      None
        
         """
         pass


      def PostNewItem(self,Flags:'typing.Any',DestinationFolder:'PyIShellItem',NewName:'typing.Any',TemplateName:'typing.Any',FileAttributes:'typing.Any',hrNew:'typing.Any',NewItem:'PyIShellItem') -> 'None':
         """
         Called after each new file is created

Args:

      Flags(typing.Any):Flags specifying creation behaviour, combination of shellcon.TSF_* flags
      DestinationFolder(PyIShellItem):Folder in which item was created
      NewName(typing.Any):Name of created item, may be mangled if file name conflicts occurred
      TemplateName(typing.Any):Template file used to initialize new item
      FileAttributes(typing.Any):File attributes of new item
      hrNew(typing.Any):HRESULT of the create operation
      NewItem(PyIShellItem):Shell interface of created item

Returns:

      None
        
         """
         pass


      def UpdateProgress(self,WorkTotal:'typing.Any',WorkSoFar:'typing.Any') -> 'None':
         """
         Gives an estimate of total work completed

Args:

      WorkTotal(typing.Any):Undimensioned number representing total amount of work
      WorkSoFar(typing.Any):Undimensioned number representing amount already completed

Returns:

      None
        
         """
         pass


      def ResetTimer(self,) -> 'None':
         """
         Not implemented, according to MSDN

Args:



Returns:

      None
        
         """
         pass


      def PauseTimer(self,) -> 'None':
         """
         Not implemented, according to MSDN

Args:



Returns:

      None
        
         """
         pass


      def ResumeTimer(self,) -> 'None':
         """
         Not implemented, according to MSDN

Args:



Returns:

      None
        
         """
         pass


class PyGSecurityInformation(object):
      """Gateway wrapper for the implement-only ISecurityInformation interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetObjectInformation(self,) -> 'SI_OBJECT_INFO':
         """
         Returns information identifying the object 

whose security is to be editted, and which pages are to appear in the property sheet

Args:



Returns:

      SI_OBJECT_INFO:PyGSecurityInformation.GetObjectInformation
SI_OBJECT_INFO = GetObjectInformation()Returns information identifying the object 

whose security is to be editted, and which pages are to appear in the property sheet
Comments

Due to peculiarities of the underlying system calls, this method will only be called once, 

and subsequent calls will return the information obtained on the first call.  As a consequence, a new 

instance of the interface will need to be created for each object whose security is to be displayed.
Return ValueYour implementation of this method should return a SI_OBJECT_INFO tuple

        
         """
         pass


      def GetSecurity(self,RequestedInformation:'typing.Any',Default:'typing.Any') -> 'PySECURITY_DESCRIPTOR':
         """
         Retrieves the object's current security 

settings

Args:

      RequestedInformation(typing.Any):Combination of SECURITY_INFORMATION flags indicating which components of the object's security descriptor you should return
      Default(typing.Any):If true, return a default security descriptor rather than current security.  (invoked when 'Reset' button is clicked)

Returns:

      PySECURITY_DESCRIPTOR
        
         """
         pass


      def SetSecurity(self,SecurityInformation:'typing.Any',SecurityDescriptor:'PySECURITY_DESCRIPTOR') -> 'None':
         """
         Applies the modified security to the object

Args:

      SecurityInformation(typing.Any):SECURITY_INFORMATION flags specifying which types of security information are to be applied
      SecurityDescriptor(PySECURITY_DESCRIPTOR):The security information to be applied to the objectReturn ValueAny returned value is ignored

Returns:

      None:The security information to be applied to the objectReturn ValueAny returned value is ignored

        
         """
         pass


      def GetAccessRights(self,ObjectType:'PyIID',Flags:'typing.Any') -> 'typing.Tuple[SI_ACCESS, typing.Any]':
         """
         Retrieves permission that can be set

Args:

      ObjectType(PyIID):GUID representing type of object, may be None
      Flags(typing.Any):Indicates which page is requesting the access rights (SI_ADVANCED, SI_EDIT_AUDITS, SI_EDIT_PROPERTIES)Return ValueThis method should return a 2-tuple containing a sequence of SI_ACCESS tuples, and a zero-based index indicating which of them is the default

Returns:

      typing.Tuple[SI_ACCESS, typing.Any]:Indicates which page is requesting the access rights (SI_ADVANCED, SI_EDIT_AUDITS, 

SI_EDIT_PROPERTIES)Return ValueThis method should return a 2-tuple containing a sequence of SI_ACCESS tuples, 

and a zero-based index indicating which of them is the default

        
         """
         pass


      def MapGeneric(self,ObjectType:'PyIID',AceFlags:'typing.Any',Mask:'typing.Any') -> 'typing.Any':
         """
         Translates generic access rights to specific equivalents

Args:

      ObjectType(PyIID):Type of object that permissions apply to, None or GUID_NULL indicates object itself
      AceFlags(typing.Any):Flags from the ACE that contains the permissions
      Mask(typing.Any):Bitmask containing access rightsCommentsSee win32security::MapGenericMaskReturn ValueThis method should return the input bitmask will all generic rights mapped to specific rights

Returns:

      typing.Any:Bitmask containing access rightsComments

See win32security::MapGenericMask
Return ValueThis method should return the input bitmask will all generic rights mapped to specific rights

        
         """
         pass


      def GetInheritTypes(self,) -> 'typing.Tuple[SI_INHERIT_TYPE, ...]':
         """
         Requests types of inheritance that your 

implementation supports

Args:



Returns:

      typing.Tuple[SI_INHERIT_TYPE, ...]:PyGSecurityInformation.GetInheritTypes

(SI_INHERIT_TYPE,...) = GetInheritTypes()Requests types of inheritance that your 

implementation supports
Return ValueReturns a sequence of SI_INHERIT_TYPE tuples

        
         """
         pass


      def PropertySheetPageCallback(self,hwnd:'int',Msg:'typing.Any',Page:'typing.Any') -> 'None':
         """
         Called by each page as it is created and destroyed

Args:

      hwnd(typing.Any):Handle to the window for the page
      Msg(typing.Any):Flag indicating type of event, one of PSPCB_CREATE,PSPCB_RELEASE,PSPCB_SI_INITDIALOG
      Page(typing.Any):SI_PAGE_TYPE value indicating which page is making the call (ntsecuritycon.SI_PAGE_*)Return ValueAny returned value will be ignored

Returns:

      None:SI_PAGE_TYPE value indicating which page is making the call (ntsecuritycon.SI_PAGE_*)Return ValueAny returned value will be ignored

        
         """
         pass


class PyIADesktopP2(object):
      """An interface to the ActiveDesktop"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def UpdateAllDesktopSubscriptions(self,) -> 'None':
         """
         Updates webpage subscriptions on the desktop

Args:



Returns:

      None
        
         """
         pass


class PyIADs(object):
      """An object representing the IADs interface. 

In most cases you can achieve the same result via IDispatch - however, this 

interface allows you get get and set properties without the IDispatch 

overhead."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ADsPath(self)->'str':
         """"""
         pass


      @property
      def AdsPath(self)->'str':
         """Synonym for ADsPath"""
         pass


      @property
      def Class(self)->'str':
         """"""
         pass


      @property
      def GUID(self)->'str':
         """Like the IADs method, this returns a string rather than a GUID object."""
         pass


      @property
      def Name(self)->'str':
         """"""
         pass


      @property
      def Parent(self)->'str':
         """"""
         pass


      @property
      def Schema(self)->'str':
         """"""
         pass


      def GetInfo(self,) -> 'None':
         """
         Description of GetInfo.

Args:



Returns:

      None
        
         """
         pass


      def SetInfo(self,) -> 'None':
         """
         Description of SetInfo.

Args:



Returns:

      None
        
         """
         pass


      def Get(self,prop:'str') -> 'typing.Any':
         """
         Description of Get.

Args:

      prop(str):The name of the property to fetchReturn ValueThe result is a Python object converted from a COM variant.  It may be an array, or any types supported by COM variant.

Returns:

      typing.Any:The name of the property to fetchReturn ValueThe result is a Python object converted from a COM variant.  It 

may be an array, or any types supported by COM variant.

        
         """
         pass


      def Put(self,_property:'str',val:'typing.Any') -> 'None':
         """
         Description of Put.

Args:

      _property(str):The property name to set
      val(typing.Any):The value to set.

Returns:

      None
        
         """
         pass


      def get(self,prop:'str') -> 'typing.Any':
         """
         Description of Get.

Args:

      prop(str):The name of the property to fetchReturn ValueThe result is a Python object converted from a COM variant.  It may be an array, or any types supported by COM variant.

Returns:

      typing.Any:The name of the property to fetchReturn ValueThe result is a Python object converted from a COM variant.  It 

may be an array, or any types supported by COM variant.

        
         """
         pass


      def put(self,_property:'str',val:'typing.Any') -> 'None':
         """
         Description of Put.

Args:

      _property(str):The property name to set
      val(typing.Any):The value to set.

Returns:

      None
        
         """
         pass


class PyIADsContainer(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetObject(self,_class:'str',relativeName:'str') -> 'PyIDispatch':
         """
         None

Args:

      _class(str):Specifies the name of the object class as known in the underlying directory and identical to the one retrieved through the get_Class property method. If the class name is None, the provider returns the first item found in the container.
      relativeName(str):Specifies the name of the object as known in the underlying directory and identical to the one retrieved through the get_Name property method.

Returns:

      PyIDispatch
        
         """
         pass


      def get_Count(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def get_Filter(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_Filter(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_Hints(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_Hints(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


class PyIADsUser(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def get_AccountDisabled(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_AccountDisabled(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_AccountExpirationDate(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_AccountExpirationDate(self,val:'PyTime') -> 'None':
         """
         None

Args:

      val(PyTime):

Returns:

      None
        
         """
         pass


      def get_BadLoginAddress(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def get_BadLoginCount(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def get_Department(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_Department(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_Description(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_Description(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_Division(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_Division(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_EmailAddress(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_EmailAddress(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_EmployeeID(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_EmployeeID(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_FirstName(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_FirstName(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_FullName(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_FullName(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_HomeDirectory(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_HomeDirectory(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_HomePage(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_HomePage(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def get_LoginScript(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def put_LoginScript(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def SetPassword(self,val:'typing.Any') -> 'None':
         """
         None

Args:

      val(typing.Any):

Returns:

      None
        
         """
         pass


      def ChangePassword(self,oldval:'typing.Any',newval:'typing.Any') -> 'None':
         """
         None

Args:

      oldval(typing.Any):
      newval(typing.Any):

Returns:

      None
        
         """
         pass


class PyIActiveDesktop(object):
      """An interface to the ActiveDesktop"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ApplyChanges(self,Flags:'typing.Any') -> 'None':
         """
         Applies changes to ActiveDesktop settings and persists them to the registry.

Args:

      Flags(typing.Any):Combination of shellcon.AD_APPLY_* flags

Returns:

      None
        
         """
         pass


      def GetWallpaper(self,cchWallpaper:'typing.Any',Reserved:'typing.Any'=0) -> 'typing.Any':
         """
         Returns the current wallpaper

Args:

      cchWallpaper(typing.Any):Number of characters to allocate for buffer
      Reserved(typing.Any):Use 0 if passed in

Returns:

      typing.Any
        
         """
         pass


      def SetWallpaper(self,Wallpaper:'typing.Any',Reserved:'typing.Any'=0) -> 'None':
         """
         Sets the desktop wallpaper

Args:

      Wallpaper(typing.Any):File to be used as new wallpaper
      Reserved(typing.Any):Reserved, use 0 if passed in

Returns:

      None
        
         """
         pass


      def GetWallpaperOptions(self,Reserved:'typing.Any'=0) -> 'typing.Any':
         """
         Returns wallpaper style

Args:

      Reserved(typing.Any):Use 0 if passed inReturn ValueReturns one of the WPSTYLE_* values

Returns:

      typing.Any:Use 0 if passed in
Return ValueReturns one of the WPSTYLE_* values

        
         """
         pass


      def SetWallpaperOptions(self,Style:'typing.Any',Reserved:'typing.Any'=0) -> 'None':
         """
         Sets wallpaper style

Args:

      Style(typing.Any):The wallpaper style, one of the WPSTYLE_* constants
      Reserved(typing.Any):Reserved, use 0 if passed in

Returns:

      None
        
         """
         pass


      def GetPattern(self,cchPattern:'typing.Any'=1024,Reserved:'typing.Any'=0) -> 'None':
         """
         Returns the wallpaper pattern

Args:

      cchPattern(typing.Any):Number of characters to allocate for buffer
      Reserved(typing.Any):Use 0 if passed inReturn ValueReturns a unicode string containing decimal values representing the pattern

Returns:

      None:Use 0 if passed in
Return ValueReturns a unicode string containing decimal values representing the pattern

        
         """
         pass


      def SetPattern(self,Pattern:'typing.Any',Reserved:'typing.Any'=0) -> 'None':
         """
         Sets the wallpaper pattern

Args:

      Pattern(typing.Any):String of decimal numbers representing a picture
      Reserved(typing.Any):Use 0 if passed in

Returns:

      None
        
         """
         pass


      def GetDesktopItemOptions(self,) -> 'typing.Any':
         """
         Returns options for Active Desktop.

Args:



Returns:

      typing.Any:PyIActiveDesktop.GetDesktopItemOptions

dict = GetDesktopItemOptions()Returns options for Active Desktop.
Return ValueReturns a COMPONENTSOPT dictionary

        
         """
         pass


      def SetDesktopItemOptions(self,comp:'typing.Any',Reserved:'typing.Any'=0) -> 'None':
         """
         Sets Active Desktop options

Args:

      comp(typing.Any):COMPONENTSOPT dictionary
      Reserved(typing.Any):Use 0 if passed in

Returns:

      None
        
         """
         pass


      def AddDesktopItem(self,comp:'typing.Any',Reserved:'typing.Any'=0) -> 'None':
         """
         Creates a new item to display on the desktop

Args:

      comp(typing.Any):COMPONENT dictionary
      Reserved(typing.Any):Use 0 if passed in

Returns:

      None
        
         """
         pass


      def AddDesktopItemWithUI(self,hwnd:'int',comp:'typing.Any',Flags:'typing.Any') -> 'None':
         """
         Adds a desktop item, allowing user interaction

Args:

      hwnd(int):Handle to parent window
      comp(typing.Any):COMPONENT dictionary
      Flags(typing.Any):One of shellcon.DTI_ADDUI_* flags

Returns:

      None
        
         """
         pass


      def ModifyDesktopItem(self,comp:'typing.Any',Flags:'typing.Any') -> 'None':
         """
         Changes parameters for a desktop item

Args:

      comp(typing.Any):COMPONENT dictionary
      Flags(typing.Any):Combination of shellcon.COMP_ELEM_* flags

Returns:

      None
        
         """
         pass


      def RemoveDesktopItem(self,comp:'typing.Any',Reserved:'typing.Any'=0) -> 'None':
         """
         Removes an item from the Active Desktop

Args:

      comp(typing.Any):COMPONENT dictionary specifying which component to remove
      Reserved(typing.Any):Use 0 if passed in

Returns:

      None
        
         """
         pass


      def GetDesktopItemCount(self,) -> 'None':
         """
         Returns number of defined desktop items.

Args:



Returns:

      None
        
         """
         pass


      def GetDesktopItem(self,Component:'typing.Any',Reserved:'typing.Any'=0) -> 'typing.Any':
         """
         Returns desktop item parameters by index

Args:

      Component(typing.Any):The zero-based index of the component to get
      Reserved(typing.Any):Use 0 if passed inReturn ValueReturns a COMPONENT dictionary describing the item

Returns:

      typing.Any:Use 0 if passed in
Return ValueReturns a COMPONENT dictionary describing the item

        
         """
         pass


      def GetDesktopItemByID(self,ID:'typing.Any',reserved:'typing.Any'=0) -> 'typing.Any':
         """
         Returns desktop item parameters by Id

Args:

      ID(typing.Any):The Id of the desktop item
      reserved(typing.Any):Use 0 if passed inReturn ValueReturns a COMPONENT dictionary

Returns:

      typing.Any:Use 0 if passed in
Return ValueReturns a COMPONENT dictionary

        
         """
         pass


      def GenerateDesktopItemHtml(self,FileName:'typing.Any',comp:'typing.Any',Reserved:'typing.Any'=0) -> 'None':
         """
         Creates an HTML page for the desktop item

Args:

      FileName(typing.Any):Name of file to be created
      comp(typing.Any):COMPONENT dictionary specifying the desktop item
      Reserved(typing.Any):Use 0 if passed in

Returns:

      None
        
         """
         pass


      def AddUrl(self,hwnd:'int',Source:'typing.Any',comp:'typing.Any',Flags:'typing.Any') -> 'None':
         """
         Adds a web page to desktop, allowing user interaction

Args:

      hwnd(int):Parent windows for any user interactive
      Source(typing.Any):Source URL
      comp(typing.Any):COMPONENT dictionary
      Flags(typing.Any):ADDURL_SILENT, or 0

Returns:

      None
        
         """
         pass


      def GetDesktopItemBySource(self,Source:'typing.Any',Reserved:'typing.Any'=0) -> 'typing.Any':
         """
         Returns desktop item parameters by URL

Args:

      Source(typing.Any):The URL address of the item to retrieve
      Reserved(typing.Any):Use 0 if passed inReturn ValueReturns a COMPONENT dictionary

Returns:

      typing.Any:Use 0 if passed in
Return ValueReturns a COMPONENT dictionary

        
         """
         pass


class PyIActiveDesktopP(object):
      """An interface to the ActiveDesktop"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetSafeMode(self,Flags:'typing.Any') -> 'None':
         """
         Changes Active Desktop to safe mode

Args:

      Flags(typing.Any):One of shellcon.SSM_* flags

Returns:

      None
        
         """
         pass


class PyIActiveScriptDebug(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetScriptTextAttributes(self,pstrCode:'str',pstrDelimiter:'str',dwFlags:'typing.Any') -> 'typing.Tuple[typing.Any, ...]':
         """
         Returns the text attributes for an arbitrary block 

of script text.

Args:

      pstrCode(str):The script block text.
      pstrDelimiter(str):See PyIActiveScriptParse::ParseScriptText for a description of this argument.
      dwFlags(typing.Any):See PyIActiveScriptParse::ParseScriptText for a description of this argument.CommentsSmart hosts use this call to delegate GetText calls made on their axscript::PyIDebugDocumentText

Returns:

      typing.Tuple[typing.Any, ...]
        
         """
         pass


      def GetScriptletTextAttributes(self,pstrCode:'str',pstrDelimiter:'str',dwFlags:'typing.Any') -> 'None':
         """
         Description of GetScriptletTextAttributes.

Args:

      pstrCode(str):The script block text.
      pstrDelimiter(str):See PyIActiveScriptParse::ParseScriptText for a description of this argument.
      dwFlags(typing.Any):See PyIActiveScriptParse::ParseScriptText for a description of this argument.

Returns:

      None
        
         """
         pass


      def EnumCodeContextsOfPosition(self,dwSourceContext:'typing.Any',uCharacterOffset:'typing.Any',uNumChars:'typing.Any') -> 'None':
         """
         Description of EnumCodeContextsOfPosition.

Args:

      dwSourceContext(typing.Any):Description for dwSourceContext
      uCharacterOffset(typing.Any):Description for uCharacterOffset
      uNumChars(typing.Any):Description for uNumChars

Returns:

      None
        
         """
         pass


class PyIActiveScriptError(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetExceptionInfo(self,) -> 'None':
         """
         Description of GetExceptionInfo.

Args:



Returns:

      None
        
         """
         pass


      def GetSourcePosition(self,) -> 'None':
         """
         Description of GetSourcePosition.

Args:



Returns:

      None
        
         """
         pass


      def GetSourceLineText(self,) -> 'None':
         """
         Description of GetSourceLineText.

Args:



Returns:

      None
        
         """
         pass


class PyIActiveScriptErrorDebug(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDocumentContext(self,) -> 'None':
         """
         Description of GetDocumentContext.

Args:



Returns:

      None
        
         """
         pass


      def GetStackFrame(self,) -> 'None':
         """
         Description of GetStackFrame.

Args:



Returns:

      None
        
         """
         pass


class PyIActiveScriptParseProcedure(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ParseProcedureText(self,pstrCode:'typing.Any',pstrFormalParams:'typing.Any',pstrProcedureName:'typing.Any',pstrItemName:'typing.Any',punkContext:'PyIUnknown',pstrDelimiter:'typing.Any',dwSourceContextCookie:'typing.Any',ulStartingLineNumber:'typing.Any',dwFlags:'typing.Any') -> 'None':
         """
         Description of ParseProcedureText.

Args:

      pstrCode(typing.Any):Description for pstrCode
      pstrFormalParams(typing.Any):Description for pstrFormalParams
      pstrProcedureName(typing.Any):Description for pstrProcedureName
      pstrItemName(typing.Any):Description for pstrItemName
      punkContext(PyIUnknown):Description for punkContext
      pstrDelimiter(typing.Any):Description for pstrDelimiter
      dwSourceContextCookie(typing.Any):Description for dwSourceContextCookie
      ulStartingLineNumber(typing.Any):Description for ulStartingLineNumber
      dwFlags(typing.Any):Description for dwFlags

Returns:

      None
        
         """
         pass


class PyIActiveScriptSite(object):
      """An object providing the IActiveScriptSite interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetLCID(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetItemInfo(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetDocVersionString(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnStateChange(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnEnterScript(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnLeaveScript(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnScriptError(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnScriptTerminate(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIActiveScriptSiteDebug(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDocumentContextFromPosition(self,dwSourceContext:'typing.Any',uCharacterOffset:'typing.Any',uNumChars:'typing.Any') -> 'None':
         """
         Description of GetDocumentContextFromPosition.

Args:

      dwSourceContext(typing.Any):Description for dwSourceContext
      uCharacterOffset(typing.Any):Description for uCharacterOffset
      uNumChars(typing.Any):Description for uNumChars

Returns:

      None
        
         """
         pass


      def GetApplication(self,) -> 'None':
         """
         Description of GetApplication.

Args:



Returns:

      None
        
         """
         pass


      def GetRootApplicationNode(self,) -> 'None':
         """
         Description of GetRootApplicationNode.

Args:



Returns:

      None
        
         """
         pass


      def OnScriptErrorDebug(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Allows a smart host to control the handling of runtime 

errors

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]:PyIActiveScriptSiteDebug.OnScriptErrorDebug

int, int = OnScriptErrorDebug()Allows a smart host to control the handling of runtime 

errors
Return ValueThe result is a tuple of (bCallDebugger, bCallOnScriptErrorWhenContinuing)

        
         """
         pass


class PyIAddrBook(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ResolveName(self,uiParm:'typing.Any',flags:'typing.Any',entryTitle:'str',ADRLIST:'typing.Any') -> 'None':
         """
         Performs name resolution, assigning entry identifiers to recipients in a recipient list.

Args:

      uiParm(typing.Any):hwnd of a dialogs parent.
      flags(typing.Any):Bitmask of flags that controls whether a dialog box can be displayed.
      entryTitle(str):
      ADRLIST(typing.Any):Partial addresses to resolve.

Returns:

      None
        
         """
         pass


      def OpenEntry(self,entryId:'str',iid:'PyIID',flags:'typing.Any') -> 'typing.Any':
         """
         Opens a folder or message and returns an interface object for further access.

Args:

      entryId(str):The entryID of the object
      iid(PyIID):The IID of the object to return, or None for the default IID
      flags(typing.Any):Bitmask of flags that controls how the object is opened.

Returns:

      typing.Any
        
         """
         pass


      def CompareEntryIDs(self,entryId:'str',entryId1:'str',flags:'typing.Any'=0) -> 'typing.Any':
         """
         Compares two entry identifiers belonging to a particular address book provider to determine if they refer to the same address book object

Args:

      entryId(str):The first entry ID to be compared
      entryId1(str):The second entry ID to be compared
      flags(typing.Any):Reserved - must be zero.Return ValueThe result is set to TRUE if the two entry identifiers refer to the same object, and FALSE otherwise.

Returns:

      typing.Any:Reserved - must be zero.
Return ValueThe result is set to TRUE if the two entry identifiers refer to the same object, and FALSE otherwise.

        
         """
         pass


class PyIApplicationDebugger(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def QueryAlive(self,) -> 'None':
         """
         Returns true if alive, else false.

Args:



Returns:

      None
        
         """
         pass


      def CreateInstanceAtDebugger(self,rclsid:'PyIID',pUnkOuter:'PyIUnknown',dwClsContext:'typing.Any',riid:'PyIID') -> 'None':
         """
         Create objects in the application process address space.

Args:

      rclsid(PyIID):Description for rclsid
      pUnkOuter(PyIUnknown):Description for pUnkOuter
      dwClsContext(typing.Any):Description for dwClsContext
      riid(PyIID):Description for riidCommentsProvides a mechanism for the debugger IDE, running out-of-process to the application, to create objects in the application process. This method simply delegates to CoCreateInstance.

Returns:

      None
        
         """
         pass


      def onDebugOutput(self,pstr:'typing.Any') -> 'None':
         """
         None

Args:

      pstr(typing.Any):Description for pstrCommentsThe debugger can use this to display the string in an output window.

Returns:

      None
        
         """
         pass


      def onHandleBreakPoint(self,prpt:'PyIRemoteDebugApplicationThread',br:'typing.Any',pError:'typing.Any') -> 'None':
         """
         Called when a breakpoint is hit.

Args:

      prpt(PyIRemoteDebugApplicationThread):Description for prpt
      br(typing.Any):Description for br
      pError(typing.Any):Description for pErrorCommentsThe application will remain suspended until the debugger IDE calls PyIDebugApplication::ResumeFromBreakPoint.

Returns:

      None
        
         """
         pass


      def onClose(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def onDebuggerEvent(self,guid:'PyIID',uUnknown:'PyIUnknown') -> 'None':
         """
         Description of onDebuggerEvent.

Args:

      guid(PyIID):
      uUnknown(PyIUnknown):CommentsThe semantics of guid and unknown are entirely application/debugger defined This method may return E_NOTIMPL.

Returns:

      None
        
         """
         pass


class PyIApplicationDestinations(object):
      """Allows an application to removed items from its jump lists"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetAppID(self,AppID:'typing.Any') -> 'None':
         """
         Specifies the application whose jump list is to be accessed

Args:

      AppID(typing.Any):Taskbar identifier for the applicationCommentsThis method is only needed if the application sets its own taskbar identifier

Returns:

      None
        
         """
         pass


      def RemoveDestination(self,punk:'PyIUnknown') -> 'None':
         """
         Removes a single entry from the jump lists

Args:

      punk(PyIUnknown):IShellItem or IShellLink representing an item in the application's jump listCommentsDoes not remove pinned items

Returns:

      None
        
         """
         pass


      def RemoveAllDestinations(self,) -> 'None':
         """
         Removes all Recent and Frequent jump list entries

Args:



Returns:

      None
        
         """
         pass


class PyIApplicationDocumentLists(object):
      """Interface used to retrieve the jump lists for an application"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetAppID(self,AppID:'typing.Any') -> 'None':
         """
         Specifies the application whose jump list is to be accessed

Args:

      AppID(typing.Any):Taskbar identifier for the applicationCommentsThis method is only needed if the application sets its own taskbar identifier

Returns:

      None
        
         """
         pass


      def GetList(self,ListType:'typing.Any',riid:'PyIID',ItemsDesired:'typing.Any'=0) -> 'PyIEnumObjects':
         """
         Retrieves a list of items in a jump list

Args:

      ListType(typing.Any):Type of document list to return, shellcon.ADLT_RECENT or ADLT_FREQUENT
      riid(PyIID):The interface to return, IID_IEnumObjects or IID_IObjectArray
      ItemsDesired(typing.Any):Number of items to return, use 0 for all available

Returns:

      PyIEnumObjects
        
         """
         pass


class PyIAsyncOperation(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetAsyncMode(self,fDoOpAsync:'typing.Any') -> 'None':
         """
         Description of SetAsyncMode.

Args:

      fDoOpAsync(typing.Any):Description for fDoOpAsync

Returns:

      None
        
         """
         pass


      def GetAsyncMode(self,) -> 'typing.Any':
         """
         Description of GetAsyncMode.

Args:



Returns:

      typing.Any
        
         """
         pass


      def StartOperation(self,pbcReserved:'PyIBindCtx') -> 'None':
         """
         Description of StartOperation.

Args:

      pbcReserved(PyIBindCtx):Description for pbcReserved

Returns:

      None
        
         """
         pass


      def InOperation(self,) -> 'None':
         """
         Description of InOperation.

Args:



Returns:

      None
        
         """
         pass


      def EndOperation(self,hResult:'typing.Any',pbcReserved:'PyIBindCtx',dwEffects:'typing.Any') -> 'None':
         """
         Description of EndOperation.

Args:

      hResult(typing.Any):Description for hResult
      pbcReserved(PyIBindCtx):Description for pbcReserved
      dwEffects(typing.Any):Description for dwEffects

Returns:

      None
        
         """
         pass


class PyIAttach(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetLastError(self,hr:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Returns the last error code for the object.

Args:

      hr(typing.Any):Contains the error code generated in the previous method call.
      flags(typing.Any):Indicates for format for the output.

Returns:

      typing.Any
        
         """
         pass


class PyIBindCtx(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetRunningObjectTable(self,) -> 'PyIRunningObjectTable':
         """
         Retrieves an object interfacing to the Running 

Object Table.

Args:



Returns:

      PyIRunningObjectTable
        
         """
         pass


      def GetBindOptions(self,) -> 'PyBIND_OPTS':
         """
         Retrieves the bind options for the bind context

Args:



Returns:

      PyBIND_OPTS
        
         """
         pass


      def SetBindOptions(self,bindopts:'typing.Any') -> 'None':
         """
         Sets the bind options for the context

Args:

      bindopts(typing.Any):PyBIND_OPTS dictionary containing the binding options

Returns:

      None
        
         """
         pass


      def RegisterObjectParam(self,Key:'str',punk:'PyIUnknown') -> 'None':
         """
         Adds an object to the context's keyed table of associated objects

Args:

      Key(str):The string key for the object to be registered
      punk(PyIUnknown):COM object to be registered with the bind context

Returns:

      None
        
         """
         pass


      def RevokeObjectParam(self,Key:'str') -> 'None':
         """
         Removes one of the bind context's registered objects

Args:

      Key(str):The string key for the object to be removed

Returns:

      None
        
         """
         pass


      def GetObjectParam(self,Key:'str') -> 'PyIUnknown':
         """
         Returns one of the bind context's associated objects

Args:

      Key(str):The string key for the object to be returned

Returns:

      PyIUnknown
        
         """
         pass


      def EnumObjectParam(self,) -> 'PyIEnumString':
         """
         Creates an enumerator to list context's string keys

Args:



Returns:

      PyIEnumString
        
         """
         pass


class PyIBrowserFrameOptions(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetFrameOptions(self,dwMask:'typing.Any') -> 'None':
         """
         Description of GetFrameOptions.

Args:

      dwMask(typing.Any):Description for dwMask

Returns:

      None
        
         """
         pass


class PyICancelMethodCalls(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Cancel(self,Seconds:'typing.Any') -> 'None':
         """
         Cancels a pending call

Args:

      Seconds(typing.Any):Wait timeout in seconds

Returns:

      None
        
         """
         pass


      def TestCancel(self,) -> 'typing.Any':
         """
         Checks if a request has been made to cancel a call

Args:



Returns:

      typing.Any:PyICancelMethodCalls.TestCancel

int = TestCancel()Checks if a request has been made to cancel a call
Return ValueCan return RPC_S_CALLPENDING or RPC_E_CALL_CANCELED

        
         """
         pass


class PyICatInformation(object):
      """A Python interface to ICatInformation"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def EnumCategories(self,lcid:'typing.Any'=0) -> 'PyIEnumCATEGORYINFO':
         """
         Returns an enumerator for the component categories 

registered on the system.

Args:

      lcid(typing.Any):lcid

Returns:

      PyIEnumCATEGORYINFO
        
         """
         pass


      def GetCategoryDesc(self,lcid:'typing.Any'=0) -> 'str':
         """
         Retrieves the localized description string for a specific category 

ID.

Args:

      lcid(typing.Any):lcidCommentsThe return type is a unicode object.

Returns:

      str
        
         """
         pass


      def EnumClassesOfCategories(self,listIIdImplemented:'typing.List[PyIID]'=None,listIIdRequired:'typing.Any'=None) -> 'PyIEnumGUID':
         """
         Returns an enumerator over the classes that 

implement one or more interfaces.

Args:

      listIIdImplemented(typing.List[PyIID]):A sequence of PyIID objects, or None.
      listIIdRequired(typing.Any):A sequence of PyIID objects, or None.

Returns:

      PyIEnumGUID
        
         """
         pass


class PyICatRegister(object):
      """An interface to a COM ICatRegister interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def RegisterCategories(self,arg:'typing.List[typing.Tuple[PyIID, typing.Any, str]]') -> 'None':
         """
         Registers one or more component categories. Each component category 

consists of a CATID and a list of locale-dependent description strings.

Args:

      arg(typing.List[typing.Tuple[PyIID, typing.Any, str]]):A sequence of category descriptions.

Returns:

      None
        
         """
         pass


      def UnRegisterCategories(self,arg:'typing.List[PyIID]') -> 'None':
         """
         Unregister one or more previously registered categories.

Args:

      arg(typing.List[PyIID]):The list of category IDs to be unregistered.

Returns:

      None
        
         """
         pass


      def RegisterClassImplCategories(self,clsid:'PyIID',arg:'typing.List[PyIID]') -> 'None':
         """
         Registers the class as implementing one or more component 

categories.

Args:

      clsid(PyIID):Class ID of the relevent class
      arg(typing.List[PyIID]):A sequence of category IDs to be associated with the class.

Returns:

      None
        
         """
         pass


      def UnRegisterClassImplCategories(self,clsid:'PyIID',arg:'typing.List[PyIID]') -> 'None':
         """
         Unregisters the class as implementing one or more component 

categories.

Args:

      clsid(PyIID):Class ID of the relevent class
      arg(typing.List[PyIID]):A sequence of category IDs to be unregistered from the class.

Returns:

      None
        
         """
         pass


      def RegisterClassReqCategories(self,clsid:'PyIID',arg:'typing.List[PyIID]') -> 'None':
         """
         Registers the class as requiring one or more component 

categories.

Args:

      clsid(PyIID):Class ID of the relevent class
      arg(typing.List[PyIID]):A sequence of category IDs to be associated with the class.

Returns:

      None
        
         """
         pass


      def UnRegisterClassReqCategories(self,clsid:'PyIID',arg:'typing.List[PyIID]') -> 'None':
         """
         Unregisters the class as requiring one or more component 

categories.

Args:

      clsid(PyIID):Class ID of the relevent class
      arg(typing.List[PyIID]):A sequence of category IDs to be unregistered for the class.

Returns:

      None
        
         """
         pass


class PyICategoryProvider(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CanCategorizeOnSCID(self,pscid:'typing.Any') -> 'None':
         """
         Description of CanCategorizeOnSCID.

Args:

      pscid(typing.Any):Description for pscid

Returns:

      None
        
         """
         pass


      def GetDefaultCategory(self,) -> 'None':
         """
         Description of GetDefaultCategory.

Args:



Returns:

      None
        
         """
         pass


      def GetCategoryForSCID(self,pscid:'typing.Any') -> 'None':
         """
         Description of GetCategoryForSCID.

Args:

      pscid(typing.Any):Description for pscid

Returns:

      None
        
         """
         pass


      def EnumCategories(self,) -> 'None':
         """
         Description of EnumCategories.

Args:



Returns:

      None
        
         """
         pass


      def GetCategoryName(self,guid:'PyIID') -> 'None':
         """
         Description of GetCategoryName.

Args:

      guid(PyIID):Description for pguidCommentsThe buffer is always 1024 chars long

Returns:

      None
        
         """
         pass


      def CreateCategory(self,guid:'PyIID',riid:'PyIID') -> 'None':
         """
         Description of CreateCategory.

Args:

      guid(PyIID):Description for pguid
      riid(PyIID):Description for riid

Returns:

      None
        
         """
         pass


class PyIClassFactory(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateInstance(self,outerUnknown:'PyIUnknown',iid:'PyIID') -> 'PyIUnknown':
         """
         Creates an uninitialized object.

Args:

      outerUnknown(PyIUnknown):Usually None, otherwise the outer unknown if the object is being created as part of an aggregate.
      iid(PyIID):The IID of the resultant object.Return ValueThe result object will always be derived from PyIUnknown, but will be of the type specified by iid.

Returns:

      PyIUnknown:The IID of the resultant object.Return ValueThe result object will always be derived from PyIUnknown, but will be of the 

type specified by iid.

        
         """
         pass


      def LockServer(self,bInc:'typing.Any') -> 'None':
         """
         Called by the client of a class object to keep a server open in memory, 

allowing instances to be created more quickly.

Args:

      bInc(typing.Any):1 of the server should be locked, 0 if the server should be unlocked.

Returns:

      None
        
         """
         pass


class PyIClientSecurity(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def QueryBlanket(self,Proxy:'PyIUnknown') -> 'typing.Any':
         """
         Retrieves the authentication settings for an interface

Args:

      Proxy(PyIUnknown):An interface created through a proxy

Returns:

      typing.Any
        
         """
         pass


      def SetBlanket(self,Proxy:'PyIUnknown',AuthnSvc:'typing.Any',AuthzSvc:'typing.Any',ServerPrincipalName:'str',AuthnLevel:'typing.Any',ImpLevel:'typing.Any',AuthInfo:'typing.Any',Capabilities:'typing.Any') -> 'None':
         """
         Changes the authentication options used with an interface

Args:

      Proxy(PyIUnknown):The proxy interface for which to set security options
      AuthnSvc(typing.Any):Authentication service identifier, pythoncom.RPC_C_AUTHN_* (but not RPC_C_AUTHN_LEVEL_*)
      AuthzSvc(typing.Any):Authorization service identifier, pythoncom.RPC_C_AUTHZ_*
      ServerPrincipalName(str):SPN that identifies the server, can be None
      AuthnLevel(typing.Any):Authentication level, pythoncom.RPC_C_AUTHN_LEVEL_*
      ImpLevel(typing.Any):Impersonation level, pythoncom.RPC_C_IMP_LEVEL_*
      AuthInfo(typing.Any):Not supported yet, use only None
      Capabilities(typing.Any):Combination of pythoncom.EOAC_* flags.  Must be a subset of the capabilities of the specified authentication service.

Returns:

      None
        
         """
         pass


      def CopyProxy(self,Proxy:'PyIUnknown') -> 'PyIUnknown':
         """
         Makes a private copy of a proxy interface

Args:

      Proxy(PyIUnknown):The remote interface to be copied

Returns:

      PyIUnknown
        
         """
         pass


class PyIColumnProvider(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,psci:'typing.Any') -> 'None':
         """
         Description of Initialize.

Args:

      psci(typing.Any):Description for psci

Returns:

      None
        
         """
         pass


      def GetColumnInfo(self,dwIndex:'typing.Any') -> 'None':
         """
         Description of GetColumnInfo.

Args:

      dwIndex(typing.Any):Description for dwIndex

Returns:

      None
        
         """
         pass


      def GetItemData(self,pscid:'typing.Any',pscd:'typing.Any') -> 'None':
         """
         Description of GetItemData.

Args:

      pscid(typing.Any):Description for pscid
      pscd(typing.Any):Description for pscd

Returns:

      None
        
         """
         pass


class PyIConnectionPoint(object):
      """A Python wrapper of a COM IConnectionPoint interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetConnectionInterface(self,) -> 'PyIID':
         """
         Retrieves the IID of the interface represented by the 

connection point.

Args:



Returns:

      PyIID
        
         """
         pass


      def GetConnectionPointContainer(self,) -> 'PyIConnectionPointContainer':
         """
         Gets the connection point 

container for the object.

Args:



Returns:

      PyIConnectionPointContainer
        
         """
         pass


      def Advise(self,unk:'PyIUnknown') -> 'typing.Any':
         """
         Establishes a connection between the connection point object and the client's 

sink.

Args:

      unk(PyIUnknown):The client's advise sinkReturn ValueThe result is the connection point identifier used by PyIConnectionPoint::Unadvise

Returns:

      typing.Any:The client's advise sinkReturn ValueThe result is the connection point identifier used by PyIConnectionPoint::Unadvise

        
         """
         pass


      def Unadvise(self,cookie:'typing.Any') -> 'None':
         """
         Terminates an advisory connection previously established through 

IConnectionPoint::Advise. The dwCookie parameter identifies the connection to terminate.

Args:

      cookie(typing.Any):The connection token

Returns:

      None
        
         """
         pass


      def EnumConnections(self,) -> 'PyIEnumConnections':
         """
         Creates an enumerator to iterate through the 

connections for the connection point

Args:



Returns:

      PyIEnumConnections
        
         """
         pass


class PyIConnectionPointContainer(object):
      """A Python wrapper of a COM IConnectionPointContainer interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def EnumConnectionPoints(self,) -> 'PyIEnumConnectionPoints':
         """
         Creates an enumerator object 

to iterate through all the connection points supported in the connectable object, one connection point per outgoing 

IID.

Args:



Returns:

      PyIEnumConnectionPoints
        
         """
         pass


      def FindConnectionPoint(self,iid:'PyIID') -> 'PyIConnectionPoint':
         """
         Finds a connection point for the 

given IID

Args:

      iid(PyIID):The IID of the requested connection.

Returns:

      PyIConnectionPoint
        
         """
         pass


class PyIContext(object):
      """Allows access to properties defined for the current context (Requires win2k or later)"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetProperty(self,rpolicyId:'PyIID',flags:'typing.Any',pUnk:'PyIUnknown') -> 'None':
         """
         Sets a property on the context

Args:

      rpolicyId(PyIID):GUID identifying the property to be set
      flags(typing.Any):Reserved, use only 0
      pUnk(PyIUnknown):The property value

Returns:

      None
        
         """
         pass


      def RemoveProperty(self,rPolicyId:'PyIID') -> 'None':
         """
         Removes a property from the context

Args:

      rPolicyId(PyIID):GUID that identifies a context property

Returns:

      None
        
         """
         pass


      def GetProperty(self,rGuid:'PyIID') -> 'typing.Tuple[typing.Any, PyIUnknown]':
         """
         Retrieves a context property

Args:

      rGuid(PyIID):GUID that identifies a context propertyReturn ValueReturns flags (CPFLAGS is reserved, no defined values) and the IUnknown interface set for the property

Returns:

      typing.Tuple[typing.Any, PyIUnknown]:GUID that identifies a context propertyReturn ValueReturns flags (CPFLAGS is reserved, no defined values) and the IUnknown interface set for the property

        
         """
         pass


      def EnumContextProps(self,) -> 'PyIEnumContextProps':
         """
         Returns an enumerator for the context properties

Args:



Returns:

      PyIEnumContextProps
        
         """
         pass


class PyIContextMenu(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def QueryContextMenu(self,hmenu:'int',indexMenu:'typing.Any',idCmdFirst:'typing.Any',idCmdLast:'typing.Any',uFlags:'typing.Any') -> 'typing.Any':
         """
         Adds options to a context menu

Args:

      hmenu(int):Handle to menu to which items should be added
      indexMenu(typing.Any):Zero-based index at which to add first item
      idCmdFirst(typing.Any):Minimum menu item Id
      idCmdLast(typing.Any):Max menu item Id
      uFlags(typing.Any):Combination of shellcon.CMF_* flags, can be 0

Returns:

      typing.Any
        
         """
         pass


      def InvokeCommand(self,pici:'PyCMINVOKECOMMANDINFO') -> 'None':
         """
         Executes a context menu option

Args:

      pici(PyCMINVOKECOMMANDINFO):Tuple of parameters representing a CMINVOKECOMMANDINFO struct

Returns:

      None
        
         """
         pass


      def GetCommandString(self,idCmd:'typing.Any',uType:'typing.Any',cchMax:'typing.Any'=2048) -> 'typing.Any':
         """
         Retrieves verb or help text for a context menu option

Args:

      idCmd(typing.Any):Id of the command
      uType(typing.Any):One of the shellcon.GCS_* constants
      cchMax(typing.Any):Size of buffer to create for returned string

Returns:

      typing.Any
        
         """
         pass


class PyICopyHookA(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CopyCallback(self,hwnd:'int',wFunc:'typing.Any',wFlags:'typing.Any',srcFile:'typing.Union[str, typing.Any]',srcAttribs:'typing.Any',destFile:'typing.Union[str, typing.Any]',destAttribs:'typing.Any') -> 'None':
         """
         Description of CopyCallback.

Args:

      hwnd(typing.Any):Description for hwnd
      wFunc(typing.Any):Description for wFunc
      wFlags(typing.Any):Description for wFlags
      srcFile(typing.Union[str, typing.Any]):Description for srcFile
      srcAttribs(typing.Any):Description for srcAttribs
      destFile(typing.Union[str, typing.Any]):Description for destFile
      destAttribs(typing.Any):Description for destAttribs

Returns:

      None
        
         """
         pass


class PyICopyHookW(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CopyCallback(self,hwnd:'int',wFunc:'typing.Any',wFlags:'typing.Any',srcFile:'typing.Union[str, typing.Any]',srcAttribs:'typing.Any',destFile:'typing.Union[str, typing.Any]',destAttribs:'typing.Any') -> 'None':
         """
         Description of CopyCallback.

Args:

      hwnd(typing.Any):Description for hwnd
      wFunc(typing.Any):Description for wFunc
      wFlags(typing.Any):Description for wFlags
      srcFile(typing.Union[str, typing.Any]):Description for srcFile
      srcAttribs(typing.Any):Description for srcAttribs
      destFile(typing.Union[str, typing.Any]):Description for destFile
      destAttribs(typing.Any):Description for destAttribs

Returns:

      None
        
         """
         pass


class PyICreateTypeInfo(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetGuid(self,guid:'PyIID') -> 'None':
         """
         Description of SetGuid.

Args:

      guid(PyIID):Description for guid

Returns:

      None
        
         """
         pass


      def SetTypeFlags(self,uTypeFlags:'typing.Any') -> 'None':
         """
         Description of SetTypeFlags.

Args:

      uTypeFlags(typing.Any):Description for uTypeFlags

Returns:

      None
        
         """
         pass


      def SetDocString(self,pStrDoc:'typing.Any') -> 'None':
         """
         Description of SetDocString.

Args:

      pStrDoc(typing.Any):Description for pStrDoc

Returns:

      None
        
         """
         pass


      def SetHelpContext(self,dwHelpContext:'typing.Any') -> 'None':
         """
         Description of SetHelpContext.

Args:

      dwHelpContext(typing.Any):Description for dwHelpContext

Returns:

      None
        
         """
         pass


      def SetVersion(self,wMajorVerNum:'typing.Any',wMinorVerNum:'typing.Any') -> 'None':
         """
         Description of SetVersion.

Args:

      wMajorVerNum(typing.Any):Description for wMajorVerNum
      wMinorVerNum(typing.Any):Description for wMinorVerNum

Returns:

      None
        
         """
         pass


      def AddRefTypeInfo(self,pTInfo:'PyITypeInfo') -> 'None':
         """
         Description of AddRefTypeInfo.

Args:

      pTInfo(PyITypeInfo):Description for pTInfo

Returns:

      None
        
         """
         pass


      def AddFuncDesc(self,index:'typing.Any') -> 'None':
         """
         Description of AddFuncDesc.

Args:

      index(typing.Any):Description for index

Returns:

      None
        
         """
         pass


      def AddImplType(self,index:'typing.Any',hRefType:'typing.Any') -> 'None':
         """
         Description of AddImplType.

Args:

      index(typing.Any):Description for index
      hRefType(typing.Any):A hRefType

Returns:

      None
        
         """
         pass


      def SetImplTypeFlags(self,index:'typing.Any',implTypeFlags:'typing.Any') -> 'None':
         """
         Description of SetImplTypeFlags.

Args:

      index(typing.Any):Description for index
      implTypeFlags(typing.Any):Description for implTypeFlags

Returns:

      None
        
         """
         pass


      def SetAlignment(self,cbAlignment:'typing.Any') -> 'None':
         """
         Description of SetAlignment.

Args:

      cbAlignment(typing.Any):Description for cbAlignment

Returns:

      None
        
         """
         pass


      def SetSchema(self,pStrSchema:'typing.Any') -> 'None':
         """
         Description of SetSchema.

Args:

      pStrSchema(typing.Any):Description for pStrSchema

Returns:

      None
        
         """
         pass


      def AddVarDesc(self,index:'typing.Any') -> 'None':
         """
         Description of AddVarDesc.

Args:

      index(typing.Any):Description for index

Returns:

      None
        
         """
         pass


      def SetFuncAndParamNames(self,index:'typing.Any',rgszNames:'typing.Tuple[typing.Any, ...]') -> 'None':
         """
         Description of SetFuncAndParamNames.

Args:

      index(typing.Any):Index of the item to set.
      rgszNames(typing.Tuple[typing.Any, ...]):A sequence of unicode or String objects.

Returns:

      None
        
         """
         pass


      def SetVarName(self,index:'typing.Any',szName:'typing.Any') -> 'None':
         """
         Description of SetVarName.

Args:

      index(typing.Any):Description for index
      szName(typing.Any):Description for szName

Returns:

      None
        
         """
         pass


      def SetTypeDescAlias(self,) -> 'None':
         """
         Description of SetTypeDescAlias.

Args:



Returns:

      None
        
         """
         pass


      def DefineFuncAsDllEntry(self,index:'typing.Any',szDllName:'typing.Any',szProcName:'typing.Any') -> 'None':
         """
         Description of DefineFuncAsDllEntry.

Args:

      index(typing.Any):Description for index
      szDllName(typing.Any):Description for szDllName
      szProcName(typing.Any):Description for szProcName

Returns:

      None
        
         """
         pass


      def SetFuncDocString(self,index:'typing.Any',szDocString:'typing.Any') -> 'None':
         """
         Description of SetFuncDocString.

Args:

      index(typing.Any):Description for index
      szDocString(typing.Any):Description for szDocString

Returns:

      None
        
         """
         pass


      def SetVarDocString(self,index:'typing.Any',szDocString:'typing.Any') -> 'None':
         """
         Description of SetVarDocString.

Args:

      index(typing.Any):Description for index
      szDocString(typing.Any):Description for szDocString

Returns:

      None
        
         """
         pass


      def SetFuncHelpContext(self,index:'typing.Any',dwHelpContext:'typing.Any') -> 'None':
         """
         Description of SetFuncHelpContext.

Args:

      index(typing.Any):Description for index
      dwHelpContext(typing.Any):Description for dwHelpContext

Returns:

      None
        
         """
         pass


      def SetVarHelpContext(self,index:'typing.Any',dwHelpContext:'typing.Any') -> 'None':
         """
         Description of SetVarHelpContext.

Args:

      index(typing.Any):Description for index
      dwHelpContext(typing.Any):Description for dwHelpContext

Returns:

      None
        
         """
         pass


      def SetMops(self,index:'typing.Any',bstrMops:'typing.Any') -> 'None':
         """
         Description of SetMops.

Args:

      index(typing.Any):Description for index
      bstrMops(typing.Any):Description for bstrMops

Returns:

      None
        
         """
         pass


      def LayOut(self,) -> 'None':
         """
         Description of LayOut.

Args:



Returns:

      None
        
         """
         pass


class PyICreateTypeLib(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateTypeInfo(self,szName:'typing.Any') -> 'None':
         """
         Description of CreateTypeInfo.

Args:

      szName(typing.Any):Description for szName

Returns:

      None
        
         """
         pass


      def SetName(self,szName:'typing.Any') -> 'None':
         """
         Description of SetName.

Args:

      szName(typing.Any):Description for szName

Returns:

      None
        
         """
         pass


      def SetVersion(self,wMajorVerNum:'typing.Any',wMinorVerNum:'typing.Any') -> 'None':
         """
         Description of SetVersion.

Args:

      wMajorVerNum(typing.Any):Description for wMajorVerNum
      wMinorVerNum(typing.Any):Description for wMinorVerNum

Returns:

      None
        
         """
         pass


      def SetGuid(self,guid:'PyIID') -> 'None':
         """
         Description of SetGuid.

Args:

      guid(PyIID):Description for guid

Returns:

      None
        
         """
         pass


      def SetDocString(self,szDoc:'typing.Any') -> 'None':
         """
         Description of SetDocString.

Args:

      szDoc(typing.Any):Description for szDoc

Returns:

      None
        
         """
         pass


      def SetHelpFileName(self,szHelpFileName:'typing.Any') -> 'None':
         """
         Description of SetHelpFileName.

Args:

      szHelpFileName(typing.Any):Description for szHelpFileName

Returns:

      None
        
         """
         pass


      def SetHelpContext(self,dwHelpContext:'typing.Any') -> 'None':
         """
         Description of SetHelpContext.

Args:

      dwHelpContext(typing.Any):Description for dwHelpContext

Returns:

      None
        
         """
         pass


      def SetLcid(self,) -> 'None':
         """
         Description of SetLcid.

Args:



Returns:

      None
        
         """
         pass


      def SetLibFlags(self,uLibFlags:'typing.Any') -> 'None':
         """
         Description of SetLibFlags.

Args:

      uLibFlags(typing.Any):Description for uLibFlags

Returns:

      None
        
         """
         pass


      def SaveAllChanges(self,) -> 'None':
         """
         Description of SaveAllChanges.

Args:



Returns:

      None
        
         """
         pass


class PyICreateTypeLib2(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateTypeInfo(self,szName:'typing.Any') -> 'None':
         """
         Description of CreateTypeInfo.

Args:

      szName(typing.Any):Description for szName

Returns:

      None
        
         """
         pass


      def SetName(self,szName:'typing.Any') -> 'None':
         """
         Description of SetName.

Args:

      szName(typing.Any):Description for szName

Returns:

      None
        
         """
         pass


      def SetVersion(self,wMajorVerNum:'typing.Any',wMinorVerNum:'typing.Any') -> 'None':
         """
         Description of SetVersion.

Args:

      wMajorVerNum(typing.Any):Description for wMajorVerNum
      wMinorVerNum(typing.Any):Description for wMinorVerNum

Returns:

      None
        
         """
         pass


      def SetGuid(self,guid:'PyIID') -> 'None':
         """
         Description of SetGuid.

Args:

      guid(PyIID):Description for guid

Returns:

      None
        
         """
         pass


      def SetDocString(self,szDoc:'typing.Any') -> 'None':
         """
         Description of SetDocString.

Args:

      szDoc(typing.Any):Description for szDoc

Returns:

      None
        
         """
         pass


      def SetHelpFileName(self,szHelpFileName:'typing.Any') -> 'None':
         """
         Description of SetHelpFileName.

Args:

      szHelpFileName(typing.Any):Description for szHelpFileName

Returns:

      None
        
         """
         pass


      def SetHelpContext(self,dwHelpContext:'typing.Any') -> 'None':
         """
         Description of SetHelpContext.

Args:

      dwHelpContext(typing.Any):Description for dwHelpContext

Returns:

      None
        
         """
         pass


      def SetLcid(self,) -> 'None':
         """
         Description of SetLcid.

Args:



Returns:

      None
        
         """
         pass


      def SetLibFlags(self,uLibFlags:'typing.Any') -> 'None':
         """
         Description of SetLibFlags.

Args:

      uLibFlags(typing.Any):Description for uLibFlags

Returns:

      None
        
         """
         pass


      def SaveAllChanges(self,) -> 'None':
         """
         Description of SaveAllChanges.

Args:



Returns:

      None
        
         """
         pass


class PyICurrentItem(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyICustomDestinationList(object):
      """Interface used to customize an application's jump list"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetAppID(self,AppID:'typing.Any') -> 'None':
         """
         Specifies the taskbar identifier for the jump list

Args:

      AppID(typing.Any):The taskbar identifier of the applicationCommentsOnly needed if the calling app doesn't use the system-assigned default

Returns:

      None
        
         """
         pass


      def BeginList(self,riid:'PyIID') -> 'typing.Tuple[typing.Any, PyIObjectArray]':
         """
         Clears the jump list and prepares it to be 

repopulated

Args:

      riid(PyIID):The interface to returnReturn ValueReturns the number of slots and a collection of all destinations removed from the jump list

Returns:

      typing.Tuple[typing.Any, PyIObjectArray]:The interface to return
Return ValueReturns the number of slots and a collection of all destinations removed from the jump list

        
         """
         pass


      def AppendCategory(self,Category:'typing.Any',Items:'PyIObjectArray') -> 'None':
         """
         Adds a custom category to the jump list

Args:

      Category(typing.Any):Display name of the category, can also be a dll and resource id for localization
      Items(PyIObjectArray):Collection of IShellItem and/or IShellLink interfaces

Returns:

      None
        
         """
         pass


      def AppendKnownCategory(self,Category:'typing.Any') -> 'None':
         """
         Adds one of the predefined categories to the custom list

Args:

      Category(typing.Any):shellcon.KDC_RECENT or KDC_FREQUENT

Returns:

      None
        
         """
         pass


      def AddUserTasks(self,Items:'PyIObjectArray') -> 'None':
         """
         Sets the entries shown in the Tasks category

Args:

      Items(PyIObjectArray):Collection of PyIShellItem and/or PyIShellLink interfaces

Returns:

      None
        
         """
         pass


      def CommitList(self,) -> 'None':
         """
         Finalizes changes.

Args:



Returns:

      None
        
         """
         pass


      def GetRemovedDestinations(self,riid:'PyIID') -> 'PyIObjectArray':
         """
         Returns all the items removed from the 

jump list

Args:

      riid(PyIID):The interface to return

Returns:

      PyIObjectArray
        
         """
         pass


      def DeleteList(self,AppID:'typing.Any'=None) -> 'None':
         """
         Removes any customization, leaving only the system-maintained Recent 

and Frequent lists

Args:

      AppID(typing.Any):The taskbar identifier of the application

Returns:

      None
        
         """
         pass


      def AbortList(self,) -> 'None':
         """
         Discards all changes

Args:



Returns:

      None
        
         """
         pass


class PyIDL(object):
      """A Python representation of an IDL.  Implemented as a sequence of Python strings. 

FALSE*/, UINT *pcb /* = NULL */)"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyIDataObject(object):
      """Used to transfer data in various formats throughout the shell"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetData(self,pformatetcIn:'PyFORMATETC') -> 'PySTGMEDIUM':
         """
         Retrieves data from the object in specified format

Args:

      pformatetcIn(PyFORMATETC):Tuple representing a FORMATETC struct describing how the data should be returned

Returns:

      PySTGMEDIUM
        
         """
         pass


      def GetDataHere(self,pformatetcIn:'PyFORMATETC') -> 'PySTGMEDIUM':
         """
         Retunrs a copy of the object's data in specified format

Args:

      pformatetcIn(PyFORMATETC):Tuple representing a FORMATETC struct describing how the data should be returned

Returns:

      PySTGMEDIUM
        
         """
         pass


      def QueryGetData(self,pformatetc:'PyFORMATETC') -> 'None':
         """
         Checks if the objects supports returning data in a particular format.

Args:

      pformatetc(PyFORMATETC):Tuple representing a FORMATETC struct describing how the data should be returnedReturn ValueReturns None if the object supports the specified format, otherwise an error is raised.

Returns:

      None:Tuple representing a FORMATETC struct describing how the data should be 

returnedReturn ValueReturns None if the object supports the specified format, otherwise an error is raised.

        
         """
         pass


      def GetCanonicalFormatEtc(self,pformatectIn:'PyFORMATETC') -> 'PyFORMATETC':
         """
         Transforms a FORMATECT data description into a general 

format that the object supports

Args:

      pformatectIn(PyFORMATETC):Tuple representing a FORMATETC struct describing how the data should be returned

Returns:

      PyFORMATETC
        
         """
         pass


      def SetData(self,pformatetc:'PyFORMATETC',pmedium:'PySTGMEDIUM',fRelease:'typing.Any') -> 'None':
         """
         Sets the data that the object will return.

Args:

      pformatetc(PyFORMATETC):Tuple representing a FORMATETC struct describing the type of data to be set
      pmedium(PySTGMEDIUM):The data to be placed in the object
      fRelease(typing.Any):If True, transfers ownership of the data to the object.  If False, caller is responsible for releasing the STGMEDIUM.

Returns:

      None
        
         """
         pass


      def EnumFormatEtc(self,dwDirection:'typing.Any') -> 'PyIEnumFORMATETC':
         """
         Returns an enumerator to list the data formats that the 

object supports.

Args:

      dwDirection(typing.Any):Indicates whether to return formats that can be queried or set (pythoncom.DATADIR_GET or DATADIR_SET)

Returns:

      PyIEnumFORMATETC
        
         """
         pass


      def DAdvise(self,pformatetc:'PyFORMATETC',advf:'typing.Any',pAdvSink:'typing.Any') -> 'typing.Any':
         """
         Connects the object to an interface that will receive notifications when its data 

changes

Args:

      pformatetc(PyFORMATETC):Defines the type of data for which the sink will receive notifications.
      advf(typing.Any):Combination of values from ADVF enum. (which currently do not appear in any of the constants modules!)
      pAdvSink(typing.Any):Currently this interface is not wrapped.Return ValueReturns a unique number that is used to identify the connection

Returns:

      typing.Any:Currently this interface is not wrapped.Return ValueReturns a unique number that is used to identify the connection

        
         """
         pass


      def DUnadvise(self,dwConnection:'typing.Any') -> 'None':
         """
         Disconnects a notification sink.

Args:

      dwConnection(typing.Any):Identifier of the connection as returned by DAdvise.

Returns:

      None
        
         """
         pass


      def EnumDAdvise(self,) -> 'typing.Any':
         """
         Creates an enumerator to list connected notification sinks.

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIDebugApplication(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetName(self,pstrName:'typing.Any') -> 'None':
         """
         Sets the name of the application.

Args:

      pstrName(typing.Any):The name of the application.CommentsThe provided name will be returned in subsequent calls to &gtom PyIRemoteDebugApplication.GetName&gt.

Returns:

      None
        
         """
         pass


      def StepOutComplete(self,) -> 'None':
         """
         Called by language engines, in single step mode, just before they 

return to their caller.

Args:



Returns:

      None
        
         """
         pass


      def DebugOutput(self,pstr:'typing.Any') -> 'None':
         """
         Causes the given string to be displayed by the debugger IDE, normally in 

an output window.

Args:

      pstr(typing.Any):Description for pstrCommentsThis mechanism provides the means for a language engine to implement language specific debugging output support. Example: Debug.writeln("Help") in JavaScript.

Returns:

      None
        
         """
         pass


      def StartDebugSession(self,) -> 'None':
         """
         Causes a default debugger IDE to be started and a debug session to 

be attached to this application if one does not already exist.

Args:



Returns:

      None
        
         """
         pass


      def HandleBreakPoint(self,br:'typing.Any') -> 'typing.Any':
         """
         Called by the language engine in the context of a thread that has 

hit a breakpoint.

Args:

      br(typing.Any):Break reason - one of the BREAKREASON_* constants.CommentsThis method causes the current thread to block and a notification of the breakpoint to be sent to the debugger IDE. When the debugger IDE resumes the application this method returns with the action to be taken.Note: While in the breakpoint the language engine may be called in this thread to do various things such as enumerating stack frames or evaluating expressions.Return ValueThe result is the break resume action - one of the BREAKRESUMEACTION contsants.

Returns:

      typing.Any:Break reason - one of the BREAKREASON_* constants.Comments

This method causes the current thread to block and a notification of the breakpoint 

to be sent to the debugger IDE. When the debugger IDE resumes the application this 

method returns with the action to be taken.

Note: While in the breakpoint the language engine may be called in this thread to do 

various things such as enumerating stack frames or evaluating expressions.
Return ValueThe result is the break resume action - one of the BREAKRESUMEACTION contsants.

        
         """
         pass


      def Close(self,) -> 'None':
         """
         Causes this application to release all references and enter a zombie state.

Args:



Returns:

      None
        
         """
         pass


      def GetBreakFlags(self,) -> 'typing.Any':
         """
         Returns the current break flags for the application.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetCurrentThread(self,) -> 'PyIDebugApplicationThread':
         """
         Returns the application thread object 

associated with the currently running thread.

Args:



Returns:

      PyIDebugApplicationThread
        
         """
         pass


      def CreateAsyncDebugOperation(self,psdo:'PyIDebugSyncOperation') -> 'None':
         """
         None

Args:

      psdo(PyIDebugSyncOperation):Description for psdoCommentsThis provides a mechanism for language engines to implement asynchronous expression and evaluation, etc. without having to know the details of synchronization with the debugger thread. See the descriptions for PyIDebugSyncOperation and PyIDebugAsyncOperation for more details.

Returns:

      None
        
         """
         pass


      def AddStackFrameSniffer(self,pdsfs:'PyIDebugStackFrameSniffer') -> 'typing.Any':
         """
         Adds a stack frame sniffer to this application.

Args:

      pdsfs(PyIDebugStackFrameSniffer):Description for pdsfsCommentsGenerally called by a language engine to expose its stack frames to the debugger. It is possible for other entities to expose stack frames.Return ValueThe result is an integer cookie, to be passed to PyIDebugApplication::RemoveStackFrameSniffer

Returns:

      typing.Any:Description for pdsfsComments

Generally called by a language engine 

to expose its stack frames to the debugger. It is possible for other entities to 

expose stack frames.
Return ValueThe result is an integer cookie, to be passed to PyIDebugApplication::RemoveStackFrameSniffer

        
         """
         pass


      def RemoveStackFrameSniffer(self,dwCookie:'typing.Any') -> 'None':
         """
         Removes a stack frame sniffer from this application.

Args:

      dwCookie(typing.Any):A cookie obtained from PyIDebugApplication::AddStackFrameSniffer

Returns:

      None
        
         """
         pass


      def QueryCurrentThreadIsDebuggerThread(self,) -> 'None':
         """
         Determines if the current running thread is the 

debugger thread.

Args:



Returns:

      None:PyIDebugApplication.QueryCurrentThreadIsDebuggerThread
QueryCurrentThreadIsDebuggerThread()Determines if the current running thread is the 

debugger thread.
Return ValueReturns S_OK if the current running thread is the debugger thread. 

Otherwise, returns S_FALSE.

        
         """
         pass


      def SynchronousCallInDebuggerThread(self,pptc:'typing.Any',dwParam1:'typing.Any',dwParam2:'typing.Any',dwParam3:'typing.Any') -> 'None':
         """
         Provides a mechanism for the caller to run code in the 

debugger thread.

Args:

      pptc(typing.Any):Description for pptc
      dwParam1(typing.Any):Description for dwParam1
      dwParam2(typing.Any):Description for dwParam2
      dwParam3(typing.Any):Description for dwParam3CommentsThis is generally used so that language engines and hosts can implement free threaded objects on top of their single threaded implementations.

Returns:

      None
        
         """
         pass


      def CreateApplicationNode(self,) -> 'PyIDebugApplicationNode':
         """
         Creates a new application node which 

is associated with a specific document provider.

Args:



Returns:

      PyIDebugApplicationNode
        
         """
         pass


      def FireDebuggerEvent(self,guid:'typing.Any',unknown:'PyIUnknown') -> 'None':
         """
         Fire a generic event to the IApplicationDebugger (if any)

Args:

      guid(typing.Any):A GUID.
      unknown(PyIUnknown):An unknown object.

Returns:

      None
        
         """
         pass


      def HandleRuntimeError(self,pErrorDebug:'PyIActiveScriptErrorDebug',pScriptSite:'PyIActiveScriptSite') -> 'None':
         """
         Description of HandleRuntimeError.

Args:

      pErrorDebug(PyIActiveScriptErrorDebug):Description for pErrorDebug
      pScriptSite(PyIActiveScriptSite):Description for pScriptSite

Returns:

      None
        
         """
         pass


      def FCanJitDebug(self,) -> 'None':
         """
         Description of FCanJitDebug.

Args:



Returns:

      None
        
         """
         pass


      def FIsAutoJitDebugEnabled(self,) -> 'None':
         """
         Description of FIsAutoJitDebugEnabled.

Args:



Returns:

      None
        
         """
         pass


      def AddGlobalExpressionContextProvider(self,pdsfs:'PyIProvideExpressionContexts') -> 'None':
         """
         Description of AddGlobalExpressionContextProvider.

Args:

      pdsfs(PyIProvideExpressionContexts):Description for pdsfs

Returns:

      None
        
         """
         pass


      def RemoveGlobalExpressionContextProvider(self,dwCookie:'typing.Any') -> 'None':
         """
         Description of 

RemoveGlobalExpressionContextProvider.

Args:

      dwCookie(typing.Any):Description for dwCookie

Returns:

      None
        
         """
         pass


class PyIDebugApplicationNode(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def EnumChildren(self,) -> 'None':
         """
         Description of EnumChildren.

Args:



Returns:

      None
        
         """
         pass


      def GetParent(self,) -> 'PyIDebugApplicationNode':
         """
         Returns the parent node.

Args:



Returns:

      PyIDebugApplicationNode
        
         """
         pass


      def SetDocumentProvider(self,pddp:'PyIDebugDocumentProvider') -> 'None':
         """
         Description of SetDocumentProvider.

Args:

      pddp(PyIDebugDocumentProvider):Description for pddp

Returns:

      None
        
         """
         pass


      def Close(self,) -> 'None':
         """
         Description of Close.

Args:



Returns:

      None
        
         """
         pass


      def Attach(self,pdanParent:'PyIDebugApplicationNode') -> 'None':
         """
         Attach a node to its parent.

Args:

      pdanParent(PyIDebugApplicationNode):The parent node.  None is not acceptable.

Returns:

      None
        
         """
         pass


      def Detach(self,) -> 'None':
         """
         Detach a node from its parent.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugApplicationNodeEvents(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def onAddChild(self,prddpChild:'PyIDebugApplicationNode') -> 'None':
         """
         Description of onAddChild.

Args:

      prddpChild(PyIDebugApplicationNode):Description for prddpChild

Returns:

      None
        
         """
         pass


      def onRemoveChild(self,prddpChild:'PyIDebugApplicationNode') -> 'None':
         """
         Description of onRemoveChild.

Args:

      prddpChild(PyIDebugApplicationNode):Description for prddpChild

Returns:

      None
        
         """
         pass


      def onDetach(self,) -> 'None':
         """
         Description of onDetach.

Args:



Returns:

      None
        
         """
         pass


      def onAttach(self,prddpParent:'PyIDebugApplicationNode') -> 'None':
         """
         Description of onAttach.

Args:

      prddpParent(PyIDebugApplicationNode):Description for prddpParent

Returns:

      None
        
         """
         pass


class PyIDebugApplicationThread(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SynchronousCallIntoThread(self,pstcb:'typing.Any',dwParam1:'typing.Any',dwParam2:'typing.Any',dwParam3:'typing.Any') -> 'None':
         """
         Description of SynchronousCallIntoThread.

Args:

      pstcb(typing.Any):Description for pstcb
      dwParam1(typing.Any):Description for dwParam1
      dwParam2(typing.Any):Description for dwParam2
      dwParam3(typing.Any):Description for dwParam3

Returns:

      None
        
         """
         pass


      def QueryIsCurrentThread(self,) -> 'None':
         """
         Description of QueryIsCurrentThread.

Args:



Returns:

      None
        
         """
         pass


      def QueryIsDebuggerThread(self,) -> 'None':
         """
         Description of QueryIsDebuggerThread.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugCodeContext(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDocumentContext(self,) -> 'None':
         """
         Description of GetDocumentContext.

Args:



Returns:

      None
        
         """
         pass


      def SetBreakPoint(self,bps:'typing.Any') -> 'None':
         """
         Description of SetBreakPoint.

Args:

      bps(typing.Any):Description for bps

Returns:

      None
        
         """
         pass


class PyIDebugDocument(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyIDebugDocumentContext(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDocument(self,) -> 'None':
         """
         Description of GetDocument.

Args:



Returns:

      None
        
         """
         pass


      def EnumCodeContexts(self,) -> 'None':
         """
         Description of EnumCodeContexts.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugDocumentHelper(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Init(self,pda:'PyIDebugApplication',pszShortName:'typing.Any',pszLongName:'typing.Any',docAttr:'typing.Any') -> 'None':
         """
         Description of Init.

Args:

      pda(PyIDebugApplication):Description for pda
      pszShortName(typing.Any):Description for pszShortName
      pszLongName(typing.Any):Description for pszLongName
      docAttr(typing.Any):Description for docAttr

Returns:

      None
        
         """
         pass


      def Attach(self,pddhParent:'PyIDebugDocumentHelper') -> 'None':
         """
         Add the document to the doc tree

Args:

      pddhParent(PyIDebugDocumentHelper):Parent item.  If none, this item is top level.

Returns:

      None
        
         """
         pass


      def Detach(self,) -> 'None':
         """
         Description of Detach.

Args:



Returns:

      None
        
         """
         pass


      def AddUnicodeText(self,pszText:'typing.Any') -> 'None':
         """
         Description of AddUnicodeText.

Args:

      pszText(typing.Any):Description for pszText

Returns:

      None
        
         """
         pass


      def AddDBCSText(self,) -> 'None':
         """
         Description of AddDBCSText.

Args:



Returns:

      None
        
         """
         pass


      def SetDebugDocumentHost(self,pddh:'PyIDebugDocumentHost') -> 'None':
         """
         Description of SetDebugDocumentHost.

Args:

      pddh(PyIDebugDocumentHost):Description for pddh

Returns:

      None
        
         """
         pass


      def AddDeferredText(self,cChars:'typing.Any',dwTextStartCookie:'typing.Any') -> 'None':
         """
         Description of AddDeferredText.

Args:

      cChars(typing.Any):Description for cChars
      dwTextStartCookie(typing.Any):Description for dwTextStartCookie

Returns:

      None
        
         """
         pass


      def DefineScriptBlock(self,ulCharOffset:'typing.Any',cChars:'typing.Any',pas:'typing.Any',fScriptlet:'typing.Any') -> 'None':
         """
         Description of DefineScriptBlock.

Args:

      ulCharOffset(typing.Any):Description for ulCharOffset
      cChars(typing.Any):Description for cChars
      pas(typing.Any):Description for pas
      fScriptlet(typing.Any):Description for fScriptlet

Returns:

      None
        
         """
         pass


      def SetDefaultTextAttr(self,staTextAttr:'typing.Any') -> 'None':
         """
         Description of SetDefaultTextAttr.

Args:

      staTextAttr(typing.Any):Description for staTextAttr

Returns:

      None
        
         """
         pass


      def SetTextAttributes(self,ulCharOffset:'typing.Any',obAttr:'typing.Any') -> 'None':
         """
         Description of SetTextAttributes.

Args:

      ulCharOffset(typing.Any):Description for ulCharOffset
      obAttr(typing.Any):A sequence of attributes.

Returns:

      None
        
         """
         pass


      def SetLongName(self,pszLongName:'typing.Any') -> 'None':
         """
         Description of SetLongName.

Args:

      pszLongName(typing.Any):Description for pszLongName

Returns:

      None
        
         """
         pass


      def SetShortName(self,pszShortName:'typing.Any') -> 'None':
         """
         Description of SetShortName.

Args:

      pszShortName(typing.Any):Description for pszShortName

Returns:

      None
        
         """
         pass


      def SetDocumentAttr(self,pszAttributes:'typing.Any') -> 'None':
         """
         Description of SetDocumentAttr.

Args:

      pszAttributes(typing.Any):Description for pszAttributes

Returns:

      None
        
         """
         pass


      def GetDebugApplicationNode(self,) -> 'None':
         """
         Description of GetDebugApplicationNode.

Args:



Returns:

      None
        
         """
         pass


      def GetScriptBlockInfo(self,dwSourceContext:'typing.Any') -> 'None':
         """
         Description of GetScriptBlockInfo.

Args:

      dwSourceContext(typing.Any):Description for dwSourceContext

Returns:

      None
        
         """
         pass


      def CreateDebugDocumentContext(self,iCharPos:'typing.Any',cChars:'typing.Any') -> 'None':
         """
         Description of CreateDebugDocumentContext.

Args:

      iCharPos(typing.Any):Description for iCharPos
      cChars(typing.Any):Description for cChars

Returns:

      None
        
         """
         pass


      def BringDocumentToTop(self,) -> 'None':
         """
         Description of BringDocumentToTop.

Args:



Returns:

      None
        
         """
         pass


      def BringDocumentContextToTop(self,pddc:'PyIDebugDocumentContext') -> 'None':
         """
         Description of BringDocumentContextToTop.

Args:

      pddc(PyIDebugDocumentContext):Description for pddc

Returns:

      None
        
         """
         pass


class PyIDebugDocumentHost(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDeferredText(self,dwTextStartCookie:'typing.Any',cMaxChars:'typing.Any') -> 'None':
         """
         Description of GetDeferredText.

Args:

      dwTextStartCookie(typing.Any):Description for dwTextStartCookie
      cMaxChars(typing.Any):Description for cMaxChars

Returns:

      None
        
         """
         pass


      def GetScriptTextAttributes(self,pstrCode:'typing.Any',pstrDelimiter:'typing.Any',dwFlags:'typing.Any') -> 'None':
         """
         Description of GetScriptTextAttributes.

Args:

      pstrCode(typing.Any):Description for pstrCode
      pstrDelimiter(typing.Any):Description for pstrDelimiter
      dwFlags(typing.Any):Description for dwFlags

Returns:

      None
        
         """
         pass


      def OnCreateDocumentContext(self,) -> 'None':
         """
         Description of OnCreateDocumentContext.

Args:



Returns:

      None
        
         """
         pass


      def GetPathName(self,) -> 'None':
         """
         Description of GetPathName.

Args:



Returns:

      None
        
         """
         pass


      def GetFileName(self,) -> 'None':
         """
         Description of GetFileName.

Args:



Returns:

      None
        
         """
         pass


      def NotifyChanged(self,) -> 'None':
         """
         Description of NotifyChanged.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugDocumentInfo(object):
      """Provides information on a document, which may or may not be instantiated."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetName(self,) -> 'None':
         """
         Returns the specified name for the document.

Args:



Returns:

      None
        
         """
         pass


      def GetDocumentClassId(self,) -> 'PyIID':
         """
         Returns a CLSID describing the document type.

Args:



Returns:

      PyIID
        
         """
         pass


class PyIDebugDocumentProvider(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDocument(self,) -> 'PyIDebugDocument':
         """
         Causes the document to be instantiated if it does 

not already exist.

Args:



Returns:

      PyIDebugDocument
        
         """
         pass


class PyIDebugDocumentText(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDocumentAttributes(self,) -> 'None':
         """
         Description of GetDocumentAttributes.

Args:



Returns:

      None
        
         """
         pass


      def GetSize(self,) -> 'None':
         """
         Description of GetSize.

Args:



Returns:

      None
        
         """
         pass


      def GetPositionOfLine(self,cLineNumber:'typing.Any') -> 'None':
         """
         Description of GetPositionOfLine.

Args:

      cLineNumber(typing.Any):Description for cLineNumber

Returns:

      None
        
         """
         pass


      def GetLineOfPosition(self,cCharacterPosition:'typing.Any') -> 'None':
         """
         Description of GetLineOfPosition.

Args:

      cCharacterPosition(typing.Any):Description for cCharacterPosition

Returns:

      None
        
         """
         pass


      def GetText(self,cCharacterPosition:'typing.Any',cMaxChars:'typing.Any',bWantAttr:'typing.Any'=1) -> 'None':
         """
         Description of GetText.

Args:

      cCharacterPosition(typing.Any):
      cMaxChars(typing.Any):Max chars to return
      bWantAttr(typing.Any):Should the attributes be returned?

Returns:

      None
        
         """
         pass


      def GetPositionOfContext(self,psc:'PyIDebugDocumentContext') -> 'None':
         """
         Description of GetPositionOfContext.

Args:

      psc(PyIDebugDocumentContext):Description for psc

Returns:

      None
        
         """
         pass


      def GetContextOfPosition(self,cCharacterPosition:'typing.Any',cNumChars:'typing.Any') -> 'None':
         """
         Description of GetContextOfPosition.

Args:

      cCharacterPosition(typing.Any):Description for cCharacterPosition
      cNumChars(typing.Any):Description for cNumChars

Returns:

      None
        
         """
         pass


class PyIDebugDocumentTextAuthor(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def InsertText(self,cCharacterPosition:'typing.Any',cNumToInsert:'typing.Any',pcharText:'typing.Any') -> 'None':
         """
         Description of InsertText.

Args:

      cCharacterPosition(typing.Any):Description for cCharacterPosition
      cNumToInsert(typing.Any):Description for cNumToInsert
      pcharText(typing.Any):Description for pcharText

Returns:

      None
        
         """
         pass


      def RemoveText(self,cCharacterPosition:'typing.Any',cNumToRemove:'typing.Any') -> 'None':
         """
         Description of RemoveText.

Args:

      cCharacterPosition(typing.Any):Description for cCharacterPosition
      cNumToRemove(typing.Any):Description for cNumToRemove

Returns:

      None
        
         """
         pass


      def ReplaceText(self,cCharacterPosition:'typing.Any',cNumToReplace:'typing.Any',pcharText:'typing.Any') -> 'None':
         """
         Description of ReplaceText.

Args:

      cCharacterPosition(typing.Any):Description for cCharacterPosition
      cNumToReplace(typing.Any):Description for cNumToReplace
      pcharText(typing.Any):Description for pcharText

Returns:

      None
        
         """
         pass


class PyIDebugDocumentTextEvents(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def onDestroy(self,) -> 'None':
         """
         Description of onDestroy.

Args:



Returns:

      None
        
         """
         pass


      def onInsertText(self,cCharacterPosition:'typing.Any',cNumToInsert:'typing.Any') -> 'None':
         """
         Description of onInsertText.

Args:

      cCharacterPosition(typing.Any):Description for cCharacterPosition
      cNumToInsert(typing.Any):Description for cNumToInsert

Returns:

      None
        
         """
         pass


      def onRemoveText(self,cCharacterPosition:'typing.Any',cNumToRemove:'typing.Any') -> 'None':
         """
         Description of onRemoveText.

Args:

      cCharacterPosition(typing.Any):Description for cCharacterPosition
      cNumToRemove(typing.Any):Description for cNumToRemove

Returns:

      None
        
         """
         pass


      def onReplaceText(self,cCharacterPosition:'typing.Any',cNumToReplace:'typing.Any') -> 'None':
         """
         Description of onReplaceText.

Args:

      cCharacterPosition(typing.Any):Description for cCharacterPosition
      cNumToReplace(typing.Any):Description for cNumToReplace

Returns:

      None
        
         """
         pass


      def onUpdateTextAttributes(self,cCharacterPosition:'typing.Any',cNumToUpdate:'typing.Any') -> 'None':
         """
         Description of onUpdateTextAttributes.

Args:

      cCharacterPosition(typing.Any):Description for cCharacterPosition
      cNumToUpdate(typing.Any):Description for cNumToUpdate

Returns:

      None
        
         """
         pass


      def onUpdateDocumentAttributes(self,textdocattr:'typing.Any') -> 'None':
         """
         Description of onUpdateDocumentAttributes.

Args:

      textdocattr(typing.Any):Description for textdocattr

Returns:

      None
        
         """
         pass


class PyIDebugDocumentTextExternalAuthor(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPathName(self,) -> 'None':
         """
         Description of GetPathName.

Args:



Returns:

      None
        
         """
         pass


      def GetFileName(self,) -> 'None':
         """
         Description of GetFileName.

Args:



Returns:

      None
        
         """
         pass


      def NotifyChanged(self,) -> 'None':
         """
         Description of NotifyChanged.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugExpression(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Start(self,pdecb:'PyIDebugExpressionCallBack') -> 'None':
         """
         Description of Start.

Args:

      pdecb(PyIDebugExpressionCallBack):Description for pdecb

Returns:

      None
        
         """
         pass


      def Abort(self,) -> 'None':
         """
         Description of Abort.

Args:



Returns:

      None
        
         """
         pass


      def QueryIsComplete(self,) -> 'None':
         """
         Description of QueryIsComplete.

Args:



Returns:

      None
        
         """
         pass


      def GetResultAsString(self,) -> 'None':
         """
         Description of GetResultAsString.

Args:



Returns:

      None
        
         """
         pass


      def GetResultAsDebugProperties(self,) -> 'None':
         """
         Description of GetResultAsDebugProperty.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugExpressionCallBack(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def onComplete(self,) -> 'None':
         """
         Description of onComplete.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugExpressionContext(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ParseLanguageText(self,pstrCode:'typing.Any',nRadix:'typing.Any',pstrDelimiter:'typing.Any',dwFlags:'typing.Any') -> 'None':
         """
         Description of ParseLanguageText.

Args:

      pstrCode(typing.Any):Description for pstrCode
      nRadix(typing.Any):Description for nRadix
      pstrDelimiter(typing.Any):Description for pstrDelimiter
      dwFlags(typing.Any):Description for dwFlags

Returns:

      None
        
         """
         pass


      def GetLanguageInfo(self,) -> 'None':
         """
         Description of GetLanguageInfo.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugProperty(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPropertyInfo(self,dwFieldSpec:'typing.Any',nRadix:'typing.Any') -> 'None':
         """
         Description of GetPropertyInfo.

Args:

      dwFieldSpec(typing.Any):Description for dwFieldSpec
      nRadix(typing.Any):Description for nRadix

Returns:

      None
        
         """
         pass


      def GetExtendedInfo(self,) -> 'None':
         """
         Description of GetExtendedInfo.

Args:



Returns:

      None
        
         """
         pass


      def SetValueAsString(self,pszValue:'typing.Any',nRadix:'typing.Any') -> 'None':
         """
         Description of SetValueAsString.

Args:

      pszValue(typing.Any):Description for pszValue
      nRadix(typing.Any):Description for nRadix

Returns:

      None
        
         """
         pass


      def EnumMembers(self,dwFieldSpec:'typing.Any',nRadix:'typing.Any',refiid:'PyIID') -> 'None':
         """
         Description of EnumMembers.

Args:

      dwFieldSpec(typing.Any):Description for dwFieldSpec
      nRadix(typing.Any):Description for nRadix
      refiid(PyIID):Description for refiid

Returns:

      None
        
         """
         pass


      def GetParent(self,) -> 'None':
         """
         Description of GetParent.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugSessionProvider(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def StartDebugSession(self,pda:'PyIRemoteDebugApplication') -> 'None':
         """
         Description of StartDebugSession.

Args:

      pda(PyIRemoteDebugApplication):Description for pda

Returns:

      None
        
         """
         pass


class PyIDebugStackFrame(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetCodeContext(self,) -> 'None':
         """
         Returns the current code context associated with the stack frame.

Args:



Returns:

      None
        
         """
         pass


      def GetDescriptionString(self,fLong:'typing.Any') -> 'typing.Any':
         """
         Returns a short or long textual description of the 

stack frame.

Args:

      fLong(typing.Any):If false, provide only the name of the function associated with the stack frame. When true it may also provide the parameter(s) to the function or whatever else is relevant.

Returns:

      typing.Any
        
         """
         pass


      def GetLanguageString(self,fLong:'typing.Any') -> 'typing.Any':
         """
         Returns a short or long textual description of the 

language.

Args:

      fLong(typing.Any):If False, just the language name should be provided, eg, "Python". If True a full product description may be provided (eg, "Python 1.4 ActiveX Debugging Host")

Returns:

      typing.Any
        
         """
         pass


      def GetThread(self,) -> 'PyIDebugApplicationThread':
         """
         Returns the thread associated with this stack 

frame.

Args:



Returns:

      PyIDebugApplicationThread
        
         """
         pass


class PyIDebugStackFrameSniffer(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def EnumStackFrames(self,) -> 'None':
         """
         Description of EnumStackFrames.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugStackFrameSnifferEx(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def EnumStackFramesEx(self,) -> 'None':
         """
         Description of EnumStackFrames.

Args:



Returns:

      None
        
         """
         pass


class PyIDebugSyncOperation(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetTargetThread(self,) -> 'None':
         """
         Description of GetTargetThread.

Args:



Returns:

      None
        
         """
         pass


      def Execute(self,) -> 'None':
         """
         Description of Execute.

Args:



Returns:

      None
        
         """
         pass


      def InProgressAbort(self,) -> 'None':
         """
         Description of InProgressAbort.

Args:



Returns:

      None
        
         """
         pass


class PyIDefaultExtractIconInit(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetFlags(self,uFlags:'typing.Any') -> 'None':
         """
         Description of SetFlags.

Args:

      uFlags(typing.Any):Description for uFlags

Returns:

      None
        
         """
         pass


      def SetKey(self,hkey:'PyHKEY') -> 'None':
         """
         Description of SetKey.

Args:

      hkey(PyHKEY):Description for hkey

Returns:

      None
        
         """
         pass


      def SetNormalIcon(self,pszFile:'typing.Any',iIcon:'typing.Any') -> 'None':
         """
         Description of SetNormalIcon.

Args:

      pszFile(typing.Any):Description for pszFile
      iIcon(typing.Any):Description for iIcon

Returns:

      None
        
         """
         pass


      def SetOpenIcon(self,pszFile:'typing.Any',iIcon:'typing.Any') -> 'None':
         """
         Description of SetOpenIcon.

Args:

      pszFile(typing.Any):Description for pszFile
      iIcon(typing.Any):Description for iIcon

Returns:

      None
        
         """
         pass


      def SetShortcutIcon(self,pszFile:'typing.Any',iIcon:'typing.Any') -> 'None':
         """
         Description of SetShortcutIcon.

Args:

      pszFile(typing.Any):Description for pszFile
      iIcon(typing.Any):Description for iIcon

Returns:

      None
        
         """
         pass


      def SetDefaultIcon(self,pszFile:'typing.Any',iIcon:'typing.Any') -> 'None':
         """
         Description of SetDefaultIcon.

Args:

      pszFile(typing.Any):Description for pszFile
      iIcon(typing.Any):Description for iIcon

Returns:

      None
        
         """
         pass


class PyIDirectSound(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,guid:'PyIID') -> 'None':
         """
         Description of Initialize.

Args:

      guid(PyIID):Globally unique identifier (GUID) specifying the sound driver to which this DirectSound object binds. Pass None to select the primary sound driver.

Returns:

      None
        
         """
         pass


      def SetCooperativeLevel(self,hwnd:'int',level:'typing.Any') -> 'None':
         """
         The IDirectSound::SetCooperativeLevel method sets the cooperative level 

of the application for this sound device.

Args:

      hwnd(typing.Any):Window handle to the application or None.
      level(typing.Any):Requested priority level. Specify one of the following values:LevelDescriptionDSSCL_NORMALSets the application to a fully cooperative status. Most applications should use this level, because it has the smoothest multitasking and resource-sharing behavior.DSSCL_PRIORITYSets the application to the priority level. Applications with this cooperative level can call the DirectSoundBuffer.setFormat and DirectSound.compact methods.DSSCL_EXCLUSIVESets the application to the exclusive level. When it has the input focus, the application will be the only one audible (sounds from applications with the DSBCAPS_GLOBALFOCUS flag set will be muted). With this level, it also has all the privileges of the DSSCL_PRIORITY level. DirectSound will restore the hardware format, as specified by the most recent call to the DirectSoundBuffer.setFormat method, once the application gains the input focus. (Note that DirectSound will always restore the wave format, no matter what priority level is set.)DSSCL_WRITEPRIMARYThis is the highest priority level. The application has write access to the primary sound buffers. No secondary sound buffers in any application can be played.

Returns:

      None
        
         """
         pass


      def CreateSoundBuffer(self,lpDSCBufferDesc:'PyDSCBUFFERDESC',unk:'typing.Any'=None) -> 'None':
         """
         The IDirectSound::CreateSoundBuffer method creates a DirectSoundBuffer 

object to hold a sequence of audio samples.

Args:

      lpDSCBufferDesc(PyDSCBUFFERDESC):a DSBUFFERDESC structure containing values for the sound buffer being created.
      unk(typing.Any):The IUnknown for COM aggregation.

Returns:

      None
        
         """
         pass


      def GetCaps(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def Compact(self,) -> 'None':
         """
         The Compact method moves the unused portions of on-board sound memory, if any, to a 

contiguous block so that the largest portion of free memory will be available.

Args:



Returns:

      None
        
         """
         pass


class PyIDirectSoundBuffer(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,) -> 'None':
         """
         Description of Initialize.

Args:



Returns:

      None
        
         """
         pass


      def GetStatus(self,) -> 'None':
         """
         Retrieves the current status of the sound buffer.

Args:



Returns:

      None
        
         """
         pass


      def GetCaps(self,) -> 'None':
         """
         Retrieves the capabilities of the DirectSoundBuffer object as a DSBCAPS 

object.

Args:



Returns:

      None
        
         """
         pass


      def Restore(self,) -> 'None':
         """
         Restores the memory allocation for a lost sound buffer for the specified 

DirectSoundBuffer object.

Args:



Returns:

      None
        
         """
         pass


      def GetCurrentPosition(self,) -> 'None':
         """
         Description of GetCurrentPosition.

Args:



Returns:

      None
        
         """
         pass


      def Play(self,) -> 'None':
         """
         Description of Play.

Args:



Returns:

      None
        
         """
         pass


      def SetCurrentPosition(self,) -> 'None':
         """
         Description of SetCurrentPosition.

Args:



Returns:

      None
        
         """
         pass


      def Stop(self,) -> 'None':
         """
         Description of Stop.

Args:



Returns:

      None
        
         """
         pass


      def GetFrequency(self,) -> 'None':
         """
         Description of GetFrequency.

Args:



Returns:

      None
        
         """
         pass


      def GetPan(self,) -> 'None':
         """
         Description of GetPan.

Args:



Returns:

      None
        
         """
         pass


      def GetVolume(self,) -> 'None':
         """
         Description of GetVolume.

Args:



Returns:

      None
        
         """
         pass


      def SetFrequency(self,) -> 'None':
         """
         Description of SetFrequency.

Args:



Returns:

      None
        
         """
         pass


      def SetPan(self,) -> 'None':
         """
         Description of SetPan.

Args:



Returns:

      None
        
         """
         pass


      def SetVolume(self,) -> 'None':
         """
         Description of SetVolume.

Args:



Returns:

      None
        
         """
         pass


class PyIDirectSoundCapture(object):
      """The methods of the IDirectSoundCapture interface are used to create sound capture 

buffers."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,) -> 'None':
         """
         Not normally called directly. Use DirectSoundCaptureCreate instead.

Args:



Returns:

      None
        
         """
         pass


      def GetCaps(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


class PyIDirectSoundCaptureBuffer(object):
      """The methods of the IDirectSoundCaptureBuffer interface are used to manipulate 

sound capture buffers."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,) -> 'None':
         """
         Not normally used. Used IDirectSoundCapture.CreateCaptureBuffer 

instead.

Args:



Returns:

      None
        
         """
         pass


      def GetStatus(self,) -> 'None':
         """
         Retrieves the current status of the sound capture buffer.

Args:



Returns:

      None
        
         """
         pass


      def GetCurrentPosition(self,) -> 'None':
         """
         Returns a tuple of the current capture and read position in 

the buffer. The capture position is ahead of the read position. These positions are not always identical due to 

possible buffering of captured data either on the physical device or in the host. The data after the read position up 

to and including the capture position is not necessarily valid data.

Args:



Returns:

      None
        
         """
         pass


      def Stop(self,) -> 'None':
         """
         The IDirectSoundCaptureBuffer::Stop method puts the capture buffer into 

the "stop" state and stops capturing data. If the capture buffer is already in the stop state then the method has no 

effect.

Args:



Returns:

      None
        
         """
         pass


class PyIDirectSoundNotify(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyIDirectoryObject(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetObjectInformation(self,) -> 'PyADS_OBJECT_INFO':
         """
         None

Args:



Returns:

      PyADS_OBJECT_INFO
        
         """
         pass


      def GetObjectAttributes(self,names:'typing.Tuple[str, ...]') -> 'typing.Tuple[PyADS_ATTR_INFO, ...]':
         """
         None

Args:

      names(typing.Tuple[str, ...]):

Returns:

      typing.Tuple[PyADS_ATTR_INFO, ...]
        
         """
         pass


      def SetObjectAttributes(self,attrs:'typing.Tuple[PyADS_ATTR_INFO, ...]') -> 'typing.Any':
         """
         None

Args:

      attrs(typing.Tuple[PyADS_ATTR_INFO, ...]):The attributes to set

Returns:

      typing.Any
        
         """
         pass


      def CreateDSObject(self,rdn:'str',attrs:'typing.Tuple[PyADS_ATTR_INFO, ...]') -> 'PyIDispatch':
         """
         None

Args:

      rdn(str):The relative distinguished name (relative path) of the object to be created.
      attrs(typing.Tuple[PyADS_ATTR_INFO, ...]):The attributes to set.

Returns:

      PyIDispatch
        
         """
         pass


      def DeleteDSObject(self,rdn:'str') -> 'None':
         """
         Deletes a leaf object in a directory tree

Args:

      rdn(str):The relative distinguished name (relative path) of the object to be deleted.

Returns:

      None
        
         """
         pass


class PyIDirectorySearch(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetSearchPreference(self,prefs:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         None

Args:

      prefs(typing.Any):Return ValueThe result is the hresult of the call, and a list of integer status codes for each of the preferences set.

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]:Return ValueThe result is the hresult of the call, and a list of integer status 

codes for each of the preferences set.

        
         """
         pass


      def ExecuteSearch(self,_filter:'str',attrNames:'typing.List[str]') -> 'typing.Any':
         """
         None

Args:

      _filter(str):
      attrNames(typing.List[str]):Return ValueThe result is an integer search handle.  PyIDirectorySearch::CloseSearchHandle should be called to close the handle.

Returns:

      typing.Any:Return ValueThe result is an integer search handle.  PyIDirectorySearch::CloseSearchHandle 

should be called to close the handle.

        
         """
         pass


      def GetNextRow(self,handle:'typing.Any') -> 'typing.Any':
         """
         None

Args:

      handle(typing.Any):Return ValueThe result is the HRESULT from the call - no exceptions are thrown

Returns:

      typing.Any:Return ValueThe result is the HRESULT from the call - no exceptions are thrown

        
         """
         pass


      def GetFirstRow(self,handle:'typing.Any') -> 'typing.Any':
         """
         None

Args:

      handle(typing.Any):Return ValueThe result is the HRESULT from the call - no exceptions are thrown

Returns:

      typing.Any:Return ValueThe result is the HRESULT from the call - no exceptions are thrown

        
         """
         pass


      def GetPreviousRow(self,handle:'typing.Any') -> 'typing.Any':
         """
         None

Args:

      handle(typing.Any):Return ValueThe result is the HRESULT from the call - no exceptions are thrown

Returns:

      typing.Any:Return ValueThe result is the HRESULT from the call - no exceptions are thrown

        
         """
         pass


      def CloseSearchHandle(self,handle:'typing.Any') -> 'None':
         """
         Closes a previously opened search handle.

Args:

      handle(typing.Any):

Returns:

      None
        
         """
         pass


      def AdandonSearch(self,handle:'typing.Any') -> 'None':
         """
         None

Args:

      handle(typing.Any):

Returns:

      None
        
         """
         pass


      def GetColumn(self,handle:'typing.Any',name:'str') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         None

Args:

      handle(typing.Any):Handle to a search
      name(str):The column name to fetch

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetNextColumnName(self,) -> 'None':
         """
         None

Args:



Returns:

      None:PyIDirectorySearch.GetNextColumnName
GetNextColumnName()
Return ValueReturns None when the underlying ADSI function return S_ADS_NOMORE_COLUMNS.

        
         """
         pass


class PyIDispatch(object):
      """A OLE automation client object."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Invoke(self,dispid:'typing.Any',lcid:'typing.Any',flags:'typing.Any',bResultWanted:'typing.Any',arg:'typing.Tuple[typing.Any, ...]') -> 'typing.Any':
         """
         Invokes a DISPID, using the passed arguments.

Args:

      dispid(typing.Any):The dispid to use.  Typically this value will come from PyIDispatch::GetIDsOfNames or from a type library.
      lcid(typing.Any):The locale id to use.
      flags(typing.Any):The flags for the call.  The following flags can be used.FlagDescriptionDISPATCH_METHODThe member is invoked as a method. If a property has the same name, both this and the DISPATCH_PROPERTYGET flag may be set.DISPATCH_PROPERTYGETThe member is retrieved as a property or data member.DISPATCH_PROPERTYPUTThe member is changed as a property or data member.DISPATCH_PROPERTYPUTREFThe member is changed by a reference assignment, rather than a value assignment. This flag is valid only when the property accepts a reference to an object.
      bResultWanted(typing.Any):Indicates if the result of the call should be requested.
      arg(typing.Tuple[typing.Any, ...]):The parameters to pass.Return ValueIf the bResultWanted parameter is False, then the result will be None. Otherwise, the result is determined by the COM object itself (and may still be None)

Returns:

      typing.Any:The parameters to pass.Return ValueIf the bResultWanted parameter is False, then the result will be None. 

Otherwise, the result is determined by the COM object itself (and may still be None)

        
         """
         pass


      def InvokeTypes(self,dispid:'typing.Any',lcid:'typing.Any',wFlags:'typing.Any',resultTypeDesc:'typing.Any',typeDescs:'typing.Tuple[typing.Any, ...]',args:'typing.Tuple[typing.Any, ...]') -> 'typing.Any':
         """
         Invokes a DISPID, using the passed arguments and type descriptions.

Args:

      dispid(typing.Any):The dispid to use.  Please see PyIDispatch::Invoke.
      lcid(typing.Any):The locale ID.  Please see PyIDispatch::Invoke.
      wFlags(typing.Any):Flags for the call.  Please see PyIDispatch::Invoke.
      resultTypeDesc(typing.Any):A tuple describing the type of the result.  See the comments for more information.
      typeDescs(typing.Tuple[typing.Any, ...]):A sequence of tuples describing the types of the parameters for the function.  See the comments for more information.
      args(typing.Tuple[typing.Any, ...]):The args to the function.CommentsThe Microsoft documentation for IDispatch should be used for all params except 'resultTypeDesc' and 'typeDescs'. 'resultTypeDesc' describes the return value of the function, and is a tuple of (type_id, flags). 'typeDescs' describes the type of each parameters, and is a list of the same (type_id, flags) tuple.itemDescriptiontype_idA valid "variant type" constant (eg, VT_I4 | VT_ARRAY, VT_DATE, etc - see VARIANT at MSDN).flagsOne of the PARAMFLAG constants (eg, PARAMFLAG_FIN, PARAMFLAG_FOUT etc - see PARAMFLAG at MSDN).ExampleAn example from the makepy generated file for Wordclass Cells(DispatchBaseClass):...    def SetWidth(self, ColumnWidth=..., RulerStyle=...):	return self._oleobj_.InvokeTypes(202, LCID, 1, (24, 0), ((4, 1), (3, 1)),...)The interesting bits areresultTypeDesc: (24, 0) - (VT_VOID, &ltno flags&gt)typeDescs: ((4, 1), (3, 1)) - ((VT_R4, PARAMFLAG_FIN), (VT_I4, PARAMFLAG_FIN))So, in this example, the function returns no value and takes 2 "in" params - ColumnWidth is a float, and RulerStule is an int.

Returns:

      typing.Any
        
         """
         pass


      def GetIDsOfNames(self,name:'str',arg:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Union[typing.Any]]':
         """
         Get the DISPID for the passed names.

Args:

      name(str):A name to query forAlternative Parameters
      arg(typing.Any):A sequence of string names to queryCommentsCurrently the LCID can not be specified, and  LOCALE_SYSTEM_DEFAULT is used.Return ValueIf the first parameter is a sequence, the result will be a tuple of integers for each name in the sequence.  If the first parameter is a single string, the result is a single integer with the ID of requested item.

Returns:

      typing.Tuple[typing.Any, typing.Union[typing.Any]]:A sequence of string names to query
Comments

Currently the LCID can not be specified, and  LOCALE_SYSTEM_DEFAULT is used.
Return ValueIf the first parameter is a sequence, the result will be a tuple of integers 

for each name in the sequence.  If the first parameter is a single string, the result 

is a single integer with the ID of requested item.

        
         """
         pass


      def GetTypeInfo(self,locale:'typing.Any',index:'typing.Any'=0) -> 'PyITypeInfo':
         """
         Get type information for the object.

Args:

      locale(typing.Any):The locale to use.
      index(typing.Any):The index of the typelibrary to fetch. Note that these params are reversed from the win32 call.

Returns:

      PyITypeInfo
        
         """
         pass


      def GetTypeInfoCount(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIDispatchEx(object):
      """A OLE automation client object that uses the IDispatchEx scripting interface.."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDispID(self,name:'str',fdex:'typing.Any') -> 'typing.Any':
         """
         Returns the member id for a name

Args:

      name(str):Passed in name to be mapped
      fdex(typing.Any):Determines the options for obtaining the member identifier. This can be a combination of the fdex* constants:

Returns:

      typing.Any
        
         """
         pass


      def InvokeEx(self,dispid:'typing.Any',lcid:'typing.Any',flags:'typing.Any',args:'typing.List[typing.Any]',types:'typing.List[typing.Any]'=None,returnDesc:'typing.Any'=1,serviceProvider:'PyIServiceProvider'=None) -> 'typing.Any':
         """
         None

Args:

      dispid(typing.Any):
      lcid(typing.Any):
      flags(typing.Any):
      args(typing.List[typing.Any]):The arguments.
      types(typing.List[typing.Any]):A tuple of type description object, or None if type descriptions are not available.
      returnDesc(typing.Any):If types==None, should be a BOOL indicating if the result is needed.  If types is a tuple, then should a be type description.
      serviceProvider(PyIServiceProvider):A service provider object supplied by the caller which allows the object to obtain services from the caller. Can be None.

Returns:

      typing.Any
        
         """
         pass


      def DeleteMemberByName(self,name:'str',fdex:'typing.Any') -> 'None':
         """
         None

Args:

      name(str):Passed in name to be mapped
      fdex(typing.Any):Determines the options

Returns:

      None
        
         """
         pass


      def DeleteMemberByDispID(self,dispid:'typing.Any') -> 'None':
         """
         None

Args:

      dispid(typing.Any):

Returns:

      None
        
         """
         pass


      def GetMemberProperties(self,dispid:'typing.Any',fdex:'typing.Any') -> 'typing.Any':
         """
         Returns mask of fdex* flags describing a member

Args:

      dispid(typing.Any):The member id
      fdex(typing.Any):fdex* flags specifying which properties to return

Returns:

      typing.Any
        
         """
         pass


      def GetMemberName(self,dispid:'typing.Any') -> 'typing.Any':
         """
         Returns the name associated with a member id

Args:

      dispid(typing.Any):The member id

Returns:

      typing.Any
        
         """
         pass


      def GetNextDispID(self,fdex:'typing.Any',dispid:'typing.Any') -> 'typing.Any':
         """
         Enumerates member ids.

Args:

      fdex(typing.Any):Determines the options
      dispid(typing.Any):Current member, or DISPID_STARTENUM to begin enumeration. GetNextDispID will retrieve the item in the enumeration after this one.

Returns:

      typing.Any
        
         """
         pass


class PyIDisplayItem(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyIDocHostUIHandler(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ShowContextMenu(self,dwID:'typing.Any',pt:'typing.Tuple[typing.Any, typing.Any]',pcmdtReserved:'PyIUnknown',pdispReserved:'PyIDispatch') -> 'None':
         """
         Description of ShowContextMenu.

Args:

      dwID(typing.Any):Description for dwID
      pt(typing.Tuple[typing.Any, typing.Any]):Description for ppt
      pcmdtReserved(PyIUnknown):Description for pcmdtReserved
      pdispReserved(PyIDispatch):Description for pdispReserved

Returns:

      None
        
         """
         pass


      def GetHostInfo(self,) -> 'None':
         """
         Description of GetHostInfo.

Args:



Returns:

      None
        
         """
         pass


      def ShowUI(self,dwID:'typing.Any',pActiveObject:'PyIOleInPlaceActiveObject',pCommandTarget:'PyIOleCommandTarget',pFrame:'PyIOleInPlaceFrame',pDoc:'PyIOleInPlaceUIWindow') -> 'None':
         """
         Description of ShowUI.

Args:

      dwID(typing.Any):Description for dwID
      pActiveObject(PyIOleInPlaceActiveObject):Description for pActiveObject
      pCommandTarget(PyIOleCommandTarget):Description for pCommandTarget
      pFrame(PyIOleInPlaceFrame):Description for pFrame
      pDoc(PyIOleInPlaceUIWindow):Description for pDoc

Returns:

      None
        
         """
         pass


      def HideUI(self,) -> 'None':
         """
         Description of HideUI.

Args:



Returns:

      None
        
         """
         pass


      def UpdateUI(self,) -> 'None':
         """
         Description of UpdateUI.

Args:



Returns:

      None
        
         """
         pass


      def EnableModeless(self,fEnable:'typing.Any') -> 'None':
         """
         Description of EnableModeless.

Args:

      fEnable(typing.Any):Description for fEnable

Returns:

      None
        
         """
         pass


      def OnDocWindowActivate(self,fActivate:'typing.Any') -> 'None':
         """
         Description of OnDocWindowActivate.

Args:

      fActivate(typing.Any):Description for fActivate

Returns:

      None
        
         """
         pass


      def OnFrameWindowActivate(self,fActivate:'typing.Any') -> 'None':
         """
         Description of OnFrameWindowActivate.

Args:

      fActivate(typing.Any):Description for fActivate

Returns:

      None
        
         """
         pass


      def ResizeBorder(self,prcBorder:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',pUIWindow:'PyIOleInPlaceUIWindow',fRameWindow:'typing.Any') -> 'None':
         """
         Description of ResizeBorder.

Args:

      prcBorder(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Description for prcBorder
      pUIWindow(PyIOleInPlaceUIWindow):Description for pUIWindow
      fRameWindow(typing.Any):Description for fRameWindow

Returns:

      None
        
         """
         pass


      def TranslateAccelerator(self,lpMsg:'typing.Any',pguidCmdGroup:'PyIID',nCmdID:'typing.Any') -> 'None':
         """
         Description of TranslateAccelerator.

Args:

      lpMsg(typing.Any):Description for lpMsg
      pguidCmdGroup(PyIID):Description for pguidCmdGroup
      nCmdID(typing.Any):Description for nCmdID

Returns:

      None
        
         """
         pass


      def GetOptionKeyPath(self,dw:'typing.Any') -> 'None':
         """
         Description of GetOptionKeyPath.

Args:

      dw(typing.Any):Description for dw

Returns:

      None
        
         """
         pass


      def GetDropTarget(self,pDropTarget:'PyIDropTarget') -> 'None':
         """
         Description of GetDropTarget.

Args:

      pDropTarget(PyIDropTarget):Description for pDropTarget

Returns:

      None
        
         """
         pass


      def GetExternal(self,) -> 'None':
         """
         Description of GetExternal.

Args:



Returns:

      None
        
         """
         pass


      def TranslateUrl(self,dwTranslate:'typing.Any',pchURLIn:'typing.Any') -> 'None':
         """
         Description of TranslateUrl.

Args:

      dwTranslate(typing.Any):Description for dwTranslate
      pchURLIn(typing.Any):Description for pchURLIn

Returns:

      None
        
         """
         pass


      def FilterDataObject(self,pDO:'PyIDataObject') -> 'None':
         """
         Description of FilterDataObject.

Args:

      pDO(PyIDataObject):Description for pDO

Returns:

      None
        
         """
         pass


class PyIDropSource(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def QueryContinueDrag(self,fEscapePressed:'typing.Any',grfKeyState:'typing.Any') -> 'None':
         """
         Description of QueryContinueDrag.

Args:

      fEscapePressed(typing.Any):Description for fEscapePressed
      grfKeyState(typing.Any):Description for grfKeyState

Returns:

      None
        
         """
         pass


      def GiveFeedback(self,dwEffect:'typing.Any') -> 'None':
         """
         Description of GiveFeedback.

Args:

      dwEffect(typing.Any):Description for dwEffect

Returns:

      None
        
         """
         pass


class PyIDropTarget(object):
      """Interface that acts as a target of OLE drag and drop operations"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def DragEnter(self,pDataObj:'PyIDataObject',grfKeyState:'typing.Any',pt:'typing.Tuple[typing.Any, typing.Any]',pdwEffect:'typing.Any') -> 'typing.Any':
         """
         Called when an object is initially dragged into a window

Args:

      pDataObj(PyIDataObject):IDataObject interface that contains the object being dragged
      grfKeyState(typing.Any):Combination of win32con.MK_* flags containing keyboard modifier state
      pt(typing.Tuple[typing.Any, typing.Any]):(x,y) Screen coordinates of cursor
      pdwEffect(typing.Any):shellcon.DROPEFFECT_* valueReturn ValueYour implementation of this function should return a shellcon.DROPEFFECT_* value indicating if the object can be accepted

Returns:

      typing.Any:shellcon.DROPEFFECT_* valueReturn ValueYour implementation of this function should return a shellcon.DROPEFFECT_* value indicating if the object can 

be accepted

        
         """
         pass


      def DragOver(self,grfKeyState:'typing.Any',pt:'typing.Tuple[typing.Any, typing.Any]',pdwEffect:'typing.Any') -> 'typing.Any':
         """
         Called as the dragged object moves over the window

Args:

      grfKeyState(typing.Any):Combination of win32con.MK_* flags containing keyboard modifier state
      pt(typing.Tuple[typing.Any, typing.Any]):(x,y) Screen coordinates of cursor
      pdwEffect(typing.Any):shellcon.DROPEFFECT_* valueReturn ValueYour implementation of this function should return a shellcon.DROPEFFECT_* value indicating if the object can be accepted at the current position

Returns:

      typing.Any:shellcon.DROPEFFECT_* valueReturn ValueYour implementation of this function should return a shellcon.DROPEFFECT_* value indicating if the 

object can be accepted at the current position

        
         """
         pass


      def DragLeave(self,) -> 'None':
         """
         Called as the object is dragged back out of the window

Args:



Returns:

      None
        
         """
         pass


      def Drop(self,pDataObj:'PyIDataObject',grfKeyState:'typing.Any',pt:'typing.Tuple[typing.Any, typing.Any]',dwEffect:'typing.Any') -> 'typing.Any':
         """
         Called when the object is dropped onto the window

Args:

      pDataObj(PyIDataObject):IDataObject interface containing the dropped object
      grfKeyState(typing.Any):Combination of win32con.MK_* flags containing keyboard modifier state
      pt(typing.Tuple[typing.Any, typing.Any]):(x,y) Screen coordinates of cursor
      dwEffect(typing.Any):shellcon.DROPEFFECT_* valueReturn ValueYour implementation of this function should return one of the shellcon.DROPEFFECT_* values

Returns:

      typing.Any:shellcon.DROPEFFECT_* valueReturn ValueYour implementation of this function should return one of the shellcon.DROPEFFECT_* values

        
         """
         pass


class PyIDropTargetHelper(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def DragEnter(self,hwnd:'int',pDataObj:'PyIDataObject',pt:'typing.Tuple[typing.Any, typing.Any]',dwEffect:'typing.Any') -> 'None':
         """
         Description of DragEnter.

Args:

      hwnd(int):Handle to target window
      pDataObj(PyIDataObject):Object that is dragged onto the window
      pt(typing.Tuple[typing.Any, typing.Any]):Coordinates where drag operation entered the window
      dwEffect(typing.Any):One of shellcon.DROPEFFECT_* values

Returns:

      None
        
         """
         pass


      def DragOver(self,hwnd:'int',pt:'typing.Tuple[typing.Any, typing.Any]',pdwEffect:'typing.Any') -> 'None':
         """
         Description of DragOver.

Args:

      hwnd(typing.Any):
      pt(typing.Tuple[typing.Any, typing.Any]):Description for pt
      pdwEffect(typing.Any):Description for pdwEffect

Returns:

      None
        
         """
         pass


      def DragLeave(self,) -> 'None':
         """
         Description of DragLeave.

Args:



Returns:

      None
        
         """
         pass


      def Drop(self,pDataObj:'PyIDataObject',pt:'typing.Tuple[typing.Any, typing.Any]',dwEffect:'typing.Any') -> 'None':
         """
         Description of Drop.

Args:

      pDataObj(PyIDataObject):Description for pDataObj
      pt(typing.Tuple[typing.Any, typing.Any]):Description for pt
      dwEffect(typing.Any):Description for dwEffect

Returns:

      None
        
         """
         pass


class PyIDsObjectPicker(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,targetComputer:'str',scopeInfos:'PyDSOP_SCOPE_INIT_INFOs',options:'typing.Any'=0,attrNames:'typing.List[str]'=None) -> 'None':
         """
         Initializes the IDsObjectPicker interface with information about the scopes, filters, and options used by the object picker dialog box.

Args:

      targetComputer(str):
      scopeInfos(PyDSOP_SCOPE_INIT_INFOs):
      options(typing.Any):
      attrNames(typing.List[str]):

Returns:

      None
        
         """
         pass


      def InvokeDialog(self,hwnd:'int') -> 'PyIDataObject':
         """
         Displays a modal object picker dialog box and returns the user's selections.

Args:

      hwnd(typing.Any):

Returns:

      PyIDataObject
        
         """
         pass


class PyIEmptyVolumeCache(object):
      """Used for cleaning up temporary file ("disk cleanup")"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyIEmptyVolumeCache2(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyIEmptyVolumeCacheCallBack(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ScanProgress(self,dwlSpaceUsed:'typing.Any',dwFlags:'typing.Any',pcwszStatus:'typing.Any') -> 'None':
         """
         Description of ScanProgress.

Args:

      dwlSpaceUsed(typing.Any):Description for dwlSpaceUsed
      dwFlags(typing.Any):Description for dwFlags
      pcwszStatus(typing.Any):Description for pcwszStatus

Returns:

      None
        
         """
         pass


      def PurgeProgress(self,dwlSpaceFreed:'typing.Any',spaceFreed:'typing.Any',spaceToFree:'typing.Any',flags:'typing.Any',status:'typing.Any') -> 'None':
         """
         Description of PurgeProgress.

Args:

      dwlSpaceFreed(typing.Any):Description for dwlSpaceFreed
      spaceFreed(typing.Any):
      spaceToFree(typing.Any):
      flags(typing.Any):
      status(typing.Any):

Returns:

      None
        
         """
         pass


class PyIEnumCATEGORYINFO(object):
      """A Python interface to IEnumCATEGORYINFO"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Tuple[typing.Tuple[PyIID, typing.Any, str], ...]':
         """
         Retrieves a specified number of items in the 

enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.Return ValueThe result is a tuple of (IID object, LCID, string description) tuples, one for each element returned.

Returns:

      typing.Tuple[typing.Tuple[PyIID, typing.Any, str], ...]:Number of items to retrieve.
Return ValueThe result is a tuple of (IID object, LCID, string description) tuples, 

one for each element returned.

        
         """
         pass


      def Skip(self,num:'typing.Any') -> 'None':
         """
         Skips over the next specified elementes.

Args:

      num(typing.Any):The number of elements being requested.

Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumCATEGORYINFO':
         """
         Creates another enumerator that contains the same 

enumeration state as the current one

Args:



Returns:

      PyIEnumCATEGORYINFO
        
         """
         pass


class PyIEnumConnectionPoints(object):
      """A Python interface to IEnumConnectionPoints"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Tuple[PyIConnectionPoint, ...]':
         """
         Retrieves a specified number of items in the 

enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Tuple[PyIConnectionPoint, ...]
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumConnectionPoints':
         """
         Creates another enumerator that contains the same 

enumeration state as the current one

Args:



Returns:

      PyIEnumConnectionPoints
        
         """
         pass


class PyIEnumConnections(object):
      """A Python interface to IEnumConnections"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumConnections':
         """
         Creates another enumerator that contains the same 

enumeration state as the current one

Args:



Returns:

      PyIEnumConnections
        
         """
         pass


class PyIEnumContextProps(object):
      """A Python interface to IEnumContextProps"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Tuple[typing.Tuple[PyIID, typing.Any, PyIUnknown], ...]':
         """
         Retrieves a specified number of items in 

the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.Return ValueReturns a tuple of 3-tuples representing ContextProperty structs:  First item is GUID identifying the property, second is Flags (reserved), third is the interface set as the property value

Returns:

      typing.Tuple[typing.Tuple[PyIID, typing.Any, PyIUnknown], ...]:Number of items to retrieve.
Return ValueReturns a tuple of 3-tuples representing ContextProperty structs: 

 First item is GUID identifying the property, second is Flags (reserved), third is the interface set as the 

property value

        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumContextProps':
         """
         Creates another enumerator that contains the same 

enumeration state as the current one

Args:



Returns:

      PyIEnumContextProps
        
         """
         pass


class PyIEnumDebugApplicationNodes(object):
      """A Python interface to IEnumDebugApplicationNodes"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumDebugApplicationNodes':
         """
         Creates another enumerator that 

contains the same enumeration state as the current one

Args:



Returns:

      PyIEnumDebugApplicationNodes
        
         """
         pass


class PyIEnumDebugCodeContexts(object):
      """A Python interface to IEnumDebugCodeContexts"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumDebugCodeContexts':
         """
         Creates another enumerator that contains the 

same enumeration state as the current one

Args:



Returns:

      PyIEnumDebugCodeContexts
        
         """
         pass


class PyIEnumDebugExpressionContexts(object):
      """A Python interface to IEnumDebugExpressionContexts"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration 

sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumDebugExpressionContexts':
         """
         Creates another enumerator that 

contains the same enumeration state as the current one

Args:



Returns:

      PyIEnumDebugExpressionContexts
        
         """
         pass


class PyIEnumDebugPropertyInfo(object):
      """A Python interface to IEnumDebugPropertyInfo"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumDebugPropertyInfo':
         """
         Creates another enumerator that contains the 

same enumeration state as the current one

Args:



Returns:

      PyIEnumDebugPropertyInfo
        
         """
         pass


      def GetCount(self,) -> 'typing.Any':
         """
         Obtains the number of items

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIEnumDebugStackFrames(object):
      """A Python interface to IEnumDebugStackFrames"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumDebugStackFrames':
         """
         Creates another enumerator that contains the same 

enumeration state as the current one

Args:



Returns:

      PyIEnumDebugStackFrames
        
         """
         pass


class PyIEnumExplorerCommand(object):
      """A Python interface to IEnumExplorerCommand"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumExplorerCommand':
         """
         Creates another enumerator that contains the same 

enumeration state as the current one

Args:



Returns:

      PyIEnumExplorerCommand
        
         """
         pass


class PyIEnumFORMATETC(object):
      """A Python interface to IEnumFORMATETC"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumFORMATETC':
         """
         Creates another enumerator that contains the same enumeration 

state as the current one

Args:



Returns:

      PyIEnumFORMATETC
        
         """
         pass


class PyIEnumGUID(object):
      """A Python interface to IEnumGUID"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Tuple[PyIID, ...]':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.Return ValueThe result is a tuple of PyIID objects, one for each element returned.  Note that if zero elements are returned, it is not considered an error condition - an empty tuple is simply returned.

Returns:

      typing.Tuple[PyIID, ...]:Number of items to retrieve.
Return ValueThe result is a tuple of PyIID objects, 

one for each element returned.  Note that if zero elements are returned, it is not considered 

an error condition - an empty tuple is simply returned.

        
         """
         pass


      def Skip(self,num:'typing.Any') -> 'None':
         """
         Skips over the next specified elementes.

Args:

      num(typing.Any):The number of elements being requested.

Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumGUID':
         """
         Creates another enumerator that contains the same enumeration state as 

the current one

Args:



Returns:

      PyIEnumGUID
        
         """
         pass


class PyIEnumIDList(object):
      """A Python interface to IEnumIDList"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumIDList':
         """
         Creates another enumerator that contains the same enumeration state 

as the current one

Args:



Returns:

      PyIEnumIDList
        
         """
         pass


class PyIEnumMoniker(object):
      """A Python interface to IEnumMoniker"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'PyIMoniker':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.Return ValueThe result is a tuple of PyIID objects, one for each element returned.  Note that if zero elements are returned, it is not considered an error condition - an empty tuple is simply returned.

Returns:

      PyIMoniker:Number of items to retrieve.
Return ValueThe result is a tuple of PyIID objects, 

one for each element returned.  Note that if zero elements are returned, it is not considered 

an error condition - an empty tuple is simply returned.

        
         """
         pass


      def Skip(self,num:'typing.Any') -> 'None':
         """
         Skips over the next specified elementes.

Args:

      num(typing.Any):The number of elements being requested.

Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumMoniker':
         """
         Creates another enumerator that contains the same enumeration state 

as the current one

Args:



Returns:

      PyIEnumMoniker
        
         """
         pass


class PyIEnumObjects(object):
      """Iterates through a number of arbitrary interfaces"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,riid:'PyIID',num:'typing.Any'=1) -> 'typing.Tuple[PyIUnknown, ...]':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      riid(PyIID):The interfaces to return
      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Tuple[PyIUnknown, ...]
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumObjects':
         """
         Creates another enumerator that contains the same enumeration state 

as the current one

Args:



Returns:

      PyIEnumObjects
        
         """
         pass


class PyIEnumRemoteDebugApplicationThreads(object):
      """A Python interface to IEnumRemoteDebugApplicationThreads"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration 

sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumRemoteDebugApplicationThreads':
         """
         Creates another 

enumerator that contains the same enumeration state as the current one

Args:



Returns:

      PyIEnumRemoteDebugApplicationThreads
        
         """
         pass


class PyIEnumRemoteDebugApplications(object):
      """A Python interface to IEnumRemoteDebugApplications"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration 

sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumRemoteDebugApplications':
         """
         Creates another enumerator that 

contains the same enumeration state as the current one

Args:



Returns:

      PyIEnumRemoteDebugApplications
        
         """
         pass


class PyIEnumResources(object):
      """A Python interface to IEnumResources"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumResources':
         """
         Creates another enumerator that contains the same enumeration 

state as the current one

Args:



Returns:

      PyIEnumResources
        
         """
         pass


class PyIEnumSTATPROPSETSTG(object):
      """A Python interface to IEnumSTATPROPSETSTG"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumSTATPROPSETSTG':
         """
         Creates another enumerator that contains the same 

enumeration state as the current one

Args:



Returns:

      PyIEnumSTATPROPSETSTG
        
         """
         pass


class PyIEnumSTATPROPSTG(object):
      """A Python interface to IEnumSTATPROPSTG"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Any':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumSTATPROPSTG':
         """
         Creates another enumerator that contains the same 

enumeration state as the current one

Args:



Returns:

      PyIEnumSTATPROPSTG
        
         """
         pass


class PyIEnumSTATSTG(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Tuple[STATSTG, ...]':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Tuple[STATSTG, ...]
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumSTATSTG':
         """
         Creates another enumerator that contains the same enumeration state 

as the current one

Args:



Returns:

      PyIEnumSTATSTG
        
         """
         pass


class PyIEnumShellItems(object):
      """A Python interface to IEnumShellItems"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Tuple[PyIShellItem, ...]':
         """
         Retrieves a specified number of items in the enumeration 

sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Tuple[PyIShellItem, ...]
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumShellItems':
         """
         Creates another enumerator that contains the same enumeration 

state as the current one

Args:



Returns:

      PyIEnumShellItems
        
         """
         pass


class PyIEnumString(object):
      """An enumerator interface to list strings"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Next(self,num:'typing.Any'=1) -> 'typing.Tuple[str, ...]':
         """
         Retrieves a specified number of items in the enumeration sequence.

Args:

      num(typing.Any):Number of items to retrieve.

Returns:

      typing.Tuple[str, ...]
        
         """
         pass


      def Skip(self,) -> 'None':
         """
         Skips over the next specified elementes.

Args:



Returns:

      None
        
         """
         pass


      def Reset(self,) -> 'None':
         """
         Resets the enumeration sequence to the beginning.

Args:



Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIEnumString':
         """
         Creates another enumerator that contains the same enumeration state 

as the current one

Args:



Returns:

      PyIEnumString
        
         """
         pass


class PyIErrorLog(object):
      """A Python wrapper for a COM IErrorLog interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddError(self,propName:'str',excepInfo:'typing.Any'=None) -> 'None':
         """
         Adds an error to the error log.

Args:

      propName(str):The name of the error
      excepInfo(typing.Any):A COM exception.  Must be a complete COM exception (ie, pythoncom.com_error, or win32com.server.exceptions.COMException())

Returns:

      None
        
         """
         pass


class PyIExplorerBrowser(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,hwndParent:'typing.Any',prc:'PyRECT',pfs:'typing.Any') -> 'None':
         """
         Description of Initialize.

Args:

      hwndParent(typing.Any):Description for hwndParent
      prc(PyRECT):Description for prc
      pfs(typing.Any):Description for pfs

Returns:

      None
        
         """
         pass


      def Destroy(self,) -> 'None':
         """
         Description of Destroy.

Args:



Returns:

      None
        
         """
         pass


      def SetRect(self,hdwp:'typing.Any',rcBrowser:'PyRECT') -> 'int':
         """
         Description of SetRect.

Args:

      hdwp(typing.Any):Description for phdwp
      rcBrowser(PyRECT):Description for rcBrowser

Returns:

      int
        
         """
         pass


      def SetPropertyBag(self,PropertyBag:'typing.Any') -> 'None':
         """
         Description of SetPropertyBag.

Args:

      PropertyBag(typing.Any):Description for pszPropertyBag

Returns:

      None
        
         """
         pass


      def SetEmptyText(self,EmptyText:'typing.Any') -> 'None':
         """
         Description of SetEmptyText.

Args:

      EmptyText(typing.Any):Description for pszEmptyText

Returns:

      None
        
         """
         pass


      def SetFolderSettings(self,pfs:'typing.Any') -> 'None':
         """
         Description of SetFolderSettings.

Args:

      pfs(typing.Any):Description for pfs

Returns:

      None
        
         """
         pass


      def Advise(self,psbe:'PyIExplorerBrowserEvents') -> 'typing.Any':
         """
         Description of Advise.

Args:

      psbe(PyIExplorerBrowserEvents):Description for psbe

Returns:

      typing.Any
        
         """
         pass


      def Unadvise(self,dwCookie:'typing.Any') -> 'None':
         """
         Description of Unadvise.

Args:

      dwCookie(typing.Any):Description for dwCookie

Returns:

      None
        
         """
         pass


      def SetOptions(self,dwFlag:'typing.Any') -> 'None':
         """
         Description of SetOptions.

Args:

      dwFlag(typing.Any):Description for dwFlag

Returns:

      None
        
         """
         pass


      def GetOptions(self,) -> 'typing.Any':
         """
         Description of GetOptions.

Args:



Returns:

      typing.Any
        
         """
         pass


      def BrowseToIDList(self,pidl:'typing.Any',uFlags:'typing.Any') -> 'None':
         """
         Description of BrowseToIDList.

Args:

      pidl(typing.Any):Description for pidl
      uFlags(typing.Any):Description for uFlags

Returns:

      None
        
         """
         pass


      def BrowseToObject(self,punk:'PyIUnknown',uFlags:'typing.Any') -> 'None':
         """
         Description of BrowseToObject.

Args:

      punk(PyIUnknown):Description for punk
      uFlags(typing.Any):Description for uFlags

Returns:

      None
        
         """
         pass


      def FillFromObject(self,punk:'PyIUnknown',dwFlags:'typing.Any') -> 'None':
         """
         Description of FillFromObject.

Args:

      punk(PyIUnknown):Description for punk
      dwFlags(typing.Any):Description for dwFlags

Returns:

      None
        
         """
         pass


      def RemoveAll(self,) -> 'None':
         """
         Description of RemoveAll.

Args:



Returns:

      None
        
         """
         pass


      def GetCurrentView(self,riid:'PyIID') -> 'PyIUnknown':
         """
         Description of GetCurrentView.

Args:

      riid(PyIID):Description for riid

Returns:

      PyIUnknown
        
         """
         pass


class PyIExplorerBrowserEvents(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def OnNavigationPending(self,pidlFolder:'typing.Any') -> 'None':
         """
         Description of OnNavigationPending.

Args:

      pidlFolder(typing.Any):Description for pidlFolder

Returns:

      None
        
         """
         pass


      def OnViewCreated(self,psv:'PyIShellView') -> 'None':
         """
         Description of OnViewCreated.

Args:

      psv(PyIShellView):Description for psv

Returns:

      None
        
         """
         pass


      def OnNavigationComplete(self,pidlFolder:'typing.Any') -> 'None':
         """
         Description of OnNavigationComplete.

Args:

      pidlFolder(typing.Any):Description for pidlFolder

Returns:

      None
        
         """
         pass


      def OnNavigationFailed(self,pidlFolder:'typing.Any') -> 'None':
         """
         Description of OnNavigationFailed.

Args:

      pidlFolder(typing.Any):Description for pidlFolder

Returns:

      None
        
         """
         pass


class PyIExplorerCommand(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetTitle(self,psiItemArray:'PyIShellItemArray') -> 'typing.Any':
         """
         Description of GetTitle.

Args:

      psiItemArray(PyIShellItemArray):Description for psiItemArray

Returns:

      typing.Any
        
         """
         pass


      def GetIcon(self,psiItemArray:'PyIShellItemArray') -> 'typing.Any':
         """
         Description of GetIcon.

Args:

      psiItemArray(PyIShellItemArray):Description for psiItemArray

Returns:

      typing.Any
        
         """
         pass


      def GetToolTip(self,psiItemArray:'PyIShellItemArray') -> 'typing.Any':
         """
         Description of GetToolTip.

Args:

      psiItemArray(PyIShellItemArray):Description for psiItemArray

Returns:

      typing.Any
        
         """
         pass


      def GetCanonicalName(self,) -> 'PyIID':
         """
         Description of GetCanonicalName.

Args:



Returns:

      PyIID
        
         """
         pass


      def GetState(self,psiItemArray:'PyIShellItemArray',fOkToBeSlow:'typing.Any') -> 'typing.Any':
         """
         Description of GetState.

Args:

      psiItemArray(PyIShellItemArray):Description for psiItemArray
      fOkToBeSlow(typing.Any):Description for fOkToBeSlow

Returns:

      typing.Any
        
         """
         pass


      def Invoke(self,psiItemArray:'PyIShellItemArray',pbc:'PyIBindCtx') -> 'None':
         """
         Description of Invoke.

Args:

      psiItemArray(PyIShellItemArray):Description for psiItemArray
      pbc(PyIBindCtx):Description for pbc

Returns:

      None
        
         """
         pass


      def GetFlags(self,) -> 'typing.Any':
         """
         Description of GetFlags.

Args:



Returns:

      typing.Any
        
         """
         pass


      def EnumSubCommands(self,) -> 'PyIEnumExplorerCommand':
         """
         Description of EnumSubCommands.

Args:



Returns:

      PyIEnumExplorerCommand
        
         """
         pass


class PyIExplorerCommandProvider(object):
      """This is a gateway only interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyIExplorerPaneVisibility(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyIExternalConnection(object):
      """A Python wrapper for a COM IExternalConnection interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddConnection(self,extconn:'typing.Any',reserved:'typing.Any'=0) -> 'typing.Any':
         """
         Increments an object's count of its strong external connections 

(links).

Args:

      extconn(typing.Any):Type of external connection to the object. The only type of external connection currently supported by this interface is strong, which means that the object must remain alive as long as this external connection exists. Strong external connections are represented by the value EXTCONN_STRONG = 0x0001, which is defined in the enumeration EXTCON
      reserved(typing.Any):A reserved parameterReturn ValueThe result is the number of reference counts on the object; used for debugging purposes only.

Returns:

      typing.Any:A reserved parameter
Return ValueThe result is the number of reference counts on the object; used for debugging purposes only.

        
         """
         pass


      def ReleaseConnection(self,extconn:'typing.Any',reserved:'typing.Any',fLastReleaseCloses:'typing.Any') -> 'typing.Any':
         """
         Decrements an object's count of its strong external connections 

(references).

Args:

      extconn(typing.Any):Type of external connection
      reserved(typing.Any):A reserved parameter.
      fLastReleaseCloses(typing.Any):TRUE specifies that if the connection being released is the last external lock on the object, the object should close. FALSE specifies that the object should remain open until closed by the user or another process.Return ValueThe result is the number of reference counts on the object; used for debugging purposes only.

Returns:

      typing.Any:TRUE specifies that if the connection being released is the last external lock on 

the object, the object should close. FALSE specifies that the object should remain open until closed by the user 

or another process.Return ValueThe result is the number of reference counts on the object; used for debugging purposes only.

        
         """
         pass


class PyIExtractIcon(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Extract(self,pszFile:'typing.Any',nIconIndex:'typing.Any',nIconSize:'typing.Any') -> 'None':
         """
         Description of Extract.

Args:

      pszFile(typing.Any):Description for pszFile
      nIconIndex(typing.Any):Description for nIconIndex
      nIconSize(typing.Any):Description for nIconIndexReturn ValueThe result is (hicon_large, hicon_small), or (None,None) if the underlying function returns S_FALSE, indicating the calling application should extract it.

Returns:

      None:Description for nIconIndexReturn ValueThe result is (hicon_large, hicon_small), or 

(None,None) if the underlying function returns S_FALSE, indicating 

the calling application should extract it.

        
         """
         pass


      def GetIconLocation(self,uFlags:'typing.Any',cchMax:'typing.Any') -> 'None':
         """
         Description of GetIconLocation.

Args:

      uFlags(typing.Any):Description for uFlags
      cchMax(typing.Any):Buffer size to allocate for file name

Returns:

      None
        
         """
         pass


class PyIExtractIconW(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Extract(self,pszFile:'typing.Any',nIconIndex:'typing.Any',nIconSize:'typing.Any') -> 'None':
         """
         Description of Extract.

Args:

      pszFile(typing.Any):Description for pszFile
      nIconIndex(typing.Any):Description for nIconIndex
      nIconSize(typing.Any):Description for nIconIndexReturn ValueThe result is (hicon_large, hicon_small), or (None,None) if the underlying function returns S_FALSE, indicating the calling application should extract it.

Returns:

      None:Description for nIconIndexReturn ValueThe result is (hicon_large, hicon_small), or 

(None,None) if the underlying function returns S_FALSE, indicating 

the calling application should extract it.

        
         """
         pass


      def GetIconLocation(self,uFlags:'typing.Any',cchMax:'typing.Any') -> 'None':
         """
         Description of GetIconLocation.

Args:

      uFlags(typing.Any):Description for uFlags
      cchMax(typing.Any):Buffer size to allocate for file name

Returns:

      None
        
         """
         pass


class PyIExtractImage(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetLocation(self,dwPriority:'typing.Any',size:'typing.Tuple[typing.Any, typing.Any]',dwRecClrDepth:'typing.Any',pdwFlags:'typing.Any') -> 'None':
         """
         Description of GetLocation.

Args:

      dwPriority(typing.Any):Description for dwPriority
      size(typing.Tuple[typing.Any, typing.Any]):Description for prgSize
      dwRecClrDepth(typing.Any):Description for dwRecClrDepth
      pdwFlags(typing.Any):Description for pdwFlags

Returns:

      None
        
         """
         pass


      def Extract(self,) -> 'None':
         """
         Description of Extract.

Args:



Returns:

      None
        
         """
         pass


class PyIFileOperation(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Advise(self,Sink:'PyGFileOperationProgressSink') -> 'typing.Any':
         """
         Connects an event sink to receive updates

Args:

      Sink(PyGFileOperationProgressSink):Interface that receives progress updatesReturn ValueReturns a cookie to be passed to PyIFileOperation::Unadvise to disconnect

Returns:

      typing.Any:Interface that receives progress updatesReturn ValueReturns a cookie to be passed to PyIFileOperation::Unadvise to disconnect

        
         """
         pass


      def Unadvise(self,Cookie:'typing.Any') -> 'None':
         """
         Disconnects a progress sink

Args:

      Cookie(typing.Any):Identifies the sink to disconnect, as returned by PyIFileOperation::Advise

Returns:

      None
        
         """
         pass


      def SetOperationFlags(self,OperationFlags:'typing.Any') -> 'None':
         """
         Sets option flags for the operation

Args:

      OperationFlags(typing.Any):Combination of shellcon.FOF_* and FOFX_* flags

Returns:

      None
        
         """
         pass


      def SetProgressMessage(self,Message:'typing.Any') -> 'None':
         """
         Not implemented.

Args:

      Message(typing.Any):Description for Message

Returns:

      None
        
         """
         pass


      def SetProgressDialog(self,popd:'typing.Any') -> 'None':
         """
         Provides an interface used to display a progress dialog

Args:

      popd(typing.Any):Progress dialog interfaceCommentsIOperationsProgressDialog is not yet supported

Returns:

      None
        
         """
         pass


      def SetProperties(self,proparray:'PyIPropertyChangeArray') -> 'None':
         """
         Specifies a set of properties to be changed.

Args:

      proparray(PyIPropertyChangeArray):Sequence of property changes to be performed (see propsys::PSCreatePropertyChangeArray)CommentsNote that these properties will be set for *any* files created by the operation, not just items passed to ApplyPropertiesToItem(s).  New items created as the result of a rename, copy, or move must have a property handler, or the operation fails with the vague com_error: (-2147467259, 'Unspecified error', None, None) (E_FAIL, or 0x80004005 in hex) even though the given file operation was actually performed.

Returns:

      None
        
         """
         pass


      def SetOwnerWindow(self,Owner:'int') -> 'None':
         """
         Sets the parent window for any UI displayed.

Args:

      Owner(int):Handle to parent window

Returns:

      None
        
         """
         pass


      def ApplyPropertiesToItem(self,Item:'PyIShellItem') -> 'None':
         """
         Specifies the item that will receive property changes

Args:

      Item(PyIShellItem):The item to which property changes will be applied

Returns:

      None
        
         """
         pass


      def ApplyPropertiesToItems(self,Items:'PyIUnknown') -> 'None':
         """
         Specifies multiple items that will receive property changes

Args:

      Items(PyIUnknown):PyIShellItemArray, PyIDataObject, or PyIEnumShellItems containing the target items

Returns:

      None
        
         """
         pass


      def RenameItem(self,Item:'PyIShellItem',NewName:'typing.Any',Sink:'PyGFileOperationProgressSink'=None) -> 'None':
         """
         Adds a rename to the operation sequence

Args:

      Item(PyIShellItem):The item to be renamed
      NewName(typing.Any):The new name
      Sink(PyGFileOperationProgressSink):Progress sink for this operation only.

Returns:

      None
        
         """
         pass


      def RenameItems(self,pUnkItems:'PyIUnknown',NewName:'typing.Any') -> 'None':
         """
         Adds multiple renames to the operation sequence

Args:

      pUnkItems(PyIUnknown):PyIShellItemArray, PyIDataObject, or PyIEnumShellItems containing items to be renamed
      NewName(typing.Any):New name for all items.  Collisions handled automatically.

Returns:

      None
        
         """
         pass


      def MoveItem(self,Item:'PyIShellItem',DestinationFolder:'PyIShellItem',pszNewName:'typing.Any'=None,Sink:'PyGFileOperationProgressSink'=None) -> 'None':
         """
         Adds a move operation to the configuration

Args:

      Item(PyIShellItem):The item to be moved
      DestinationFolder(PyIShellItem):The folder into which it will be moved
      pszNewName(typing.Any):Name to be given to moved item, use None to keep original name
      Sink(PyGFileOperationProgressSink):Progress sink to receive notification for just this operation

Returns:

      None
        
         """
         pass


      def MoveItems(self,Items:'PyIUnknown',DestinationFolder:'PyIShellItem') -> 'None':
         """
         Adds multiple move operations to the configuration

Args:

      Items(PyIUnknown):PyIShellItemArray, PyIDataObject, or PyIEnumShellItems containing the items to be moved
      DestinationFolder(PyIShellItem):Folder into which all items will be moved

Returns:

      None
        
         """
         pass


      def CopyItem(self,Item:'PyIShellItem',DestinationFolder:'PyIShellItem',CopyName:'typing.Any'=None,Sink:'PyGFileOperationProgressSink'=None) -> 'None':
         """
         Adds a copy operation to the configuration

Args:

      Item(PyIShellItem):Item to be copied
      DestinationFolder(PyIShellItem):Folder into which it will be copied
      CopyName(typing.Any):New name for the copied file, use None to keep original name
      Sink(PyGFileOperationProgressSink):Progress sink for just this operation

Returns:

      None
        
         """
         pass


      def CopyItems(self,Items:'PyIUnknown',DestinationFolder:'PyIShellItem') -> 'None':
         """
         Adds multiple copy operations to the configuration

Args:

      Items(PyIUnknown):PyIShellItemArray, PyIDataObject, or PyIEnumShellItems containing items to be copied
      DestinationFolder(PyIShellItem):Folder into which they will be copied

Returns:

      None
        
         """
         pass


      def DeleteItem(self,Item:'PyIShellItem',Sink:'PyGFileOperationProgressSink'=None) -> 'None':
         """
         Adds a delete operation to the configuration

Args:

      Item(PyIShellItem):Description for psiItem
      Sink(PyGFileOperationProgressSink):Progress sink for just this operation

Returns:

      None
        
         """
         pass


      def DeleteItems(self,Items:'PyIUnknown') -> 'None':
         """
         Adds multiple delete operations to the configuration

Args:

      Items(PyIUnknown):PyIShellItemArray, PyIDataObject, or PyIEnumShellItems containing the items to be deleted

Returns:

      None
        
         """
         pass


      def NewItem(self,DestinationFolder:'PyIShellItem',FileAttributes:'typing.Any',Name:'typing.Any',TemplateName:'typing.Any'=None,Sink:'PyGFileOperationProgressSink'=None) -> 'None':
         """
         Creates a new file as part of the operation

Args:

      DestinationFolder(PyIShellItem):Folder in which to create the file
      FileAttributes(typing.Any):Combination of win32con.FILE_ATTRIBUTE_* flags
      Name(typing.Any):Name of the new file
      TemplateName(typing.Any):Template file used to initialize the new file
      Sink(PyGFileOperationProgressSink):Progress sink for just this operation

Returns:

      None
        
         """
         pass


      def PerformOperations(self,) -> 'None':
         """
         Effects all configured file system modifications

Args:



Returns:

      None
        
         """
         pass


      def GetAnyOperationsAborted(self,) -> 'typing.Any':
         """
         Determines if any operations were terminated

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIIdentityName(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyIInitializeWithFile(object):
      """Initializes a property handler that requires a file path instead of a stream"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,FilePath:'typing.Any',Mode:'typing.Any') -> 'None':
         """
         Passes a file path to a property handler on startup

Args:

      FilePath(typing.Any):Full path to the file whose properties are to be accessed
      Mode(typing.Any):Indicates if properties can be written, STGM_READ or STGM_READWRITE

Returns:

      None
        
         """
         pass


class PyIInitializeWithStream(object):
      """Interface that initializes a handler capable of reading properties from a stream"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,Stream:'PyIStream',Mode:'typing.Any') -> 'None':
         """
         Initializes a property handler with a stream

Args:

      Stream(PyIStream):Stream containing the contents from which to extract properties
      Mode(typing.Any):Indicates if stream is writable, STGM_READ or STGM_READWRITE

Returns:

      None
        
         """
         pass


class PyIInputObject(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def TranslateAccelerator(self,pmsg:'typing.Any') -> 'None':
         """
         Description of TranslateAccelerator.

Args:

      pmsg(typing.Any):Description for pmsg

Returns:

      None
        
         """
         pass


      def UIActivate(self,uState:'typing.Any') -> 'None':
         """
         Description of UIActivate.

Args:

      uState(typing.Any):Description for uState

Returns:

      None
        
         """
         pass


      def HasFocusIO(self,) -> 'None':
         """
         Description of Refresh.

Args:



Returns:

      None
        
         """
         pass


class PyIInternetBindInfo(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetBindInfo(self,) -> 'None':
         """
         Description of GetBindInfo.

Args:



Returns:

      None
        
         """
         pass


      def GetBindString(self,) -> 'None':
         """
         Description of GetBindString.

Args:



Returns:

      None
        
         """
         pass


class PyIInternetPriority(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetPriority(self,nPriority:'typing.Any') -> 'None':
         """
         Description of SetPriority.

Args:

      nPriority(typing.Any):Description for nPriority

Returns:

      None
        
         """
         pass


      def GetPriority(self,) -> 'None':
         """
         Description of GetPriority.

Args:



Returns:

      None
        
         """
         pass


class PyIInternetProtocol(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Read(self,cb:'typing.Any') -> 'None':
         """
         Description of Read.

Args:

      cb(typing.Any):Description for cb

Returns:

      None
        
         """
         pass


      def Seek(self,dlibMove:'LARGE_INTEGER',dwOrigin:'typing.Any') -> 'None':
         """
         Description of Seek.

Args:

      dlibMove(LARGE_INTEGER):Description for dlibMove
      dwOrigin(typing.Any):Description for dwOrigin

Returns:

      None
        
         """
         pass


      def LockRequest(self,dwOptions:'typing.Any') -> 'None':
         """
         Description of LockRequest.

Args:

      dwOptions(typing.Any):Description for dwOptions

Returns:

      None
        
         """
         pass


      def UnlockRequest(self,) -> 'None':
         """
         Description of UnlockRequest.

Args:



Returns:

      None
        
         """
         pass


class PyIInternetProtocolInfo(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ParseUrl(self,pwzUrl:'typing.Any',ParseAction:'typing.Any',dwParseFlags:'typing.Any',cchResult:'typing.Any',dwReserved:'typing.Any') -> 'None':
         """
         Description of ParseUrl.

Args:

      pwzUrl(typing.Any):Description for pwzUrl
      ParseAction(typing.Any):Description for ParseAction
      dwParseFlags(typing.Any):Description for dwParseFlags
      cchResult(typing.Any):Description for cchResult
      dwReserved(typing.Any):Description for dwReserved

Returns:

      None
        
         """
         pass


      def CombineUrl(self,pwzBaseUrl:'typing.Any',pwzRelativeUrl:'typing.Any',dwCombineFlags:'typing.Any',cchResult:'typing.Any',dwReserved:'typing.Any') -> 'None':
         """
         Description of CombineUrl.

Args:

      pwzBaseUrl(typing.Any):Description for pwzBaseUrl
      pwzRelativeUrl(typing.Any):Description for pwzRelativeUrl
      dwCombineFlags(typing.Any):Description for dwCombineFlags
      cchResult(typing.Any):Description for cchResult
      dwReserved(typing.Any):Description for dwReserved

Returns:

      None
        
         """
         pass


      def CompareUrl(self,pwzUrl1:'typing.Any',pwzUrl2:'typing.Any',dwCompareFlags:'typing.Any') -> 'None':
         """
         Description of CompareUrl.

Args:

      pwzUrl1(typing.Any):Description for pwzUrl1
      pwzUrl2(typing.Any):Description for pwzUrl2
      dwCompareFlags(typing.Any):Description for dwCompareFlags

Returns:

      None
        
         """
         pass


      def QueryInfo(self,pwzUrl:'typing.Any',OueryOption:'typing.Any',dwQueryFlags:'typing.Any',cbBuffer:'typing.Any',dwReserved:'typing.Any') -> 'typing.Any':
         """
         Description of QueryInfo.

Args:

      pwzUrl(typing.Any):Description for pwzUrl
      OueryOption(typing.Any):Description for OueryOption
      dwQueryFlags(typing.Any):Description for dwQueryFlags
      cbBuffer(typing.Any):Description for cbBuffer
      dwReserved(typing.Any):Description for dwReservedCommentsIf the buffer size is the size of an integer, an integer will be returned, otherwise a string.

Returns:

      typing.Any
        
         """
         pass


class PyIInternetProtocolRoot(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Start(self,szUrl:'typing.Any',pOIProtSink:'PyIInternetProtocolSink',pOIBindInfo:'PyIInternetBindInfo',grfPI:'typing.Any',dwReserved:'typing.Any') -> 'None':
         """
         Description of Start.

Args:

      szUrl(typing.Any):Description for szUrl
      pOIProtSink(PyIInternetProtocolSink):Description for pOIProtSink
      pOIBindInfo(PyIInternetBindInfo):Description for pOIBindInfo
      grfPI(typing.Any):Description for grfPI
      dwReserved(typing.Any):Description for dwReserved

Returns:

      None
        
         """
         pass


      def Continue(self,) -> 'None':
         """
         Description of Continue.

Args:



Returns:

      None
        
         """
         pass


      def Abort(self,hrReason:'typing.Any',dwOptions:'typing.Any') -> 'None':
         """
         Description of Abort.

Args:

      hrReason(typing.Any):Description for hrReason
      dwOptions(typing.Any):Description for dwOptions

Returns:

      None
        
         """
         pass


      def Terminate(self,dwOptions:'typing.Any') -> 'None':
         """
         Description of Terminate.

Args:

      dwOptions(typing.Any):Description for dwOptions

Returns:

      None
        
         """
         pass


      def Suspend(self,) -> 'None':
         """
         Description of Suspend.

Args:



Returns:

      None
        
         """
         pass


      def Resume(self,) -> 'None':
         """
         Description of Resume.

Args:



Returns:

      None
        
         """
         pass


class PyIInternetProtocolSink(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Switch(self,) -> 'None':
         """
         Description of Switch.

Args:



Returns:

      None
        
         """
         pass


      def ReportProgress(self,ulStatusCode:'typing.Any',szStatusText:'typing.Any') -> 'None':
         """
         Description of ReportProgress.

Args:

      ulStatusCode(typing.Any):Description for ulStatusCode
      szStatusText(typing.Any):Description for szStatusText

Returns:

      None
        
         """
         pass


      def ReportData(self,grfBSCF:'typing.Any',ulProgress:'typing.Any',ulProgressMax:'typing.Any') -> 'None':
         """
         Description of ReportData.

Args:

      grfBSCF(typing.Any):Description for grfBSCF
      ulProgress(typing.Any):Description for ulProgress
      ulProgressMax(typing.Any):Description for ulProgressMax

Returns:

      None
        
         """
         pass


      def ReportResult(self,hrResult:'typing.Any',dwError:'typing.Any',szResult:'typing.Any') -> 'None':
         """
         Description of ReportResult.

Args:

      hrResult(typing.Any):Description for hrResult
      dwError(typing.Any):Description for dwError
      szResult(typing.Any):Description for szResult

Returns:

      None
        
         """
         pass


class PyIInternetSecurityManager(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetSecuritySite(self,pSite:'typing.Any') -> 'None':
         """
         Description of SetSecuritySite.

Args:

      pSite(typing.Any):Description for pSite

Returns:

      None
        
         """
         pass


      def GetSecuritySite(self,) -> 'None':
         """
         Description of GetSecuritySite.

Args:



Returns:

      None
        
         """
         pass


      def MapUrlToZone(self,pwszUrl:'typing.Any',dwFlags:'typing.Any') -> 'None':
         """
         Description of MapUrlToZone.

Args:

      pwszUrl(typing.Any):Description for pwszUrl
      dwFlags(typing.Any):Description for dwFlags

Returns:

      None
        
         """
         pass


      def GetSecurityId(self,pwszUrl:'typing.Any',pcbSecurityId:'typing.Any') -> 'None':
         """
         Description of GetSecurityId.

Args:

      pwszUrl(typing.Any):Description for pwszUrl
      pcbSecurityId(typing.Any):Description for pcbSecurityId

Returns:

      None
        
         """
         pass


      def ProcessUrlAction(self,pwszUrl:'typing.Any',dwAction:'typing.Any',context:'typing.Any',dwFlags:'typing.Any') -> 'None':
         """
         Description of ProcessUrlAction.

Args:

      pwszUrl(typing.Any):Description for pwszUrl
      dwAction(typing.Any):Description for dwAction
      context(typing.Any):
      dwFlags(typing.Any):Description for dwFlags

Returns:

      None
        
         """
         pass


      def SetZoneMapping(self,dwZone:'typing.Any',lpszPattern:'typing.Any',dwFlags:'typing.Any') -> 'None':
         """
         Description of SetZoneMapping.

Args:

      dwZone(typing.Any):Description for dwZone
      lpszPattern(typing.Any):Description for lpszPattern
      dwFlags(typing.Any):Description for dwFlags

Returns:

      None
        
         """
         pass


      def GetZoneMappings(self,dwZone:'typing.Any',dwFlags:'typing.Any') -> 'None':
         """
         Description of GetZoneMappings.

Args:

      dwZone(typing.Any):Description for dwZone
      dwFlags(typing.Any):Description for dwFlags

Returns:

      None
        
         """
         pass


class PyIKnownFolder(object):
      """Interface representing a known folder that serves 

as a replacement for the numeric CSIDL definitions and API functions. 

Requires Vista or later."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetId(self,) -> 'PyIID':
         """
         Returns the id of the folder

Args:



Returns:

      PyIID
        
         """
         pass


      def GetCategory(self,) -> 'typing.Any':
         """
         Returns the category for a folder (shellcon.KF_CATEGORY_*)

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetShellItem(self,riid:'PyIID',Flags:'typing.Any'=0) -> 'PyIShellItem':
         """
         Returns a shell interface for the folder

Args:

      riid(PyIID):The interface to return (IShellItem or IShellItem2)
      Flags(typing.Any):Combination of shellcon.KF_FLAG_* values

Returns:

      PyIShellItem
        
         """
         pass


      def GetPath(self,Flags:'typing.Any'=0) -> 'typing.Any':
         """
         Returns the path to the folder

Args:

      Flags(typing.Any):Combination of shellcon.KF_FLAG_* flags controlling how the path is returned

Returns:

      typing.Any
        
         """
         pass


      def SetPath(self,Flags:'typing.Any',Path:'typing.Any') -> 'None':
         """
         Changes the location of the folder

Args:

      Flags(typing.Any):KF_FLAG_DONT_UNEXPAND, or 0
      Path(typing.Any):New path for known folder

Returns:

      None
        
         """
         pass


      def GetIDList(self,Flags:'typing.Any') -> 'PyIDL':
         """
         Returns the folder's location as an item id list.

Args:

      Flags(typing.Any):Combination of shellcon.KF_FLAG_* values that affect how the operation is performed

Returns:

      PyIDL
        
         """
         pass


      def GetFolderType(self,) -> 'PyIID':
         """
         Returns the type of the folder

Args:



Returns:

      PyIID:PyIKnownFolder.GetFolderType
PyIID = GetFolderType()Returns the type of the folder
Return ValueReturns a folder type guid (shell.FOLDERTYPEID_*)

        
         """
         pass


      def GetRedirectionCapabilities(self,) -> 'typing.Any':
         """
         Returns flags indicating how the folder can be redirected

Args:



Returns:

      typing.Any:PyIKnownFolder.GetRedirectionCapabilities

int = GetRedirectionCapabilities()Returns flags indicating how the folder can be redirected
Return ValueCombination of shellcon.KF_REDIRECTION_CAPABILITIES_* flags

        
         """
         pass


      def GetFolderDefinition(self,) -> 'typing.Any':
         """
         Retrieves detailed information about a known folder

Args:



Returns:

      typing.Any:PyIKnownFolder.GetFolderDefinition

dict = GetFolderDefinition()Retrieves detailed information about a known folder
Return ValueReturns a dict containing info from a KNOWNFOLDER_DEFINITION struct

        
         """
         pass


class PyIKnownFolderManager(object):
      """Interface used to manage known folder definitions."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def FolderIdFromCsidl(self,Csidl:'typing.Any') -> 'PyIID':
         """
         Returns the folder id that corresponds to a CSIDL

Args:

      Csidl(typing.Any):The legacy CSIDL identifying a folder

Returns:

      PyIID
        
         """
         pass


      def FolderIdToCsidl(self,_id:'PyIID') -> 'typing.Any':
         """
         Returns the CSIDL equivalent of a known folder

Args:

      _id(PyIID):A known folder id (shell.FOLDERID_*)

Returns:

      typing.Any
        
         """
         pass


      def GetFolderIds(self,) -> 'typing.Tuple[PyIID, ...]':
         """
         Retrieves all known folder ids.

Args:



Returns:

      typing.Tuple[PyIID, ...]
        
         """
         pass


      def GetFolder(self,_id:'PyIID') -> 'PyIKnownFolder':
         """
         Returns a folder by its id.

Args:

      _id(PyIID):A known folder id (shell.FOLDERID_*)

Returns:

      PyIKnownFolder
        
         """
         pass


      def GetFolderByName(self,Name:'typing.Any') -> 'PyIKnownFolder':
         """
         Returns a folder by canonical name

Args:

      Name(typing.Any):The nonlocalized name of a known folder

Returns:

      PyIKnownFolder
        
         """
         pass


      def RegisterFolder(self,_id:'PyIID',Definition:'typing.Any') -> 'None':
         """
         Defines a new known folder

Args:

      _id(PyIID):GUID used to identify the new known folder
      Definition(typing.Any):Dictionary containing info to be placed in a KNOWNFOLDER_DEFINITION structCommentsPyIKnownFolder::GetFolderDefinition can be used to get a template dictionary

Returns:

      None
        
         """
         pass


      def UnregisterFolder(self,_id:'PyIID') -> 'None':
         """
         Removes the definition of a known folder

Args:

      _id(PyIID):GUID of a known folder to be unregistered

Returns:

      None
        
         """
         pass


      def FindFolderFromPath(self,Path:'typing.Any',Mode:'typing.Any') -> 'PyIKnownFolder':
         """
         Retrieves a known folder by path

Args:

      Path(typing.Any):Path of a folder
      Mode(typing.Any):FFFP_EXACTMATCH or FFFP_NEARESTPARENTMATCH

Returns:

      PyIKnownFolder
        
         """
         pass


      def FindFolderFromIDList(self,pidl:'PyIDL') -> 'PyIKnownFolder':
         """
         Retrieves a known folder using its item id 

list.

Args:

      pidl(PyIDL):Item id list of the folder

Returns:

      PyIKnownFolder
        
         """
         pass


      def Redirect(self,_id:'PyIID',hwnd:'int',flags:'typing.Any',TargetPath:'typing.Any',Exclusion:'typing.Tuple[PyIID, ...]') -> 'None':
         """
         Redirects a known folder to an alternate location

Args:

      _id(PyIID):Id of the known folder to be redirected
      hwnd(int):Handle of window to be used for user interaction
      flags(typing.Any):Combination of KF_REDIRECT_* flags
      TargetPath(typing.Any):Path to which the known folder will be redirected
      Exclusion(typing.Tuple[PyIID, ...]):Sequence of known folder ids of subfolders to be excluded from redirection

Returns:

      None
        
         """
         pass


class PyILockBytes(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ReadAt(self,ulOffset:'ULARGE_INTEGER',cb:'typing.Any') -> 'str':
         """
         Reads a specified number of bytes starting at a specified offset from the 

beginning of the byte array object.

Args:

      ulOffset(ULARGE_INTEGER):Offset to start reading
      cb(typing.Any):Number of bytes to readCommentsThe result is a binary buffer returned in a string.

Returns:

      str
        
         """
         pass


      def WriteAt(self,ulOffset:'ULARGE_INTEGER',data:'str') -> 'typing.Any':
         """
         Writes the specified number of bytes starting at a specified offset from the 

beginning of the byte array.

Args:

      ulOffset(ULARGE_INTEGER):Offset to write at.
      data(str):Data to writeReturn ValueThe result is the number of bytes actually written.

Returns:

      typing.Any:Data to writeReturn ValueThe result is the number of bytes actually written.

        
         """
         pass


      def Flush(self,) -> 'None':
         """
         Ensures that any internal buffers maintained by the byte array object are written out 

to the backing storage.

Args:



Returns:

      None
        
         """
         pass


      def SetSize(self,cb:'ULARGE_INTEGER') -> 'None':
         """
         Changes the size of the byte array.

Args:

      cb(ULARGE_INTEGER):The new size.

Returns:

      None
        
         """
         pass


      def LockRegion(self,libOffset:'ULARGE_INTEGER',cb:'ULARGE_INTEGER',dwLockType:'typing.Any') -> 'None':
         """
         Restricts access to a specified range of bytes in the byte array.

Args:

      libOffset(ULARGE_INTEGER):The beginning of the region to lock.
      cb(ULARGE_INTEGER):The number of bytes to lock.
      dwLockType(typing.Any):Specifies the restrictions being requested on accessing the range.

Returns:

      None
        
         """
         pass


      def UnlockRegion(self,libOffset:'ULARGE_INTEGER',cb:'ULARGE_INTEGER',dwLockType:'typing.Any') -> 'None':
         """
         None

Args:

      libOffset(ULARGE_INTEGER):The beginning of the region to unlock.
      cb(ULARGE_INTEGER):The number of bytes to lock.
      dwLockType(typing.Any):Specifies the restrictions being requested on accessing the range.

Returns:

      None
        
         """
         pass


      def Stat(self,grfStatFlag:'typing.Any') -> 'STATSTG':
         """
         None

Args:

      grfStatFlag(typing.Any):Specifies that this method does not return some of the fields in the STATSTG structure, thus saving a memory allocation operation. Values are taken from the STATFLAG enumerationg

Returns:

      STATSTG
        
         """
         pass


class PyIMAPIContainer(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def OpenEntry(self,entryId:'str',iid:'PyIID',flags:'typing.Any') -> 'typing.Any':
         """
         Opens an object and returns an interface object for further access.

Args:

      entryId(str):The EntryID to open.
      iid(PyIID):The IID of the returned interface, or None for the default interface.
      flags(typing.Any):Flags for the call.  May include MAPI_BEST_ACCESS, MAPI_DEFERRED_ERRORS, MAPI_MODIFY and possibly others (see the MAPI documentation)

Returns:

      typing.Any
        
         """
         pass


      def GetContentsTable(self,flags:'typing.Any') -> 'PyIMAPITable':
         """
         Returns an object representing the container's contents table.

Args:

      flags(typing.Any):The flags to use.

Returns:

      PyIMAPITable
        
         """
         pass


      def GetHierarchyTable(self,flags:'typing.Any') -> 'PyIMAPITable':
         """
         Returns an object representing the container's hierarchy table.

Args:

      flags(typing.Any):The flags to use.

Returns:

      PyIMAPITable
        
         """
         pass


class PyIMAPIFolder(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetLastError(self,hr:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Returns the last error code for the object.

Args:

      hr(typing.Any):Contains the error code generated in the previous method call.
      flags(typing.Any):Indicates for format for the output.

Returns:

      typing.Any
        
         """
         pass


      def CreateFolder(self,folderType:'typing.Any',folderName:'str',folderComment:'str'=None,iid:'PyIID'=None,flags:'typing.Any'=0) -> 'PyIMAPIFolder':
         """
         Creates a folder object.

Args:

      folderType(typing.Any):The type of folder to create
      folderName(str):The name of the folder.
      folderComment(str):A comment for the folder or None
      iid(PyIID):The IID of the object to return.  Should usually be None.
      flags(typing.Any):

Returns:

      PyIMAPIFolder
        
         """
         pass


      def CreateMessage(self,iid:'PyIID',flags:'typing.Any') -> 'PyIMessage':
         """
         Creates a message in a folder

Args:

      iid(PyIID):The IID of the object to return.  Should usually be None.
      flags(typing.Any):

Returns:

      PyIMessage
        
         """
         pass


      def CopyMessages(self,msgs:'PySBinaryArray',iid:'PyIID',folder:'PyIMAPIFolder',ulUIParam:'typing.Any',progress:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Copies the specified messages

Args:

      msgs(PySBinaryArray):
      iid(PyIID):IID representing the interface to be used to access the destination folder.  Should usually be None.
      folder(PyIMAPIFolder):The destination folder
      ulUIParam(typing.Any):Handle of the parent window for any dialog boxes or windows this method displays.
      progress(typing.Any):A progress object, or None
      flags(typing.Any):A bitmask ofMaskDescriptionMAPI_DECLINE_OKInforms the message store provider to immediately return MAPI_E_DECLINE_COPY if it implements CopyMessage by calling the support object's IMAPISupport::DoCopyTo or IMAPISupport::DoCopyProps method.MESSAGE_DIALOGDisplays a progress indicator as the operation proceeds.MESSAGE_MOVEThe message or messages are to be moved rather than copied. If MESSAGE_MOVE is not set, the messages are copied.

Returns:

      typing.Any
        
         """
         pass


      def DeleteFolder(self,entryId:'str',uiParam:'typing.Any',progress:'typing.Any') -> 'None':
         """
         Deletes a subfolder.

Args:

      entryId(str):The EntryID of the subfolder to delete.
      uiParam(typing.Any):Handle of the parent window of the progress indicator.
      progress(typing.Any):A progress object, or None

Returns:

      None
        
         """
         pass


      def DeleteMessages(self,msgs:'PySBinaryArray',uiParam:'typing.Any',progress:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Deletes the specified messages.

Args:

      msgs(PySBinaryArray):
      uiParam(typing.Any):A HWND for the progress
      progress(typing.Any):A progress object, or None
      flags(typing.Any):

Returns:

      typing.Any
        
         """
         pass


      def EmptyFolder(self,uiParam:'typing.Any',progress:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         deletes all messages and subfolders from a folder without deleting the folder itself.

Args:

      uiParam(typing.Any):A HWND for the progress
      progress(typing.Any):A progress object, or None
      flags(typing.Any):

Returns:

      typing.Any
        
         """
         pass


      def SetReadFlags(self,msgs:'PySBinaryArray',uiParam:'typing.Any',progress:'typing.Any',flag:'typing.Any') -> 'None':
         """
         Sets or clears the MSGFLAG_READ flag in the PR_MESSAGE_FLAGS (PidTagMessageFlags) property of one or more of the folder's messages, and manages the sending of read reports.

Args:

      msgs(PySBinaryArray):
      uiParam(typing.Any):A HWND for the progress
      progress(typing.Any):A progress object, or None
      flag(typing.Any):Bitmask of flags that controls the setting of a message's read flag - that is, the message's MSGFLAG_READ flag in its PR_MESSAGE_FLAGS property and the processing of read reports.

Returns:

      None
        
         """
         pass


class PyIMAPIProp(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetProps(self,propList:'PySPropTagArray',flags:'typing.Any'=0) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Returns a list of property values.

Args:

      propList(PySPropTagArray):The list of properties
      flags(typing.Any):

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def DeleteProps(self,propList:'PySPropTagArray',wantProblems:'typing.Any'=False) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Deletes a set of properties.

Args:

      propList(PySPropTagArray):The list of properties
      wantProblems(typing.Any):Return detailed error information

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def SetProps(self,propList:'typing.Tuple[typing.Any, typing.Any]',wantProblems:'typing.Any'=False) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Sets a set of properties.

Args:

      propList(typing.Tuple[typing.Any, typing.Any]):The list of properties
      wantProblems(typing.Any):Return detailed error information

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def CopyTo(self,IIDExcludeList:'typing.Tuple[typing.Any, typing.Any]',propTags:'PySPropTagArray',uiParam:'typing.Any',progress:'typing.Any',resultIID:'PyIID',dest:'PyIMAPIProp',flags:'typing.Any',wantProblems:'typing.Any'=False) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Copies an object to another

Args:

      IIDExcludeList(typing.Tuple[typing.Any, typing.Any]):A sequence of IIDs to exclude.
      propTags(PySPropTagArray):The property tags to exclude.
      uiParam(typing.Any):Handle to the parent window of the progress object
      progress(typing.Any):Reserved - must pass None
      resultIID(PyIID):IID of the destination object
      dest(PyIMAPIProp):The destination object
      flags(typing.Any):flags
      wantProblems(typing.Any):Return detailed error information

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def CopyProps(self,propTags:'PySPropTagArray',uiParam:'typing.Any',progress:'typing.Any',resultIID:'PyIID',dest:'PyIMAPIProp',flags:'typing.Any',wantProblems:'typing.Any'=False) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Copies a set of properties to another object

Args:

      propTags(PySPropTagArray):The property tags to copy
      uiParam(typing.Any):Handle to the parent window of the progress object
      progress(typing.Any):Reserved - must pass None
      resultIID(PyIID):IID of the destination object
      dest(PyIMAPIProp):The destination object
      flags(typing.Any):flags
      wantProblems(typing.Any):Return detailed error information

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def OpenProperty(self,propTag:'typing.Any',iid:'PyIID',interfaceOptions:'typing.Any',flags:'typing.Any') -> 'PyIUnknown':
         """
         Returns an interface object to be used to access a property.

Args:

      propTag(typing.Any):The property tag to open
      iid(PyIID):The IID of the resulting interface.
      interfaceOptions(typing.Any):Data that relates to the interface identified by the lpiid parameter.
      flags(typing.Any):flags

Returns:

      PyIUnknown
        
         """
         pass


      def GetIDsFromNames(self,nameIds:'PyMAPINAMEIDArray',flags:'typing.Any'=0) -> 'PySPropTagArray':
         """
         Determines property IDs

Args:

      nameIds(PyMAPINAMEIDArray):Sequence of name ids
      flags(typing.Any):

Returns:

      PySPropTagArray
        
         """
         pass


      def GetNamesFromIDs(self,propTags:'PySPropTagArray',propSetGuid:'PyIID'=None,flags:'typing.Any'=0) -> 'typing.Tuple[typing.Any, PySPropTagArray, PyMAPINAMEIDArray]':
         """
         Determines property names

Args:

      propTags(PySPropTagArray):Sequence of property tags, or None
      propSetGuid(PyIID):a globally unique identifier, identifying a property set, or None
      flags(typing.Any):

Returns:

      typing.Tuple[typing.Any, PySPropTagArray, PyMAPINAMEIDArray]
        
         """
         pass


      def GetLastError(self,hr:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Returns the last error code for the object.

Args:

      hr(typing.Any):Contains the error code generated in the previous method call.
      flags(typing.Any):Indicates for format for the output.

Returns:

      typing.Any
        
         """
         pass


      def SaveChanges(self,flags:'typing.Any') -> 'None':
         """
         Saves pending changes to the object

Args:

      flags(typing.Any):flags

Returns:

      None
        
         """
         pass


      def GetPropList(self,flags:'typing.Any') -> 'PySPropTagArray':
         """
         Gets a list of properties

Args:

      flags(typing.Any):flags

Returns:

      PySPropTagArray
        
         """
         pass


class PyIMAPISession(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def OpenEntry(self,entryId:'str',iid:'PyIID',flags:'typing.Any') -> 'typing.Any':
         """
         Opens an object and returns an interface object for further access.

Args:

      entryId(str):The EntryID to open.
      iid(PyIID):The IID of the returned interface, or None for the default interface.
      flags(typing.Any):Flags for the call.  May include MAPI_BEST_ACCESS, MAPI_DEFERRED_ERRORS, MAPI_MODIFY and possibly others (see the MAPI documentation)

Returns:

      typing.Any
        
         """
         pass


      def OpenMsgStore(self,uiParam:'typing.Any',entryId:'str',iid:'PyIID',flags:'typing.Any') -> 'PyIUnknown':
         """
         Opens a message store.

Args:

      uiParam(typing.Any):Handle to the parent window for dialogs.
      entryId(str):The entry ID of the message store to open.
      iid(PyIID):The IID of the interface returned, or None
      flags(typing.Any):Options for the call.CommentsThe result is the interface specified by the IID, or IID_IMsgStore if None is used.

Returns:

      PyIUnknown
        
         """
         pass


      def QueryIdentity(self,) -> 'str':
         """
         Returns the entry identifier of the object that provides the primary identity for the session.

Args:



Returns:

      str
        
         """
         pass


      def Advise(self,entryId:'str',mask:'typing.Any',sink:'typing.Any') -> 'typing.Any':
         """
         None

Args:

      entryId(str):The entryID of the object
      mask(typing.Any):
      sink(typing.Any):Return ValueThe result is an integer which should be passed to PyIMAPISession::Unadvise

Returns:

      typing.Any:Return ValueThe result is an integer which should be passed to 

PyIMAPISession::Unadvise

        
         """
         pass


      def Unadvise(self,connection:'typing.Any') -> 'None':
         """
         None

Args:

      connection(typing.Any):Value returned from PyIMAPISession::Advise

Returns:

      None
        
         """
         pass


      def CompareEntryIDs(self,entryId:'str',entryId1:'str',flags:'typing.Any'=0) -> 'typing.Any':
         """
         Compares two entry identifiers belonging to a particular address book provider to determine if they refer to the same address book object

Args:

      entryId(str):The first entry ID to be compared
      entryId1(str):The second entry ID to be compared
      flags(typing.Any):Reserved - must be zero.Return ValueThe result is set to TRUE if the two entry identifiers refer to the same object, and FALSE otherwise.

Returns:

      typing.Any:Reserved - must be zero.
Return ValueThe result is set to TRUE if the two entry identifiers refer to the same object, and FALSE otherwise.

        
         """
         pass


      def GetLastError(self,hr:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Returns the last error code for the object.

Args:

      hr(typing.Any):Contains the error code generated in the previous method call.
      flags(typing.Any):Indicates for format for the output.

Returns:

      typing.Any
        
         """
         pass


      def GetMsgStoresTable(self,flags:'typing.Any') -> 'PyIMAPITable':
         """
         Provides access to the message store table - a table with information about all of the message stores in the session profile.

Args:

      flags(typing.Any):Flags that control the opening.

Returns:

      PyIMAPITable
        
         """
         pass


      def GetStatusTable(self,flags:'typing.Any') -> 'PyIMAPITable':
         """
         Provides access to the status table - a table with information about all of the MAPI resources in the session.

Args:

      flags(typing.Any):Flags that control the opening.

Returns:

      PyIMAPITable
        
         """
         pass


      def Logoff(self,uiParm:'typing.Any',flags:'typing.Any',reserved:'typing.Any') -> 'None':
         """
         Ends a MAPI session.

Args:

      uiParm(typing.Any):hwnd of a dialog is to be displayed.
      flags(typing.Any):Bitmask of flags that control the logoff operation.
      reserved(typing.Any):Reserved; must be zero.

Returns:

      None
        
         """
         pass


      def OpenAddressBook(self,uiParm:'typing.Any',iid:'PyIID',flags:'typing.Any') -> 'PyIAddrBook':
         """
         Opens the integrated address book.

Args:

      uiParm(typing.Any):hwnd of a dialog is to be displayed.
      iid(PyIID):The IID of the interface, or None.
      flags(typing.Any):Flags that control the opening - AB_NO_DIALOG.

Returns:

      PyIAddrBook
        
         """
         pass


      def OpenProfileSection(self,iidSection:'PyIID',iid:'PyIID',flags:'typing.Any') -> 'typing.Any':
         """
         Opens a section of the current profile and returns an object for futher access

Args:

      iidSection(PyIID):The MAPIIID of the profile section
      iid(PyIID):The IID of the interface, or None.
      flags(typing.Any):Flags that control the opening.

Returns:

      typing.Any
        
         """
         pass


      def AdminServices(self,flags:'typing.Any'=0) -> 'PyIMsgServiceAdmin':
         """
         Provides access to a message service administration object for making changes to the message services.

Args:

      flags(typing.Any):reserved; must be zero.

Returns:

      PyIMsgServiceAdmin
        
         """
         pass


class PyIMAPIStatus(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ChangePassword(self,oldPassword:'typing.Any',newPassword:'typing.Any',ulFlags:'typing.Any') -> 'None':
         """
         None

Args:

      oldPassword(typing.Any):
      newPassword(typing.Any):
      ulFlags(typing.Any):

Returns:

      None
        
         """
         pass


      def SettingsDialog(self,ulUIParam:'typing.Any',ulFlags:'typing.Any') -> 'None':
         """
         None

Args:

      ulUIParam(typing.Any):
      ulFlags(typing.Any):

Returns:

      None
        
         """
         pass


      def ValidateState(self,ulUIParam:'typing.Any',ulFlags:'typing.Any') -> 'None':
         """
         None

Args:

      ulUIParam(typing.Any):
      ulFlags(typing.Any):

Returns:

      None
        
         """
         pass


      def FlushQueues(self,ulUIParam:'typing.Any',transport:'str',ulFlags:'typing.Any') -> 'None':
         """
         None

Args:

      ulUIParam(typing.Any):
      transport(str):Blob of data
      ulFlags(typing.Any):

Returns:

      None
        
         """
         pass


class PyIMAPITable(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetLastError(self,hr:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Returns the last error code for the object.

Args:

      hr(typing.Any):Contains the error code generated in the previous method call.
      flags(typing.Any):Indicates for format for the output.

Returns:

      typing.Any
        
         """
         pass


      def Advise(self,eventMask:'typing.Any',adviseSink:'typing.Any') -> 'typing.Any':
         """
         Registers to receive notification of specified events affecting the table.

Args:

      eventMask(typing.Any):
      adviseSink(typing.Any):

Returns:

      typing.Any
        
         """
         pass


      def SeekRow(self,bookmark:'typing.Any',rowCount:'typing.Any') -> 'typing.Any':
         """
         Moves the cursor to a specific position in the table.

Args:

      bookmark(typing.Any):The bookmark.
      rowCount(typing.Any):Return ValueThe result is the number of rows processed.

Returns:

      typing.Any:Return ValueThe result is the number of rows processed.

        
         """
         pass


      def SeekRowApprox(self,numerator:'typing.Any',denominator:'typing.Any') -> 'None':
         """
         Moves the cursor to an approximate fractional position in the table.

Args:

      numerator(typing.Any):The numerator of the fraction representing the table position
      denominator(typing.Any):The denominator of the fraction representing the table position. This must not be zero.

Returns:

      None
        
         """
         pass


      def GetRowCount(self,flags:'typing.Any') -> 'typing.Any':
         """
         Returns the total number of rows in the table.

Args:

      flags(typing.Any):Reserved - must be zero

Returns:

      typing.Any
        
         """
         pass


      def QueryRows(self,rowCount:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Returns one or more rows from a table, beginning at the current cursor position.

Args:

      rowCount(typing.Any):Number of rows to retrieve
      flags(typing.Any):Flags.

Returns:

      typing.Any
        
         """
         pass


      def SetColumns(self,propTags:'typing.Any',flags:'typing.Any') -> 'None':
         """
         Defines the particular properties and order of properties to appear as columns in the table.

Args:

      propTags(typing.Any):Sequence of property tags identifying properties to be included as columns in the table.
      flags(typing.Any):

Returns:

      None
        
         """
         pass


      def GetStatus(self,) -> 'None':
         """
         Returns the table's status and type.

Args:



Returns:

      None:PyIMAPITable.GetStatus
GetStatus()Returns the table's status and type.
Return ValueResult is a tuple of (tableStatus, tableType)

        
         """
         pass


      def QueryPosition(self,) -> 'None':
         """
         Retrieves the current table row position of the cursor, based on a fractional value.

Args:



Returns:

      None:PyIMAPITable.QueryPosition
QueryPosition()Retrieves the current table row position of the cursor, based on a fractional value.
Return ValueResult is a tuple of (row, numerator, denominator)

        
         """
         pass


      def QueryColumns(self,flags:'typing.Any') -> 'typing.Any':
         """
         Returns a list of columns for the table.

Args:

      flags(typing.Any):

Returns:

      typing.Any
        
         """
         pass


      def Abort(self,) -> 'None':
         """
         Stops any asynchronous operations currently in progress for the table.

Args:



Returns:

      None
        
         """
         pass


      def FreeBookmark(self,bookmark:'typing.Any') -> 'None':
         """
         Releases the memory associated with a bookmark.

Args:

      bookmark(typing.Any):

Returns:

      None
        
         """
         pass


      def CreateBookmark(self,) -> 'typing.Any':
         """
         Marks the table's current position.

Args:



Returns:

      typing.Any
        
         """
         pass


      def Restrict(self,restriction:'PySRestriction',flags:'typing.Any') -> 'None':
         """
         Applies a filter to a table, reducing the row set to only those rows matching the specified criteria.

Args:

      restriction(PySRestriction):
      flags(typing.Any):

Returns:

      None
        
         """
         pass


      def FindRow(self,restriction:'PySRestriction',bookmarkOrigin:'typing.Any',flags:'typing.Any') -> 'None':
         """
         Finds the next row in a table that matches specific search criteria.

Args:

      restriction(PySRestriction):
      bookmarkOrigin(typing.Any):
      flags(typing.Any):

Returns:

      None
        
         """
         pass


      def SortTable(self,sortOrderSet:'PySSortOrderSet',flags:'typing.Any') -> 'None':
         """
         Orders the rows of the table based on sort criteria.

Args:

      sortOrderSet(PySSortOrderSet):
      flags(typing.Any):

Returns:

      None
        
         """
         pass


      def Unadvise(self,handle:'typing.Any') -> 'None':
         """
         Cancels the sending of notifications previously set up with a call to the IMAPITable::Advise method.

Args:

      handle(typing.Any):Handle returned from PyIMAPITable::Advise

Returns:

      None
        
         """
         pass


class PyIMachineDebugManager(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddApplication(self,pda:'PyIRemoteDebugApplication') -> 'None':
         """
         Description of AddApplication.

Args:

      pda(PyIRemoteDebugApplication):Description for pda

Returns:

      None
        
         """
         pass


      def RemoveApplication(self,dwAppCookie:'typing.Any') -> 'None':
         """
         Description of RemoveApplication.

Args:

      dwAppCookie(typing.Any):Description for dwAppCookie

Returns:

      None
        
         """
         pass


      def EnumApplications(self,) -> 'None':
         """
         Description of EnumApplications.

Args:



Returns:

      None
        
         """
         pass


class PyIMachineDebugManagerEvents(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def onAddApplication(self,pda:'PyIRemoteDebugApplication',dwAppCookie:'typing.Any') -> 'None':
         """
         Description of onAddApplication.

Args:

      pda(PyIRemoteDebugApplication):Description for pda
      dwAppCookie(typing.Any):Description for dwAppCookie

Returns:

      None
        
         """
         pass


      def onRemoveApplication(self,pda:'PyIRemoteDebugApplication',dwAppCookie:'typing.Any') -> 'None':
         """
         Description of onRemoveApplication.

Args:

      pda(PyIRemoteDebugApplication):Description for pda
      dwAppCookie(typing.Any):Description for dwAppCookie

Returns:

      None
        
         """
         pass


class PyIMessage(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetReadFlag(self,flag:'typing.Any') -> 'None':
         """
         Sets the read flags for a message

Args:

      flag(typing.Any):Bitmask of flags that controls the setting of a message's read flag - that is, the message's MSGFLAG_READ flag in its PR_MESSAGE_FLAGS property and the processing of read reports.

Returns:

      None
        
         """
         pass


      def GetAttachmentTable(self,flags:'typing.Any') -> 'PyIMAPITable':
         """
         Returns the message's attachment table.

Args:

      flags(typing.Any):Bitmask of flags that relate to the creation of the table.

Returns:

      PyIMAPITable
        
         """
         pass


      def OpenAttach(self,attachmentNum:'typing.Any',interface:'PyIID',flags:'typing.Any') -> 'PyIAttach':
         """
         Opens an attachment

Args:

      attachmentNum(typing.Any):
      interface(PyIID):The interface to use, or None
      flags(typing.Any):Bitmask of flags that controls how the attachment is opened.

Returns:

      PyIAttach
        
         """
         pass


      def CreateAttach(self,interface:'PyIID',flags:'typing.Any') -> 'typing.Tuple[typing.Any, PyIAttach]':
         """
         Creates an attachment

Args:

      interface(PyIID):The interface to use, or None
      flags(typing.Any):Bitmask of flags that controls how the attachment is created.Return ValueThe result is a tuple of (attachmentNum, attachmentObject)

Returns:

      typing.Tuple[typing.Any, PyIAttach]:Bitmask of flags that controls how the attachment is created.Return ValueThe result is a tuple of (attachmentNum, attachmentObject)

        
         """
         pass


      def DeleteAttach(self,attachmentNum:'typing.Any',ulUIParam:'typing.Any',interface:'typing.Any',flags:'typing.Any') -> 'None':
         """
         Deletes an attachment

Args:

      attachmentNum(typing.Any):
      ulUIParam(typing.Any):
      interface(typing.Any):The interface to use, or None
      flags(typing.Any):Bitmask of flags that controls the display of a user interface.

Returns:

      None
        
         """
         pass


      def ModifyRecipients(self,flags:'typing.Any',mods:'typing.Any') -> 'None':
         """
         adds, deletes, or modifies message recipients.

Args:

      flags(typing.Any):Bitmask of flags that controls the recipient changes. If zero is passed for the ulFlags parameter, ModifyRecipients replaces all existing recipients with the recipient list in the mods parameter.
      mods(typing.Any):The list of recipients.

Returns:

      None
        
         """
         pass


      def GetRecipientTable(self,flags:'typing.Any') -> 'PyIMAPITable':
         """
         Returns the message's recipient table.

Args:

      flags(typing.Any):Bitmask of flags that relate to the creation of the table.

Returns:

      PyIMAPITable
        
         """
         pass


      def SubmitMessage(self,flags:'typing.Any') -> 'None':
         """
         Saves all of the message's properties and marks the message as ready to be sent.

Args:

      flags(typing.Any):Flags which specify how the message is submitted.

Returns:

      None
        
         """
         pass


class PyIMoniker(object):
      """A Python interface to IMoniker"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def BindToObject(self,bindCtx:'PyIBindCtx',moniker:'PyIMoniker',iidResult:'typing.Any') -> 'PyIUnknown':
         """
         Uses the moniker to bind to the object it identifies.

Args:

      bindCtx(PyIBindCtx):bind context object to be used.
      moniker(PyIMoniker):If the moniker is part of a composite moniker, otherwise None
      iidResult(typing.Any):IID of the result object.

Returns:

      PyIUnknown
        
         """
         pass


      def BindToStorage(self,bindCtx:'PyIBindCtx',moniker:'PyIMoniker',iidResult:'typing.Any') -> 'PyIUnknown':
         """
         Retrieves an interface object to the storage that contains the 

object identified by the moniker.

Args:

      bindCtx(PyIBindCtx):bind context object to be used.
      moniker(PyIMoniker):If the moniker is part of a composite moniker, otherwise None
      iidResult(typing.Any):IID of the result object.

Returns:

      PyIUnknown
        
         """
         pass


      def GetDisplayName(self,bindCtx:'PyIBindCtx',moniker:'PyIMoniker') -> 'str':
         """
         Gets the display name , which is a user-readable representation of this 

moniker.

Args:

      bindCtx(PyIBindCtx):bind context object to be used.
      moniker(PyIMoniker):If the moniker is part of a composite moniker, otherwise None

Returns:

      str
        
         """
         pass


      def ComposeWith(self,mkRight:'PyIMoniker',fOnlyIfNotGeneric:'typing.Any') -> 'PyIMoniker':
         """
         Combines the current moniker with another moniker, creating a new 

composite moniker.

Args:

      mkRight(PyIMoniker):The IMoniker interface on the moniker to compose onto the end of this moniker.
      fOnlyIfNotGeneric(typing.Any):If TRUE, the caller requires a non-generic composition, so the operation should proceed only if pmkRight is a moniker class that this moniker can compose with in some way other than forming a generic composite. If FALSE, the method can create a generic composite if necessary.

Returns:

      PyIMoniker
        
         """
         pass


      def Enum(self,fForward:'typing.Any'=True) -> 'PyIEnumMoniker':
         """
         Supplies an enumerator that can enumerate the components of a composite 

moniker.

Args:

      fForward(typing.Any):If TRUE, enumerates the monikers from left to right. If FALSE, enumerates from right to left.

Returns:

      PyIEnumMoniker
        
         """
         pass


      def IsEqual(self,other:'PyIMoniker') -> 'typing.Any':
         """
         Compares this moniker with a specified moniker and indicates whether they are 

identical.

Args:

      other(PyIMoniker):The moniker to compare

Returns:

      typing.Any
        
         """
         pass


      def IsSystemMoniker(self,) -> 'typing.Any':
         """
         Indicates whether this moniker is of one of the system-supplied moniker 

classes.

Args:



Returns:

      typing.Any
        
         """
         pass


      def Hash(self,) -> 'typing.Any':
         """
         Calculates a 32-bit integer using the internal state of the moniker.

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIMsgServiceAdmin(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetLastError(self,hr:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Returns the last error code for the object.

Args:

      hr(typing.Any):Contains the error code generated in the previous method call.
      flags(typing.Any):Indicates for format for the output.

Returns:

      typing.Any
        
         """
         pass


      def CreateMsgService(self,serviceName:'str',displayName:'str',flags:'typing.Any',uiParam:'typing.Any'=0) -> 'None':
         """
         Creates a message service.

Args:

      serviceName(str):The name of the service.
      displayName(str):Display name of the service, or None
      flags(typing.Any):A bitmask of flags that controls how the message service is installed.
      uiParam(typing.Any):A handle of the parent window for any dialog boxes or windows that this method displays.

Returns:

      None
        
         """
         pass


      def ConfigureMsgService(self,iid:'PyIID',ulUIParam:'typing.Any',ulFlags:'typing.Any',arg:'typing.List[typing.Any]') -> 'None':
         """
         Reconfigures a message service.

Args:

      iid(PyIID):The unique identifier for the message service to configure.
      ulUIParam(typing.Any):Handle of the parent window for the configuration property sheet.
      ulFlags(typing.Any):Bitmask of flags that controls the display of the property sheet.
      arg(typing.List[typing.Any]):Property values describing the properties to display in the property sheet.  Should not be None if the service is to be configured without a message service.

Returns:

      None
        
         """
         pass


      def GetMsgServiceTable(self,flags:'typing.Any') -> 'PyIMAPITable':
         """
         Retrieves a table of services.

Args:

      flags(typing.Any):

Returns:

      PyIMAPITable
        
         """
         pass


      def GetProviderTable(self,flags:'typing.Any') -> 'PyIMAPITable':
         """
         Retrieves a table of service providers.

Args:

      flags(typing.Any):

Returns:

      PyIMAPITable
        
         """
         pass


      def DeleteMsgService(self,uuid:'PyIID') -> 'None':
         """
         Deletes the specified service

Args:

      uuid(PyIID):The ID of the service

Returns:

      None
        
         """
         pass


      def RenameMsgService(self,uuid:'PyIID',flags:'typing.Any',newName:'str') -> 'None':
         """
         Renames the specified service

Args:

      uuid(PyIID):The ID of the service
      flags(typing.Any):
      newName(str):The new name for the service.CommentsThis is deprecated, and there is no replacement referenced to use instead.

Returns:

      None
        
         """
         pass


      def OpenProfileSection(self,uuid:'PyIID',iid:'PyIID',flags:'typing.Any') -> 'typing.Any':
         """
         Opens a profile section

Args:

      uuid(PyIID):The ID of the service
      iid(PyIID):The IID of the resulting object, or None for the default
      flags(typing.Any):

Returns:

      typing.Any
        
         """
         pass


      def AdminProviders(self,uuid:'PyIID',flags:'typing.Any') -> 'typing.Any':
         """
         Returns an object providing access 

to a provider administration object.

Args:

      uuid(PyIID):The ID of the service
      flags(typing.Any):

Returns:

      typing.Any
        
         """
         pass


class PyIMsgStore(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def OpenEntry(self,entryId:'str',iid:'PyIID',flags:'typing.Any') -> 'typing.Any':
         """
         Opens a folder or message and returns an interface object for further access.

Args:

      entryId(str):The entryID of the object
      iid(PyIID):The IID of the object to return, or None for the default IID
      flags(typing.Any):Bitmask of flags that controls how the object is opened.

Returns:

      typing.Any
        
         """
         pass


      def GetReceiveFolder(self,messageClass:'str'=None,flags:'typing.Any'=0) -> 'typing.Tuple[PyIID, str]':
         """
         Obtains the folder that was established as the destination for incoming messages of a specified message class or the default receive folder for the message store.

Args:

      messageClass(str):Message class that is associated with a receive folder. If this parameter is set to None or an empty string, GetReceiveFolder returns the default receive folder for the message store.
      flags(typing.Any):

Returns:

      typing.Tuple[PyIID, str]
        
         """
         pass


      def GetReceiveFolderTable(self,flags:'typing.Any') -> 'PyIMAPITable':
         """
         provides access to the receive folder table, a table that includes information about all of the receive folders for the message store.

Args:

      flags(typing.Any):Bitmask of flags that controls table access

Returns:

      PyIMAPITable
        
         """
         pass


      def CompareEntryIDs(self,entryId:'str',entryId1:'str',flags:'typing.Any'=0) -> 'typing.Any':
         """
         Compares two entry identifiers belonging to a particular address book provider to determine if they refer to the same address book object

Args:

      entryId(str):The first entry ID to be compared
      entryId1(str):The second entry ID to be compared
      flags(typing.Any):Reserved - must be zero.Return ValueThe result is set to TRUE if the two entry identifiers refer to the same object, and FALSE otherwise.

Returns:

      typing.Any:Reserved - must be zero.
Return ValueThe result is set to TRUE if the two entry identifiers refer to the same object, and FALSE otherwise.

        
         """
         pass


      def GetLastError(self,hr:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Returns the last error code for the object.

Args:

      hr(typing.Any):Contains the error code generated in the previous method call.
      flags(typing.Any):Indicates for format for the output.

Returns:

      typing.Any
        
         """
         pass


      def AbortSubmit(self,entryId:'str',flags:'typing.Any'=0) -> 'typing.Any':
         """
         Attempts to remove a message from the outgoing queue.

Args:

      entryId(str):The entry ID of the item to be aborted.
      flags(typing.Any):Reserved - must be zero.

Returns:

      typing.Any
        
         """
         pass


      def Advise(self,entryId:'str',eventMask:'typing.Any',adviseSink:'typing.Any') -> 'None':
         """
         Registers to receive notification of specified events that affect the message store.

Args:

      entryId(str):entry identifier of the folder or message about which notifications should be generated, or None
      eventMask(typing.Any):A mask of values that indicate the types of notification events.
      adviseSink(typing.Any):An advise sink.

Returns:

      None
        
         """
         pass


      def Unadvise(self,connection:'typing.Any') -> 'None':
         """
         Cancels the sending of notifications previously set up with a call to the IMsgStore::Advise method.

Args:

      connection(typing.Any):Connection number returned from PyIMsgStore::Advise

Returns:

      None
        
         """
         pass


class PyINameSpaceTreeControl(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,hwndParent:'typing.Union[typing.Any]',prc:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',nsctsFlags:'typing.Any') -> 'None':
         """
         Description of Initialize.

Args:

      hwndParent(typing.Union[typing.Any]):Description for hwndParent
      prc(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Description for prc
      nsctsFlags(typing.Any):Description for nsctsFlags

Returns:

      None
        
         """
         pass


      def TreeAdvise(self,punk:'PyIUnknown') -> 'None':
         """
         Description of TreeAdvise.

Args:

      punk(PyIUnknown):Description for punk

Returns:

      None
        
         """
         pass


      def TreeUnadvise(self,dwCookie:'typing.Any') -> 'None':
         """
         Description of TreeUnadvise.

Args:

      dwCookie(typing.Any):Description for dwCookie

Returns:

      None
        
         """
         pass


      def AppendRoot(self,psiRoot:'PyIShellItem',grfEnumFlags:'typing.Any',grfRootStyle:'typing.Any',pif:'typing.Any') -> 'None':
         """
         Description of AppendRoot.

Args:

      psiRoot(PyIShellItem):Description for psiRoot
      grfEnumFlags(typing.Any):Description for grfEnumFlags
      grfRootStyle(typing.Any):Description for grfRootStyle
      pif(typing.Any):Description for pif

Returns:

      None
        
         """
         pass


      def InsertRoot(self,iIndex:'typing.Any',psiRoot:'PyIShellItem',grfEnumFlags:'typing.Any',grfRootStyle:'typing.Any',pif:'typing.Any') -> 'None':
         """
         Description of InsertRoot.

Args:

      iIndex(typing.Any):Description for iIndex
      psiRoot(PyIShellItem):Description for psiRoot
      grfEnumFlags(typing.Any):Description for grfEnumFlags
      grfRootStyle(typing.Any):Description for grfRootStyle
      pif(typing.Any):Description for pif

Returns:

      None
        
         """
         pass


      def RemoveRoot(self,psiRoot:'PyIShellItem') -> 'None':
         """
         Description of RemoveRoot.

Args:

      psiRoot(PyIShellItem):Description for psiRoot

Returns:

      None
        
         """
         pass


      def RemoveAllRoots(self,) -> 'None':
         """
         Description of RemoveAllRoots.

Args:



Returns:

      None
        
         """
         pass


      def GetRootItems(self,) -> 'None':
         """
         Description of GetRootItems.

Args:



Returns:

      None
        
         """
         pass


      def SetItemState(self,psi:'PyIShellItem',nstcisMask:'typing.Any',nstcisFlags:'typing.Any') -> 'None':
         """
         Description of SetItemState.

Args:

      psi(PyIShellItem):Description for psi
      nstcisMask(typing.Any):Description for nstcisMask
      nstcisFlags(typing.Any):Description for nstcisFlags

Returns:

      None
        
         """
         pass


      def GetItemState(self,psi:'PyIShellItem',nstcisMask:'typing.Any') -> 'None':
         """
         Description of GetItemState.

Args:

      psi(PyIShellItem):Description for psi
      nstcisMask(typing.Any):Description for nstcisMask

Returns:

      None
        
         """
         pass


      def GetSelectedItems(self,) -> 'None':
         """
         Description of GetSelectedItems.

Args:



Returns:

      None
        
         """
         pass


      def GetItemCustomState(self,psi:'PyIShellItem') -> 'None':
         """
         Description of GetItemCustomState.

Args:

      psi(PyIShellItem):Description for psi

Returns:

      None
        
         """
         pass


      def SetItemCustomState(self,psi:'PyIShellItem',iStateNumber:'typing.Any') -> 'None':
         """
         Description of SetItemCustomState.

Args:

      psi(PyIShellItem):Description for psi
      iStateNumber(typing.Any):Description for iStateNumber

Returns:

      None
        
         """
         pass


      def EnsureItemVisible(self,psi:'PyIShellItem') -> 'None':
         """
         Description of EnsureItemVisible.

Args:

      psi(PyIShellItem):Description for psi

Returns:

      None
        
         """
         pass


      def SetTheme(self,pszTheme:'typing.Any') -> 'None':
         """
         Description of SetTheme.

Args:

      pszTheme(typing.Any):Description for pszTheme

Returns:

      None
        
         """
         pass


      def GetNextItem(self,psi:'PyIShellItem',nstcgi:'typing.Any') -> 'None':
         """
         Description of GetNextItem.

Args:

      psi(PyIShellItem):Description for psi
      nstcgi(typing.Any):Description for nstcgi

Returns:

      None
        
         """
         pass


      def HitTest(self,pt:'typing.Tuple[typing.Any, typing.Any]') -> 'None':
         """
         Description of HitTest.

Args:

      pt(typing.Tuple[typing.Any, typing.Any]):Description for ppt

Returns:

      None
        
         """
         pass


      def GetItemRect(self,) -> 'None':
         """
         Description of GetItemRect.

Args:



Returns:

      None
        
         """
         pass


      def CollapseAll(self,) -> 'None':
         """
         Description of CollapseAll.

Args:



Returns:

      None
        
         """
         pass


class PyINamedPropertyStore(object):
      """Contains a collection of properties indentified by name"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetNamedValue(self,Name:'typing.Any') -> 'PyPROPVARIANT':
         """
         Retrieves a property value by name

Args:

      Name(typing.Any):Name of the property

Returns:

      PyPROPVARIANT
        
         """
         pass


      def SetNamedValue(self,propvar:'typing.Any') -> 'None':
         """
         Sets the value of a property

Args:

      propvar(typing.Any):Description for propvar

Returns:

      None
        
         """
         pass


      def GetNameCount(self,) -> 'typing.Any':
         """
         Retrieves the number of named properties in the store

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetNameAt(self,Index:'typing.Any') -> 'typing.Any':
         """
         Retrieves a property name by zero-based index

Args:

      Index(typing.Any):Index of the property name

Returns:

      typing.Any
        
         """
         pass


class PyIObjectArray(object):
      """Holds a collection of interface objects"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetCount(self,) -> 'typing.Any':
         """
         Returns number of objects in collection

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetAt(self,Index:'typing.Any',riid:'PyIID') -> 'PyIUnknown':
         """
         Retrieves an item  by zero-based index

Args:

      Index(typing.Any):Index of item to retrieve
      riid(PyIID):The interface to return

Returns:

      PyIUnknown
        
         """
         pass


class PyIObjectCollection(object):
      """Modifiable container for a number of IUnknown objects"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddObject(self,punk:'PyIUnknown') -> 'None':
         """
         Adds a single object to the collection

Args:

      punk(PyIUnknown):Object to be added

Returns:

      None
        
         """
         pass


      def AddFromArray(self,Source:'PyIObjectArray') -> 'None':
         """
         None

Args:

      Source(PyIObjectArray):Objects to be added to the collection

Returns:

      None
        
         """
         pass


      def RemoveObjectAt(self,Index:'typing.Any') -> 'None':
         """
         Removes a single object from the collection

Args:

      Index(typing.Any):Zero-based index of item to remove

Returns:

      None
        
         """
         pass


      def Clear(self,) -> 'None':
         """
         Empties the container.

Args:



Returns:

      None
        
         """
         pass


class PyIObjectWithPropertyKey(object):
      """Interface implemented by objects that have an associated property id"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetPropertyKey(self,key:'PyPROPERTYKEY') -> 'None':
         """
         Sets the property id

Args:

      key(PyPROPERTYKEY):The identifier of the property

Returns:

      None
        
         """
         pass


      def GetPropertyKey(self,) -> 'PyPROPERTYKEY':
         """
         Returns the property id

Args:



Returns:

      PyPROPERTYKEY
        
         """
         pass


class PyIObjectWithSite(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetSite(self,pUnkSite:'typing.Any') -> 'None':
         """
         Description of SetSite.

Args:

      pUnkSite(typing.Any):Description for pUnkSite

Returns:

      None
        
         """
         pass


      def GetSite(self,riid:'PyIID') -> 'None':
         """
         Description of GetSite.

Args:

      riid(PyIID):Description for riid

Returns:

      None
        
         """
         pass


class PyIOleClientSite(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SaveObject(self,) -> 'None':
         """
         Description of SaveObject.

Args:



Returns:

      None
        
         """
         pass


      def GetMoniker(self,dwAssign:'typing.Any',dwWhichMoniker:'typing.Any') -> 'None':
         """
         Description of GetMoniker.

Args:

      dwAssign(typing.Any):Description for dwAssign
      dwWhichMoniker(typing.Any):Description for dwWhichMoniker

Returns:

      None
        
         """
         pass


      def GetContainer(self,) -> 'None':
         """
         Description of GetContainer.

Args:



Returns:

      None
        
         """
         pass


      def ShowObject(self,) -> 'None':
         """
         Description of ShowObject.

Args:



Returns:

      None
        
         """
         pass


      def OnShowWindow(self,fShow:'typing.Any') -> 'None':
         """
         Description of OnShowWindow.

Args:

      fShow(typing.Any):Description for fShow

Returns:

      None
        
         """
         pass


      def RequestNewObjectLayout(self,) -> 'None':
         """
         Description of RequestNewObjectLayout.

Args:



Returns:

      None
        
         """
         pass


class PyIOleCommandTarget(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def QueryStatus(self,) -> 'None':
         """
         Description of QueryStatus.

Args:



Returns:

      None
        
         """
         pass


      def Exec(self,) -> 'None':
         """
         Description of Exec.

Args:



Returns:

      None
        
         """
         pass


class PyIOleControl(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetControlInfo(self,) -> 'None':
         """
         Description of GetControlInfo.

Args:



Returns:

      None
        
         """
         pass


      def OnMnemonic(self,msg:'typing.Any') -> 'None':
         """
         Description of OnMnemonic.

Args:

      msg(typing.Any):A tuple representing a MSG structure.

Returns:

      None
        
         """
         pass


      def OnAmbientPropertyChange(self,dispID:'typing.Any') -> 'None':
         """
         Description of OnAmbientPropertyChange.

Args:

      dispID(typing.Any):Description for dispID

Returns:

      None
        
         """
         pass


      def FreezeEvents(self,bFreeze:'typing.Any') -> 'None':
         """
         Description of FreezeEvents.

Args:

      bFreeze(typing.Any):Description for bFreeze

Returns:

      None
        
         """
         pass


class PyIOleControlSite(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def OnControlInfoChanged(self,) -> 'None':
         """
         Description of OnControlInfoChanged.

Args:



Returns:

      None
        
         """
         pass


      def LockInPlaceActive(self,fLock:'typing.Any') -> 'None':
         """
         Description of LockInPlaceActive.

Args:

      fLock(typing.Any):Description for fLock

Returns:

      None
        
         """
         pass


      def GetExtendedControl(self,) -> 'None':
         """
         Description of GetExtendedControl.

Args:



Returns:

      None
        
         """
         pass


      def TransformCoords(self,PtlHimetric:'typing.Tuple[typing.Any, typing.Any]',pPtfContainer:'typing.Tuple[float, float]',dwFlags:'typing.Any') -> 'None':
         """
         Description of TransformCoords.

Args:

      PtlHimetric(typing.Tuple[typing.Any, typing.Any]):Description for pPtlHimetric
      pPtfContainer(typing.Tuple[float, float]):Description for pPtfContainer
      dwFlags(typing.Any):Description for dwFlagsReturn ValueThe result is a tuple of the transformed input points - ie, a tuple of ((int, int), (float, float))

Returns:

      None:Description for dwFlagsReturn ValueThe result is a tuple of the transformed input points - ie, 

a tuple of ((int, int), (float, float))

        
         """
         pass


      def TranslateAccelerator(self,pMsg:'PyMSG',grfModifiers:'typing.Any') -> 'None':
         """
         Description of TranslateAccelerator.

Args:

      pMsg(PyMSG):Description for pMsg
      grfModifiers(typing.Any):Description for grfModifiers

Returns:

      None
        
         """
         pass


      def OnFocus(self,fGotFocus:'typing.Any') -> 'None':
         """
         Description of OnFocus.

Args:

      fGotFocus(typing.Any):Description for fGotFocus

Returns:

      None
        
         """
         pass


      def ShowPropertyFrame(self,) -> 'None':
         """
         Description of ShowPropertyFrame.

Args:



Returns:

      None
        
         """
         pass


class PyIOleInPlaceActiveObject(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def TranslateAccelerator(self,lpmsg:'PyMSG') -> 'None':
         """
         Description of TranslateAccelerator.

Args:

      lpmsg(PyMSG):Description for lpmsg

Returns:

      None
        
         """
         pass


      def OnFrameWindowActivate(self,fActivate:'typing.Any') -> 'None':
         """
         Description of OnFrameWindowActivate.

Args:

      fActivate(typing.Any):Description for fActivate

Returns:

      None
        
         """
         pass


      def OnDocWindowActivate(self,fActivate:'typing.Any') -> 'None':
         """
         Description of OnDocWindowActivate.

Args:

      fActivate(typing.Any):Description for fActivate

Returns:

      None
        
         """
         pass


      def ResizeBorder(self,rcBorder:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',pUIWindow:'PyIOleInPlaceUIWindow',fFrameWindow:'typing.Any') -> 'None':
         """
         Description of ResizeBorder.

Args:

      rcBorder(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Description for prcBorder
      pUIWindow(PyIOleInPlaceUIWindow):Description for pUIWindow
      fFrameWindow(typing.Any):Description for fFrameWindow

Returns:

      None
        
         """
         pass


      def EnableModeless(self,fEnable:'typing.Any') -> 'None':
         """
         Description of EnableModeless.

Args:

      fEnable(typing.Any):Description for fEnable

Returns:

      None
        
         """
         pass


class PyIOleInPlaceFrame(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def InsertMenus(self,hmenuShared:'typing.Union[typing.Any]',menuWidths:'PyOLEMENUGROUPWIDTHS') -> 'None':
         """
         Description of InsertMenus.

Args:

      hmenuShared(typing.Union[typing.Any]):Description for hmenuShared
      menuWidths(PyOLEMENUGROUPWIDTHS):

Returns:

      None
        
         """
         pass


      def SetMenu(self,hmenuShared:'typing.Union[typing.Any]',holemenu:'typing.Union[typing.Any]',hwndActiveObject:'typing.Union[typing.Any]') -> 'None':
         """
         Description of SetMenu.

Args:

      hmenuShared(typing.Union[typing.Any]):Description for hmenuShared
      holemenu(typing.Union[typing.Any]):Description for holemenu
      hwndActiveObject(typing.Union[typing.Any]):Description for hwndActiveObject

Returns:

      None
        
         """
         pass


      def RemoveMenus(self,hmenuShared:'typing.Union[typing.Any]') -> 'None':
         """
         Description of RemoveMenus.

Args:

      hmenuShared(typing.Union[typing.Any]):Description for hmenuShared

Returns:

      None
        
         """
         pass


      def SetStatusText(self,pszStatusText:'typing.Any') -> 'None':
         """
         Description of SetStatusText.

Args:

      pszStatusText(typing.Any):Description for pszStatusText

Returns:

      None
        
         """
         pass


      def EnableModeless(self,fEnable:'typing.Any') -> 'None':
         """
         Description of EnableModeless.

Args:

      fEnable(typing.Any):Description for fEnable

Returns:

      None
        
         """
         pass


      def TranslateAccelerator(self,lpmsg:'PyMSG',wID:'typing.Any') -> 'None':
         """
         Description of TranslateAccelerator.

Args:

      lpmsg(PyMSG):Description for lpmsg
      wID(typing.Any):Description for wID

Returns:

      None
        
         """
         pass


class PyIOleInPlaceObject(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def InPlaceDeactivate(self,) -> 'None':
         """
         Description of InPlaceDeactivate.

Args:



Returns:

      None
        
         """
         pass


      def UIDeactivate(self,) -> 'None':
         """
         Description of UIDeactivate.

Args:



Returns:

      None
        
         """
         pass


      def SetObjectRects(self,) -> 'None':
         """
         Description of SetObjectRects.

Args:



Returns:

      None
        
         """
         pass


      def ReactivateAndUndo(self,) -> 'None':
         """
         Description of ReactivateAndUndo.

Args:



Returns:

      None
        
         """
         pass


class PyIOleInPlaceSite(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CanInPlaceActivate(self,) -> 'None':
         """
         Description of CanInPlaceActivate.

Args:



Returns:

      None
        
         """
         pass


      def OnInPlaceActivate(self,) -> 'None':
         """
         Description of OnInPlaceActivate.

Args:



Returns:

      None
        
         """
         pass


      def OnUIActivate(self,) -> 'None':
         """
         Description of OnUIActivate.

Args:



Returns:

      None
        
         """
         pass


      def GetWindowContext(self,) -> 'None':
         """
         Description of GetWindowContext.

Args:



Returns:

      None
        
         """
         pass


      def Scroll(self,) -> 'None':
         """
         Description of Scroll.

Args:



Returns:

      None
        
         """
         pass


      def OnUIDeactivate(self,fUndoable:'typing.Any') -> 'None':
         """
         Description of OnUIDeactivate.

Args:

      fUndoable(typing.Any):Description for fUndoable

Returns:

      None
        
         """
         pass


      def OnInPlaceDeactivate(self,) -> 'None':
         """
         Description of OnInPlaceDeactivate.

Args:



Returns:

      None
        
         """
         pass


      def DiscardUndoState(self,) -> 'None':
         """
         Description of DiscardUndoState.

Args:



Returns:

      None
        
         """
         pass


      def DeactivateAndUndo(self,) -> 'None':
         """
         Description of DeactivateAndUndo.

Args:



Returns:

      None
        
         """
         pass


      def OnPosRectChange(self,) -> 'None':
         """
         Description of OnPosRectChange.

Args:



Returns:

      None
        
         """
         pass


class PyIOleInPlaceSiteEx(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def OnInPlaceActivateEx(self,dwFlags:'typing.Any') -> 'None':
         """
         Description of OnInPlaceActivateEx.

Args:

      dwFlags(typing.Any):Description for dwFlags

Returns:

      None
        
         """
         pass


      def OnInPlaceDeactivateEx(self,fNoRedraw:'typing.Any') -> 'None':
         """
         Description of OnInPlaceDeactivateEx.

Args:

      fNoRedraw(typing.Any):Description for fNoRedraw

Returns:

      None
        
         """
         pass


      def RequestUIActivate(self,) -> 'None':
         """
         Description of RequestUIActivate.

Args:



Returns:

      None
        
         """
         pass


class PyIOleInPlaceSiteWindowless(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CanWindowlessActivate(self,) -> 'None':
         """
         Description of CanWindowlessActivate.

Args:



Returns:

      None
        
         """
         pass


      def GetCapture(self,) -> 'None':
         """
         Description of GetCapture.

Args:



Returns:

      None
        
         """
         pass


      def SetCapture(self,fCapture:'typing.Any') -> 'None':
         """
         Description of SetCapture.

Args:

      fCapture(typing.Any):Description for fCapture

Returns:

      None
        
         """
         pass


      def GetFocus(self,) -> 'None':
         """
         Description of GetFocus.

Args:



Returns:

      None
        
         """
         pass


      def SetFocus(self,fFocus:'typing.Any') -> 'None':
         """
         Description of SetFocus.

Args:

      fFocus(typing.Any):Description for fFocus

Returns:

      None
        
         """
         pass


      def GetDC(self,grfFlags:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'None':
         """
         Description of GetDC.

Args:

      grfFlags(typing.Any):Description for grfFlags
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):

Returns:

      None
        
         """
         pass


      def ReleaseDC(self,hDC:'typing.Any') -> 'None':
         """
         Description of ReleaseDC.

Args:

      hDC(typing.Any):Description for hDC

Returns:

      None
        
         """
         pass


      def InvalidateRect(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',fErase:'typing.Any') -> 'None':
         """
         Description of InvalidateRect.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):
      fErase(typing.Any):Description for fErase

Returns:

      None
        
         """
         pass


      def InvalidateRgn(self,hRgn:'typing.Any',fErase:'typing.Any') -> 'None':
         """
         Description of InvalidateRgn.

Args:

      hRgn(typing.Any):Handle to a region
      fErase(typing.Any):Description for fErase

Returns:

      None
        
         """
         pass


      def ScrollRect(self,dx:'typing.Any',dy:'typing.Any') -> 'None':
         """
         Description of ScrollRect.

Args:

      dx(typing.Any):Description for dx
      dy(typing.Any):Description for dy

Returns:

      None
        
         """
         pass


      def AdjustRect(self,) -> 'None':
         """
         Description of AdjustRect.

Args:



Returns:

      None
        
         """
         pass


      def OnDefWindowMessage(self,msg:'typing.Any',wParam:'typing.Any',lParam:'typing.Any') -> 'None':
         """
         Description of OnDefWindowMessage.

Args:

      msg(typing.Any):Description for msg
      wParam(typing.Any):Description for wParam
      lParam(typing.Any):Description for lParam

Returns:

      None
        
         """
         pass


class PyIOleInPlaceUIWindow(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetBorder(self,) -> 'None':
         """
         Description of GetBorder.

Args:



Returns:

      None
        
         """
         pass


      def RequestBorderSpace(self,borderwidths:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'None':
         """
         Description of RequestBorderSpace.

Args:

      borderwidths(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Description for pborderwidths

Returns:

      None
        
         """
         pass


      def SetBorderSpace(self,borderwidths:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'None':
         """
         Description of SetBorderSpace.

Args:

      borderwidths(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Description for pborderwidths

Returns:

      None
        
         """
         pass


      def SetActiveObject(self,pActiveObject:'PyIOleInPlaceActiveObject',pszObjName:'typing.Any') -> 'None':
         """
         Description of SetActiveObject.

Args:

      pActiveObject(PyIOleInPlaceActiveObject):Description for pActiveObject
      pszObjName(typing.Any):Description for pszObjName

Returns:

      None
        
         """
         pass


class PyIOleObject(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetClientSite(self,pClientSite:'PyIOleClientSite') -> 'None':
         """
         Description of SetClientSite.

Args:

      pClientSite(PyIOleClientSite):Description for pClientSite

Returns:

      None
        
         """
         pass


      def GetClientSite(self,) -> 'None':
         """
         Description of GetClientSite.

Args:



Returns:

      None
        
         """
         pass


      def SetHostNames(self,szContainerApp:'typing.Any',szContainerObj:'typing.Any') -> 'None':
         """
         Description of SetHostNames.

Args:

      szContainerApp(typing.Any):Description for szContainerApp
      szContainerObj(typing.Any):Description for szContainerObj

Returns:

      None
        
         """
         pass


      def Close(self,dwSaveOption:'typing.Any') -> 'None':
         """
         Description of Close.

Args:

      dwSaveOption(typing.Any):Description for dwSaveOption

Returns:

      None
        
         """
         pass


      def SetMoniker(self,dwWhichMoniker:'typing.Any',pmk:'PyIMoniker') -> 'None':
         """
         Description of SetMoniker.

Args:

      dwWhichMoniker(typing.Any):Description for dwWhichMoniker
      pmk(PyIMoniker):Description for pmk

Returns:

      None
        
         """
         pass


      def GetMoniker(self,dwAssign:'typing.Any',dwWhichMoniker:'typing.Any') -> 'None':
         """
         Description of GetMoniker.

Args:

      dwAssign(typing.Any):Description for dwAssign
      dwWhichMoniker(typing.Any):Description for dwWhichMoniker

Returns:

      None
        
         """
         pass


      def InitFromData(self,pDataObject:'PyIDataObject',fCreation:'typing.Any',dwReserved:'typing.Any') -> 'None':
         """
         Description of InitFromData.

Args:

      pDataObject(PyIDataObject):Description for pDataObject
      fCreation(typing.Any):Description for fCreation
      dwReserved(typing.Any):Description for dwReserved

Returns:

      None
        
         """
         pass


      def GetClipboardData(self,dwReserved:'typing.Any') -> 'None':
         """
         Description of GetClipboardData.

Args:

      dwReserved(typing.Any):Description for dwReserved

Returns:

      None
        
         """
         pass


      def DoVerb(self,iVerb:'typing.Any',msg:'PyMSG',pActiveSite:'PyIOleClientSite',lindex:'typing.Any',hwndParent:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'None':
         """
         Description of DoVerb.

Args:

      iVerb(typing.Any):Description for iVerb
      msg(PyMSG):MSG tuple, a-la win32gui etc.
      pActiveSite(PyIOleClientSite):Description for pActiveSite
      lindex(typing.Any):Description for lindex
      hwndParent(typing.Any):Description for hwndParent
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):

Returns:

      None
        
         """
         pass


      def EnumVerbs(self,) -> 'None':
         """
         Description of EnumVerbs.

Args:



Returns:

      None
        
         """
         pass


      def Update(self,) -> 'None':
         """
         Description of Update.

Args:



Returns:

      None
        
         """
         pass


      def IsUpToDate(self,) -> 'None':
         """
         Description of IsUpToDate.

Args:



Returns:

      None
        
         """
         pass


      def GetUserClassID(self,) -> 'None':
         """
         Description of GetUserClassID.

Args:



Returns:

      None
        
         """
         pass


      def GetUserType(self,dwFormOfType:'typing.Any') -> 'None':
         """
         Description of GetUserType.

Args:

      dwFormOfType(typing.Any):Description for dwFormOfType

Returns:

      None
        
         """
         pass


      def SetExtent(self,dwDrawAspect:'typing.Any',size:'typing.Tuple[typing.Any, typing.Any]') -> 'None':
         """
         Description of SetExtent.

Args:

      dwDrawAspect(typing.Any):Description for dwDrawAspect
      size(typing.Tuple[typing.Any, typing.Any]):Size limit for the object.

Returns:

      None
        
         """
         pass


      def GetExtent(self,dwDrawAspect:'typing.Any',size:'typing.Tuple[typing.Any, typing.Any]') -> 'None':
         """
         Description of GetExtent.

Args:

      dwDrawAspect(typing.Any):Description for dwDrawAspect
      size(typing.Tuple[typing.Any, typing.Any]):Size limit for the object.

Returns:

      None
        
         """
         pass


      def Advise(self,pAdvSink:'typing.Any') -> 'None':
         """
         Description of Advise.

Args:

      pAdvSink(typing.Any):Description for pAdvSink

Returns:

      None
        
         """
         pass


      def Unadvise(self,dwConnection:'typing.Any') -> 'None':
         """
         Description of Unadvise.

Args:

      dwConnection(typing.Any):Description for dwConnection

Returns:

      None
        
         """
         pass


      def EnumAdvise(self,) -> 'None':
         """
         Description of EnumAdvise.

Args:



Returns:

      None
        
         """
         pass


      def GetMiscStatus(self,dwAspect:'typing.Any') -> 'None':
         """
         Description of GetMiscStatus.

Args:

      dwAspect(typing.Any):Description for dwAspect

Returns:

      None
        
         """
         pass


      def SetColorScheme(self,) -> 'None':
         """
         Description of SetColorScheme.

Args:



Returns:

      None
        
         """
         pass


class PyIOleWindow(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetWindow(self,) -> 'None':
         """
         Description of GetWindow.

Args:



Returns:

      None
        
         """
         pass


      def ContextSensitiveHelp(self,fEnterMode:'typing.Any') -> 'None':
         """
         Description of ContextSensitiveHelp.

Args:

      fEnterMode(typing.Any):Description for fEnterMode

Returns:

      None
        
         """
         pass


class PyIPersist(object):
      """A Python interface to IPersist"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetClassID(self,) -> 'PyIID':
         """
         Returns the class identifier (CLSID) for the component object.

Args:



Returns:

      PyIID
        
         """
         pass


class PyIPersistFile(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def IsDirty(self,) -> 'None':
         """
         Checks an object for changes since it was last saved to its current file.

Args:



Returns:

      None:PyIPersistFile.IsDirty
IsDirty()Checks an object for changes since it was last saved to its current file.
Return ValueThis method returns the raw COM error code without raising the normal COM exception. 

You should treat any error return codes as an indication that the object has changed. 

Unless this method explicitly returns S_FALSE, assume that the object must be saved.

        
         """
         pass


      def Load(self,FileName:'typing.Any',Mode:'typing.Any') -> 'None':
         """
         Opens the specified file and initializes an object from the file contents.

Args:

      FileName(typing.Any):Absolute path of the file to open
      Mode(typing.Any):Specifies the access mode from the STGM enumeration.

Returns:

      None
        
         """
         pass


      def Save(self,FileName:'typing.Any',fRemember:'typing.Any') -> 'None':
         """
         Saves the object into the specified file.

Args:

      FileName(typing.Any):absolute path of the file where the object is saved.
      fRemember(typing.Any):Specifies whether the file is to be the current working file or not.

Returns:

      None
        
         """
         pass


      def SaveCompleted(self,FileName:'typing.Any') -> 'None':
         """
         Notifies the object that it can revert from NoScribble mode to Normal mode.

Args:

      FileName(typing.Any):Absolute path of the file where the object was saved.

Returns:

      None
        
         """
         pass


      def GetCurFile(self,) -> 'typing.Any':
         """
         Gets the current name of the file associated with the object.

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIPersistFolder(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,pidl:'PyIDL') -> 'None':
         """
         Description of Initialize.

Args:

      pidl(PyIDL):Description for pidl

Returns:

      None
        
         """
         pass


class PyIPersistFolder2(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetCurFolder(self,) -> 'None':
         """
         Description of GetCurFolder.

Args:



Returns:

      None
        
         """
         pass


class PyIPersistPropertyBag(object):
      """A Python wrapper for a COM IPersistPropertyBag interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def InitNew(self,) -> 'None':
         """
         Called by the container when the control is initialized to initialize the 

property bag.

Args:



Returns:

      None
        
         """
         pass


      def Load(self,bag:'PyIPropertyBag',log:'PyIErrorLog'=None) -> 'None':
         """
         Called by the container to load the control's properties.

Args:

      bag(PyIPropertyBag):the caller's property bag.
      log(PyIErrorLog):the caller's error log, or None

Returns:

      None
        
         """
         pass


      def Save(self,bag:'PyIPropertyBag',clearDirty:'typing.Any',saveProperties:'typing.Any') -> 'None':
         """
         Called by the container to save the object's properties.

Args:

      bag(PyIPropertyBag):the caller's property bag.
      clearDirty(typing.Any):Specifies whether to clear the dirty flag.
      saveProperties(typing.Any):Specifies whether to save all properties or just those that have changed

Returns:

      None
        
         """
         pass


class PyIPersistSerializedPropStorage(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetFlags(self,flags:'typing.Any') -> 'None':
         """
         Sets flags for the store

Args:

      flags(typing.Any):Combination of pscon.FPSPS_* values

Returns:

      None
        
         """
         pass


      def SetPropertyStorage(self,ps:'typing.Any') -> 'None':
         """
         Initializes the store with a serialized buffer

Args:

      ps(typing.Any):Bytes or buffer object containing a serialized property store

Returns:

      None
        
         """
         pass


      def GetPropertyStorage(self,) -> 'typing.Any':
         """
         Retrieves the current contents of the property 

store

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIPersistStorage(object):
      """A Python wrapper of a COM IPersistStorage interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def IsDirty(self,) -> 'typing.Any':
         """
         Checks the object for changes since it was last saved.

Args:



Returns:

      typing.Any
        
         """
         pass


      def InitNew(self,PyIStorage:'PyIStorage') -> 'None':
         """
         Initializes a new object, providing a storage object to be used for the object.

Args:

      PyIStorage(PyIStorage):PyIStorage for the new storage object to be initialized. The container creates a nested storage object in its storage object (see PyIStorage::CreateStorage). Then, the container calls the PyIPersistStorage::WriteClassStg function to initialize the new storage object with the object class identifier (CLSID).

Returns:

      None
        
         """
         pass


      def Load(self,storage:'PyIStorage') -> 'None':
         """
         Loads an object from its existing storage.

Args:

      storage(PyIStorage):Existing storage for the object.

Returns:

      None
        
         """
         pass


      def Save(self,PyIStorage:'PyIStorage',_int:'typing.Any') -> 'None':
         """
         None

Args:

      PyIStorage(PyIStorage):Storage for the object
      _int(typing.Any):Indicates whether the specified storage object is the current one. This parameter is set to FALSE when performing a Save As or Save A Copy To operation or when performing a full save. In the latter case, this method saves to a temporary file, deletes the original file, and renames the temporary file. This parameter is set to TRUE to perform a full save in a low-memory situation or to perform a fast incremental save in which only the dirty components are saved.

Returns:

      None
        
         """
         pass


      def SaveCompleted(self,PyIStorage:'PyIStorage') -> 'None':
         """
         None

Args:

      PyIStorage(PyIStorage):The current storage object

Returns:

      None
        
         """
         pass


      def HandsOffStorage(self,) -> 'None':
         """
         Instructs the object to release all storage objects that have been 

passed to it by its container and to enter HandsOff mode, in which the object cannot do anything and the only 

operation that works is a close operation.

Args:



Returns:

      None
        
         """
         pass


class PyIPersistStream(object):
      """A Python interface to IPersistStream"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def IsDirty(self,) -> 'typing.Any':
         """
         Checks the object for changes since it was last saved.

Args:



Returns:

      typing.Any
        
         """
         pass


      def Load(self,stream:'PyIStream') -> 'None':
         """
         Initializes an object from the stream where it was previously saved.

Args:

      stream(PyIStream):Stream object to load from.CommentsThis method loads an object from its associated stream. The seek pointer is set as it was in the most recent PyIPersistStream::Save method. This method can seek and read from the stream, but cannot write to it.On exit, the seek pointer must be in the same position it was in on entry, immediately past the end of the data.

Returns:

      None
        
         """
         pass


      def Save(self,stream:'PyIStream',bClearDirty:'typing.Any') -> 'None':
         """
         Saves an object to the specified stream.

Args:

      stream(PyIStream):The stream to save to.
      bClearDirty(typing.Any):Indicates whether to clear the dirty flag after the save is complete

Returns:

      None
        
         """
         pass


      def GetSizeMax(self,) -> 'ULARGE_INTEGER':
         """
         Returns the size in bytes of the stream needed to save the 

object.

Args:



Returns:

      ULARGE_INTEGER
        
         """
         pass


class PyIPersistStreamInit(object):
      """A Python interface to IPersistStreamInit"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def InitNew(self,) -> 'None':
         """
         Initializes the object to a default state.

Args:



Returns:

      None
        
         """
         pass


class PyIProcessDebugManager(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateApplication(self,) -> 'None':
         """
         Description of CreateApplication.

Args:



Returns:

      None
        
         """
         pass


      def GetDefaultApplication(self,) -> 'None':
         """
         Description of GetDefaultApplication.

Args:



Returns:

      None
        
         """
         pass


      def AddApplication(self,pda:'PyIDebugApplication') -> 'None':
         """
         Description of AddApplication.

Args:

      pda(PyIDebugApplication):Description for pda

Returns:

      None
        
         """
         pass


      def RemoveApplication(self,dwAppCookie:'typing.Any') -> 'None':
         """
         Description of RemoveApplication.

Args:

      dwAppCookie(typing.Any):Description for dwAppCookie

Returns:

      None
        
         """
         pass


      def CreateDebugDocumentHelper(self,unkOuter:'typing.Any') -> 'None':
         """
         Description of CreateDebugDocumentHelper.

Args:

      unkOuter(typing.Any):The outer object for aggregation, or (usually!) None

Returns:

      None
        
         """
         pass


class PyIProfAdmin(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetLastError(self,hr:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Returns the last error code for the object.

Args:

      hr(typing.Any):Contains the error code generated in the previous method call.
      flags(typing.Any):Indicates for format for the output.

Returns:

      typing.Any
        
         """
         pass


      def CreateProfile(self,oldProfileName:'str',Password:'str',uiParam:'typing.Any'=0,flags:'typing.Any'=0) -> 'None':
         """
         Creates a new profile.

Args:

      oldProfileName(str):The name of the new profile.
      Password(str):Must be None
      uiParam(typing.Any):A handle of the parent window for any dialog boxes or windows that this method displays.
      flags(typing.Any):

Returns:

      None
        
         """
         pass


      def DeleteProfile(self,oldProfileName:'str',flags:'typing.Any'=0) -> 'None':
         """
         Deletes a profile.

Args:

      oldProfileName(str):The name of the profile to be deleted.
      flags(typing.Any):

Returns:

      None
        
         """
         pass


      def CopyProfile(self,oldProfileName:'str',Password:'str',newProfileName:'str',uiParam:'typing.Any'=0,flags:'typing.Any'=0) -> 'None':
         """
         Copies a profile.

Args:

      oldProfileName(str):The name of the profile to copy.
      Password(str):Must be None
      newProfileName(str):The new name of the copied profile.
      uiParam(typing.Any):A handle of the parent window for any dialog boxes or windows that this method displays.
      flags(typing.Any):

Returns:

      None
        
         """
         pass


      def RenameProfile(self,oldProfileName:'str',Password:'str',newProfileName:'str',uiParam:'typing.Any'=0,flags:'typing.Any'=0) -> 'None':
         """
         Assigns a new name to a profile.

Args:

      oldProfileName(str):The current name of the profile to rename.
      Password(str):Must be None
      newProfileName(str):The new name of the profile to rename.
      uiParam(typing.Any):A handle of the parent window for any dialog boxes or windows that this method displays.
      flags(typing.Any):

Returns:

      None
        
         """
         pass


      def SetDefaultProfile(self,profileName:'str',flags:'typing.Any'=0) -> 'None':
         """
         Sets or clears a client's default profile.

Args:

      profileName(str):The name of the profile that will become the default, or None. Setting profileName to None indicates that SetDefaultProfile should remove the existing default profile, leaving the client without a default.
      flags(typing.Any):

Returns:

      None
        
         """
         pass


      def AdminServices(self,profileName:'str',Password:'str'=None,uiParam:'typing.Any'=0,flags:'typing.Any'=0) -> 'PyIProfAdmin':
         """
         Provides access to a message service administration object for making changes to the message services in a profile.

Args:

      profileName(str):The name of the profile to be modified.
      Password(str):
      uiParam(typing.Any):A handle of the parent window for any dialog boxes or windows that this method displays.
      flags(typing.Any):

Returns:

      PyIProfAdmin
        
         """
         pass


class PyIPropertyBag(object):
      """A Python wrapper for a COM IPropertyBag interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Read(self,propName:'typing.Any',propType:'typing.Any',errorLog:'PyIErrorLog'=None) -> 'typing.Any':
         """
         Called by the control to read a property from the storage provided by the 

container.

Args:

      propName(typing.Any):Name of the property to read.
      propType(typing.Any):The type of the object to read.  Must be a VT_* Variant Type constant.
      errorLog(PyIErrorLog):The caller's PyIErrorLog object in which the property bag stores any errors that occur during reads. Can be None in which case the caller is not interested in errors.CommentsThe result is a Python object, mapped from a COM VARIANT of type as specified in the propType parameter.

Returns:

      typing.Any
        
         """
         pass


      def Write(self,propName:'typing.Any',value:'typing.Any') -> 'None':
         """
         Called by the control to write each property in turn to the storage provided by the 

container.

Args:

      propName(typing.Any):Name of the property to read.
      value(typing.Any):The value for the property.  The value must be able to be converted to a COM VARIANT.

Returns:

      None
        
         """
         pass


class PyIPropertyChange(object):
      """Interface used to specify a change to a property"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ApplyToPropVariant(self,OrigVal:'PyPROPVARIANT') -> 'PyPROPVARIANT':
         """
         Applies the change to a variant value

Args:

      OrigVal(PyPROPVARIANT):The value to be modified

Returns:

      PyPROPVARIANT
        
         """
         pass


class PyIPropertyChangeArray(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetCount(self,) -> 'typing.Any':
         """
         Returns the number of changes in the array

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetAt(self,Index:'typing.Any',riid:'PyIID') -> 'PyIPropertyChange':
         """
         Retrieves a change by zero-based index

Args:

      Index(typing.Any):Index of the change to retrieve
      riid(PyIID):The interface to return

Returns:

      PyIPropertyChange
        
         """
         pass


      def InsertAt(self,Index:'typing.Any',PropChange:'PyIPropertyChange') -> 'None':
         """
         Inserts a change at a specific position

Args:

      Index(typing.Any):Position at which to place the change
      PropChange(PyIPropertyChange):The change to be added

Returns:

      None
        
         """
         pass


      def Append(self,PropChange:'PyIPropertyChange') -> 'None':
         """
         Adds a change to the end of the array

Args:

      PropChange(PyIPropertyChange):The change to be added

Returns:

      None
        
         """
         pass


      def AppendOrReplace(self,PropChange:'PyIPropertyChange') -> 'None':
         """
         Adds a change, or replaces if an identical property key is already 

in container

Args:

      PropChange(PyIPropertyChange):The change to be added or replaced

Returns:

      None
        
         """
         pass


      def RemoveAt(self,Index:'typing.Any') -> 'None':
         """
         Removes a change from the array

Args:

      Index(typing.Any):Index of change to be removed

Returns:

      None
        
         """
         pass


      def IsKeyInArray(self,key:'PyPROPERTYKEY') -> 'typing.Any':
         """
         Checks if array contains a change to a property

Args:

      key(PyPROPERTYKEY):Property key to look for

Returns:

      typing.Any
        
         """
         pass


class PyIPropertyDescription(object):
      """Gives access to the details of a property definition"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPropertyKey(self,) -> 'PyPROPERTYKEY':
         """
         Returns the unique identifier for a property

Args:



Returns:

      PyPROPERTYKEY
        
         """
         pass


      def GetCanonicalName(self,) -> 'typing.Any':
         """
         Returns the name of the property

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetPropertyType(self,) -> 'typing.Any':
         """
         Returns the variant type of the property (VT_*)

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetDisplayName(self,) -> 'typing.Any':
         """
         Returns the property name as shown in the UI

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetEditInvitation(self,) -> 'typing.Any':
         """
         Returns the input prompt used in edit controls

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetTypeFlags(self,mask:'typing.Any') -> 'typing.Any':
         """
         Returns type flags for the property

Args:

      mask(typing.Any):Specifies which flags to retrieve (PDTF_*)

Returns:

      typing.Any
        
         """
         pass


      def GetViewFlags(self,) -> 'typing.Any':
         """
         Returns the view flags that control how the property is displayed 

(PDVF_*)

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetDefaultColumnWidth(self,) -> 'typing.Any':
         """
         Returns the default width in characters

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetDisplayType(self,) -> 'typing.Any':
         """
         Returns the display type (PDDT_*)

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetColumnState(self,) -> 'typing.Any':
         """
         Returns flags that control how property is displayed in column 

(SHCOLSTATE_*)

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetGroupingRange(self,) -> 'typing.Any':
         """
         Returns property's grouping attributes (PDGR_*)

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetRelativeDescriptionType(self,) -> 'typing.Any':
         """
         Returns the relative description type (PDRDT_*)

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetRelativeDescription(self,var1:'PyPROPVARIANT',var2:'PyPROPVARIANT') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Compares two values

Args:

      var1(PyPROPVARIANT):The first value
      var2(PyPROPVARIANT):The second value

Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def GetSortDescription(self,) -> 'typing.Any':
         """
         Returns value that determines how sorting options are 

displayed (PDSD_*)

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSortDescriptionLabel(self,Descending:'typing.Any') -> 'typing.Any':
         """
         Returns description of current sort order

Args:

      Descending(typing.Any):Indicates if order is reversed

Returns:

      typing.Any
        
         """
         pass


      def GetAggregationType(self,) -> 'typing.Any':
         """
         Describes how properties for multiple items are displayed 

(PDAT_*)

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetConditionType(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Returns options that determine how the property is used 

to build a search query

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]:PyIPropertyDescription.GetConditionType

(int, int) = GetConditionType()Returns options that determine how the property is used 

to build a search query
Return ValueReturns the condition type (PDCOT_*) and default operation (COP_*)

        
         """
         pass


      def GetEnumTypeList(self,riid:'PyIID') -> 'PyIPropertyEnumTypeList':
         """
         Returns an interface used for querying 

valid property range

Args:

      riid(PyIID):IID of the requested interface

Returns:

      PyIPropertyEnumTypeList
        
         """
         pass


      def CoerceToCanonicalValue(self,Value:'PyPROPVARIANT') -> 'typing.Any':
         """
         Converts a variant value to the exact type expected by 

the property

Args:

      Value(PyPROPVARIANT):The property value to be convertedCommentsThis method mutates the PyPROPVARIANT in place.  It may be cleared on failure.Return ValueReturns the HRESULT from the operation on success.

Returns:

      typing.Any:The property value to be convertedComments

This method mutates the PyPROPVARIANT in place.  It may be cleared on failure.
Return ValueReturns the HRESULT from the operation on success.

        
         """
         pass


      def FormatForDisplay(self,Value:'PyPROPVARIANT',Flags:'typing.Any') -> 'typing.Any':
         """
         Converts a value to its string representation

Args:

      Value(PyPROPVARIANT):The value to be formatted
      Flags(typing.Any):Combination of PROPDESC_FORMAT_FLAGS (PDFF_*)

Returns:

      typing.Any
        
         """
         pass


      def IsValueCanonical(self,Value:'typing.Any') -> 'typing.Any':
         """
         Determines if a value exactly matches the specification for 

the property

Args:

      Value(typing.Any):The value to check

Returns:

      typing.Any
        
         """
         pass


class PyIPropertyDescriptionAliasInfo(object):
      """Interface that gives access to the sorting columns for a property"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetSortByAlias(self,riid:'PyIID') -> 'PyIPropertyDescription':
         """
         Returns the primary column used 

for sorting

Args:

      riid(PyIID):The interface to return

Returns:

      PyIPropertyDescription
        
         """
         pass


      def GetAdditionalSortByAliases(self,riid:'PyIID') -> 'PyIPropertyDescriptionList':
         """
         Returns secondary 

sorting columns

Args:

      riid(PyIID):The interface to return

Returns:

      PyIPropertyDescriptionList
        
         """
         pass


class PyIPropertyDescriptionList(object):
      """Container for a number of property descriptions"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetCount(self,) -> 'typing.Any':
         """
         Gets the number of properties in the list

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetAt(self,Elem:'typing.Any',riid:'PyIID') -> 'PyIPropertyDescription':
         """
         Retrieves a description from the list

Args:

      Elem(typing.Any):Index of the element to return
      riid(PyIID):The interface to return

Returns:

      PyIPropertyDescription
        
         """
         pass


class PyIPropertyDescriptionSearchInfo(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetSearchInfoFlags(self,) -> 'typing.Any':
         """
         Returns flags controlling how property is indexed

Args:



Returns:

      typing.Any:PyIPropertyDescriptionSearchInfo.GetSearchInfoFlags

int = GetSearchInfoFlags()Returns flags controlling how property is indexed
Return ValueReturns a combination of PROPDESC_SEARCHINFO_FLAGS values

        
         """
         pass


      def GetColumnIndexType(self,) -> 'typing.Any':
         """
         Returns flags indicating type of property

Args:



Returns:

      typing.Any:PyIPropertyDescriptionSearchInfo.GetColumnIndexType

int = GetColumnIndexType()Returns flags indicating type of property
Return ValueReturns a value from the PROPDESC_COLUMNINDEX_TYPE enum

        
         """
         pass


      def GetProjectionString(self,) -> 'typing.Any':
         """
         Returns the canonical name of the property

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetMaxSize(self,) -> 'typing.Any':
         """
         Returns the maximum size specified in search options

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIPropertyEnumType(object):
      """Contains information about an allowable value or range for a property"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetEnumType(self,) -> 'typing.Any':
         """
         Retrieves the type (PROPENUMTYPE)

Args:



Returns:

      typing.Any:PyIPropertyEnumType.GetEnumType

int = GetEnumType()Retrieves the type (PROPENUMTYPE)
Return Valuepscon.PET_*

        
         """
         pass


      def GetValue(self,) -> 'PyPROPVARIANT':
         """
         Retrieves the defined value

Args:



Returns:

      PyPROPVARIANT
        
         """
         pass


      def GetRangeMinValue(self,) -> 'PyPROPVARIANT':
         """
         Returns the minimum allowed value for the property

Args:



Returns:

      PyPROPVARIANT
        
         """
         pass


      def GetRangeSetValue(self,) -> 'PyPROPVARIANT':
         """
         Returns a fixed value defined for the property

Args:



Returns:

      PyPROPVARIANT
        
         """
         pass


      def GetDisplayText(self,) -> 'None':
         """
         Returns the display text for the enumerated type

Args:



Returns:

      None
        
         """
         pass


class PyIPropertyEnumTypeList(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetCount(self,) -> 'typing.Any':
         """
         Returns the number of objects in the list

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetAt(self,itype:'typing.Any',riid:'PyIID') -> 'PyIPropertyEnumType':
         """
         Retrieves an item by index

Args:

      itype(typing.Any):Zero based index of type to return
      riid(PyIID):The interface to return

Returns:

      PyIPropertyEnumType
        
         """
         pass


      def FindMatchingIndex(self,Cmp:'PyPROPVARIANT') -> 'typing.Any':
         """
         Attempts to match the specified value to one of the allowable 

values for the property

Args:

      Cmp(PyPROPVARIANT):A value to match against the defined values of the property

Returns:

      typing.Any
        
         """
         pass


class PyIPropertySetStorage(object):
      """Container for a collection of property sets. 

Can be iterated over to enumerate property sets."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Create(self,fmtid:'PyIID',clsid:'PyIID',Flags:'typing.Any',Mode:'typing.Any') -> 'PyIPropertyStorage':
         """
         Creates a new property set in the storage object

Args:

      fmtid(PyIID):GUID identifying a property set, pythoncom.FMTID_*
      clsid(PyIID):CLSID of property set handler, usually same as fmtid
      Flags(typing.Any):Specifies behaviour of property set, storagecon.PROPSETFLAG_*
      Mode(typing.Any):Access mode, combination of storagecon.STGM_* flags

Returns:

      PyIPropertyStorage
        
         """
         pass


      def Open(self,fmtid:'PyIID',Mode:'typing.Any') -> 'PyIPropertyStorage':
         """
         Opens an existing property set

Args:

      fmtid(PyIID):GUID of a property set, pythoncom.FMTID_*
      Mode(typing.Any):Access mode, combination of storagecon.STGM_* flags

Returns:

      PyIPropertyStorage
        
         """
         pass


      def Delete(self,fmtid:'PyIID') -> 'None':
         """
         Removes a property set from this storage object

Args:

      fmtid(PyIID):GUID of a property set, pythoncom.FMTID_*

Returns:

      None
        
         """
         pass


      def Enum(self,) -> 'PyIEnumSTATPROPSETSTG':
         """
         Creates an iterator to enumerate contained property 

sets

Args:



Returns:

      PyIEnumSTATPROPSETSTG
        
         """
         pass


class PyIPropertyStorage(object):
      """Structured storage object that contains a set of properties. 

Supports iteration to list properties."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ReadMultiple(self,props:'typing.Tuple[PROPSPEC, ...]') -> 'typing.Tuple[typing.Any, ...]':
         """
         Reads specified properties from the current property set.

Args:

      props(typing.Tuple[PROPSPEC, ...]):Sequence of property IDs or names.Return ValueReturned values are automatically converted to an appropriate python type

Returns:

      typing.Tuple[typing.Any, ...]:Sequence of property IDs or names.Return ValueReturned values are automatically converted to an appropriate python type

        
         """
         pass


      def WriteMultiple(self,props:'typing.Tuple[PROPSPEC, ...]',values:'typing.Tuple[typing.Any, ...]',propidNameFirst:'typing.Any'=2) -> 'None':
         """
         Creates or modifies properties in the property set

Args:

      props(typing.Tuple[PROPSPEC, ...]):Sequence containing names or integer ids of properties to write
      values(typing.Tuple[typing.Any, ...]):The values for the properties.
      propidNameFirst(typing.Any):Minimum property id to be assigned to new properties specified by name

Returns:

      None
        
         """
         pass


      def DeleteMultiple(self,props:'typing.Tuple[PROPSPEC, ...]') -> 'None':
         """
         Deletes properties from the property set

Args:

      props(typing.Tuple[PROPSPEC, ...]):Sequence containing names or IDs of properties to be deleted

Returns:

      None
        
         """
         pass


      def ReadPropertyNames(self,props:'typing.Tuple[typing.Any, ...]') -> 'typing.Tuple[typing.Any, ...]':
         """
         Retrieves any existing string names for the specified 

property identifiers.

Args:

      props(typing.Tuple[typing.Any, ...]):Sequence of ints containing property IDs.

Returns:

      typing.Tuple[typing.Any, ...]
        
         """
         pass


      def WritePropertyNames(self,props:'typing.Tuple[typing.Any, ...]',names:'typing.Tuple[str, ...]') -> 'None':
         """
         Assigns string names to a specified array of property IDs in the 

current property set.

Args:

      props(typing.Tuple[typing.Any, ...]):Sequence containing the property IDs.
      names(typing.Tuple[str, ...]):Equal length sequence of property names.

Returns:

      None
        
         """
         pass


      def DeletePropertyNames(self,props:'typing.Tuple[typing.Any, ...]') -> 'None':
         """
         Removes property names from specified properties.

Args:

      props(typing.Tuple[typing.Any, ...]):Sequence of ints containing property IDs.

Returns:

      None
        
         """
         pass


      def Commit(self,CommitFlags:'typing.Any') -> 'None':
         """
         Persists the property set to its base storage

Args:

      CommitFlags(typing.Any):Combination of storagecon.STGC_* flags

Returns:

      None
        
         """
         pass


      def Revert(self,) -> 'None':
         """
         Discards any changes that have been made

Args:



Returns:

      None
        
         """
         pass


      def Enum(self,) -> 'PyIEnumSTATPROPSTG':
         """
         Creates an enumerator for properties in the property set

Args:



Returns:

      PyIEnumSTATPROPSTG
        
         """
         pass


      def SetTimes(self,ctime:'PyTime',atime:'PyTime',mtime:'PyTime') -> 'None':
         """
         Sets the creation, last access, and modification time

Args:

      ctime(PyTime):Creation time, or None for no change
      atime(PyTime):Last access time, or None for no change
      mtime(PyTime):Modification time, or None for no changeCommentsSome property sets do not support these times.

Returns:

      None
        
         """
         pass


      def SetClass(self,clsid:'PyIID') -> 'None':
         """
         Sets the GUID for the property set

Args:

      clsid(PyIID):Description for clsid

Returns:

      None
        
         """
         pass


      def Stat(self,) -> 'typing.Any':
         """
         Returns various infomation about the property set

Args:



Returns:

      typing.Any:PyIPropertyStorage.Stat

tuple = Stat()Returns various infomation about the property set
Return ValueReturns a tuple representing a STATPROPSETSTG struct.

        
         """
         pass


class PyIPropertyStore(object):
      """Contains a collection of properties"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetCount(self,) -> 'typing.Any':
         """
         Returns the number of properties in the store

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetAt(self,iProp:'typing.Any') -> 'PyPROPERTYKEY':
         """
         Returns the property key for the specified property

Args:

      iProp(typing.Any):Zero-based index of property

Returns:

      PyPROPERTYKEY
        
         """
         pass


      def GetValue(self,Key:'PyPROPERTYKEY') -> 'PyPROPVARIANT':
         """
         Retrieves the value of a property

Args:

      Key(PyPROPERTYKEY):Property key as returned by PyIPropertyStore::GetAt

Returns:

      PyPROPVARIANT
        
         """
         pass


      def SetValue(self,Key:'PyPROPERTYKEY',Value:'PyPROPVARIANT') -> 'None':
         """
         Sets the value of a property

Args:

      Key(PyPROPERTYKEY):Property key (see PyIPropertyStore::GetAt)
      Value(PyPROPVARIANT):Variant value which can be converted to the appropriate variant type for the property Pass a VT_EMPTY variant to indicate that the property should be removed.

Returns:

      None
        
         """
         pass


      def Commit(self,) -> 'None':
         """
         Commits property changes

Args:



Returns:

      None
        
         """
         pass


class PyIPropertyStoreCache(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetState(self,key:'PyPROPERTYKEY') -> 'typing.Any':
         """
         Retrieves the current state of a property

Args:

      key(PyPROPERTYKEY):Property identifierReturn ValueA value from the PSC_STATE enum (PSC_NORMAL, PSC_NOTINSOURCE. PSC_DIRTY)

Returns:

      typing.Any:Property identifierReturn ValueA value from the PSC_STATE enum (PSC_NORMAL, PSC_NOTINSOURCE. PSC_DIRTY)

        
         """
         pass


      def GetValueAndState(self,key:'PyPROPERTYKEY') -> 'typing.Tuple[PyPROPVARIANT, typing.Any]':
         """
         Retrieves the current value and state of a 

property

Args:

      key(PyPROPERTYKEY):Property identifier

Returns:

      typing.Tuple[PyPROPVARIANT, typing.Any]
        
         """
         pass


      def SetState(self,key:'PyPROPERTYKEY',state:'typing.Any') -> 'None':
         """
         Sets the state of a property

Args:

      key(PyPROPERTYKEY):Property identifier
      state(typing.Any):Value from the PSC_STATE enum (pscon.PSC_*)

Returns:

      None
        
         """
         pass


      def SetValueAndState(self,key:'PyPROPERTYKEY',value:'PyPROPVARIANT',state:'typing.Any') -> 'None':
         """
         Sets the value and state of a property

Args:

      key(PyPROPERTYKEY):Property identifier
      value(PyPROPVARIANT):The new value
      state(typing.Any):The new state (pscon.PSC_*)

Returns:

      None
        
         """
         pass


class PyIPropertyStoreCapabilities(object):
      """Property providers use this interface to indicate whether properties are 

writeable."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def IsPropertyWritable(self,key:'PyPROPERTYKEY') -> 'typing.Any':
         """
         Asks provider if a property can be editted.

Args:

      key(PyPROPERTYKEY):Property identifier

Returns:

      typing.Any
        
         """
         pass


class PyIPropertySystem(object):
      """Wraps the IPropertySystem interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPropertyDescription(self,Key:'PyPROPERTYKEY',riid:'PyIID') -> 'PyIPropertyDescription':
         """
         Returns an interface used to describe a 

property

Args:

      Key(PyPROPERTYKEY):Fmtid and propertyid that uniquely identifies a property
      riid(PyIID):The interface to return

Returns:

      PyIPropertyDescription
        
         """
         pass


      def GetPropertyDescriptionByName(self,CanonicalName:'typing.Any',riid:'PyIID') -> 'PyIPropertyDescription':
         """
         Returns an interface used to 

describe a property

Args:

      CanonicalName(typing.Any):Registered name of the property
      riid(PyIID):The interface to return

Returns:

      PyIPropertyDescription
        
         """
         pass


      def GetPropertyDescriptionListFromString(self,PropList:'typing.Any',riid:'PyIID') -> 'PyIPropertyDescriptionList':
         """
         Retrieves property 

descriptions from a string of property names

Args:

      PropList(typing.Any):String containing a list of properties and flags
      riid(PyIID):The interface to return

Returns:

      PyIPropertyDescriptionList
        
         """
         pass


      def EnumeratePropertyDescriptions(self,Filter:'typing.Any',riid:'PyIID') -> 'PyIPropertyDescriptionList':
         """
         Returns an interface used to 

list defined properties

Args:

      Filter(typing.Any):Value from PROPDESC_ENUMFILTER (pscon.PDEF_*) that limits what types of properties are listed
      riid(PyIID):The interface to return

Returns:

      PyIPropertyDescriptionList
        
         """
         pass


      def FormatForDisplay(self,Key:'PyPROPERTYKEY',Value:'PyPROPVARIANT',Flags:'typing.Any') -> 'typing.Any':
         """
         Formats a property into a string

Args:

      Key(PyPROPERTYKEY):Fmtid and property id that identifies the property
      Value(PyPROPVARIANT):The value to format
      Flags(typing.Any):Combination of PROPDESC_FORMAT_FLAGS (pscon.PDFF_*) indicating formatting options

Returns:

      typing.Any
        
         """
         pass


      def RegisterPropertySchema(self,Path:'typing.Any') -> 'None':
         """
         Registers a set of properties defined in a .propdesc file

Args:

      Path(typing.Any):Path to a property schema XML file (.propdesc)

Returns:

      None
        
         """
         pass


      def UnregisterPropertySchema(self,Path:'typing.Any') -> 'None':
         """
         Removes a set of registered properties

Args:

      Path(typing.Any):Path to a property schema XML file (.propdesc)

Returns:

      None
        
         """
         pass


      def RefreshPropertySchema(self,) -> 'None':
         """
         Not currently implemented by the OS

Args:



Returns:

      None
        
         """
         pass


class PyIProvideClassInfo(object):
      """A Python interface to IProvideClassInfo"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetClassInfo(self,) -> 'PyITypeInfo':
         """
         Gets information about the CO_CLASS.

Args:



Returns:

      PyITypeInfo
        
         """
         pass


class PyIProvideClassInfo2(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetGUID(self,flags:'typing.Any') -> 'PyIID':
         """
         Gets the GUID for the object.

Args:

      flags(typing.Any):The flags for the GUID.

Returns:

      PyIID
        
         """
         pass


class PyIProvideExpressionContexts(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def EnumExpressionContexts(self,) -> 'None':
         """
         Description of EnumStackFrames.

Args:



Returns:

      None
        
         """
         pass


class PyIProvideTaskPage(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPage(self,tpType:'typing.Any',PersistChanges:'typing.Any') -> 'None':
         """
         Return a property sheet page handle for the spedified type 

(TASKPAGE_TASK,TASKPAGE_SCHEDULE,TASKPAGE_SETTINGS)

Args:

      tpType(typing.Any):Type of page to retreive (TASKPAGE_TASK,TASKPAGE_SCHEDULE,TASKPAGE_SETTINGS)
      PersistChanges(typing.Any):Indicates if changes should be saved automaticallyCommentsThere's not yet anything useful that can be done with this handle - return type subject to change

Returns:

      None
        
         """
         pass


class PyIQueryAssociations(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Init(self,flags:'typing.Any',assoc:'str',hkeyProgId:'PyHKEY'=None,hwnd:'int'=None) -> 'None':
         """
         Initializes the IQueryAssociations interface and sets the root key to the 

appropriate ProgID.

Args:

      flags(typing.Any):One of shellcon.ASSOCF_* flags
      assoc(str):The string data (ie, extension, prog-id, etc)
      hkeyProgId(PyHKEY):Root registry key, can be None
      hwnd(int):Reserved, must be 0 or None

Returns:

      None
        
         """
         pass


      def GetKey(self,flags:'typing.Any',assocKey:'typing.Any',arg:'str') -> 'typing.Any':
         """
         Searches for and retrieves a file association-related key from the 

registry.

Args:

      flags(typing.Any):Used to control the search.
      assocKey(typing.Any):Specifies the type of key that is to be returned.
      arg(str):Optional string with information about the location of the key. It is normally set to a shell verb such as 'open'. Set this parameter to None if it is not used.

Returns:

      typing.Any
        
         """
         pass


      def GetString(self,flags:'typing.Any',assocStr:'typing.Any',arg:'str') -> 'typing.Any':
         """
         Searches for and retrieves a file association-related string from the 

registry.

Args:

      flags(typing.Any):Used to control the search.
      assocStr(typing.Any):Specifies the type of string that is to be returned.
      arg(str):Optional string with information about the location of the key. It is normally set to a shell verb such as 'open'. Set this parameter to None if it is not used.CommentsNote that ASSOCF_NOTRUNCATE semantics are currently not supported - the buffer passed is 2048 bytes long, and will be truncated by the shell if too small.

Returns:

      typing.Any
        
         """
         pass


class PyIRelatedItem(object):
      """Interface used as the base for objects that have a related shell item 

(eg ITransferMediumItem, IDisplayItem, etc).  Should not be used directly."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetItemIDList(self,) -> 'PyIDL':
         """
         Returns the ID list of the related item

Args:



Returns:

      PyIDL
        
         """
         pass


      def GetItem(self,) -> 'PyIShellItem':
         """
         Returns the related item

Args:



Returns:

      PyIShellItem
        
         """
         pass


class PyIRemoteDebugApplication(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ResumeFromBreakPoint(self,prptFocus:'PyIRemoteDebugApplicationThread',bra:'typing.Any',era:'typing.Any') -> 'None':
         """
         Continue an application which is currently in a breakpoint.

Args:

      prptFocus(PyIRemoteDebugApplicationThread):Description for prptFocus
      bra(typing.Any):Break resume action
      era(typing.Any):Error resume action

Returns:

      None
        
         """
         pass


      def CauseBreak(self,) -> 'None':
         """
         Causes the application to break into the debugger at the earliest 

opportunity.

Args:



Returns:

      None
        
         """
         pass


      def ConnectDebugger(self,pad:'PyIApplicationDebugger') -> 'None':
         """
         Connects a debugger to the application.

Args:

      pad(PyIApplicationDebugger):Description for padCommentsOnly one debugger may be connected at a time; this method fails if there is already a debugger connected.

Returns:

      None
        
         """
         pass


      def DisconnectDebugger(self,) -> 'None':
         """
         Disconnects the current debugger from the application.

Args:



Returns:

      None
        
         """
         pass


      def GetDebugger(self,) -> 'PyIApplicationDebugger':
         """
         Returns the current debugger connected to 

the application.

Args:



Returns:

      PyIApplicationDebugger
        
         """
         pass


      def CreateInstanceAtApplication(self,rclsid:'PyIID',pUnkOuter:'PyIUnknown',dwClsContext:'typing.Any',riid:'PyIID') -> 'PyIUnknown':
         """
         Create objects in the application 

process address space.

Args:

      rclsid(PyIID):Description for rclsid
      pUnkOuter(PyIUnknown):Description for pUnkOuter
      dwClsContext(typing.Any):Description for dwClsContext
      riid(PyIID):Description for riidCommentsProvides a mechanism for the debugger IDE, running out-of-process to the application, to create objects in the application process. This method simply delegates to CoCreateInstance.

Returns:

      PyIUnknown
        
         """
         pass


      def QueryAlive(self,) -> 'None':
         """
         Returns True if alive, else False.

Args:



Returns:

      None
        
         """
         pass


      def EnumThreads(self,) -> 'PyIEnumRemoteDebugApplicationThreads':
         """
         Enumerates all threads known 

to be associated with the application.

Args:



Returns:

      PyIEnumRemoteDebugApplicationThreads
        
         """
         pass


      def GetName(self,) -> 'None':
         """
         Description of GetName.

Args:



Returns:

      None
        
         """
         pass


      def GetRootNode(self,) -> 'PyIDebugApplicationNode':
         """
         Returns the application node under which 

all nodes associated with the application are added.

Args:



Returns:

      PyIDebugApplicationNode
        
         """
         pass


      def EnumGlobalExpressionContexts(self,) -> 'typing.Any':
         """
         Enumerates all 

global expression contexts

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIRemoteDebugApplicationEvents(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def OnConnectDebugger(self,pad:'PyIApplicationDebugger') -> 'None':
         """
         Description of OnConnectDebugger.

Args:

      pad(PyIApplicationDebugger):Description for pad

Returns:

      None
        
         """
         pass


      def OnDisconnectDebugger(self,) -> 'None':
         """
         Description of OnDisconnectDebugger.

Args:



Returns:

      None
        
         """
         pass


      def OnSetName(self,pstrName:'typing.Any') -> 'None':
         """
         Description of OnSetName.

Args:

      pstrName(typing.Any):Description for pstrName

Returns:

      None
        
         """
         pass


      def OnDebugOutput(self,pstr:'typing.Any') -> 'None':
         """
         Description of OnDebugOutput.

Args:

      pstr(typing.Any):Description for pstr

Returns:

      None
        
         """
         pass


      def OnClose(self,) -> 'None':
         """
         Description of OnClose.

Args:



Returns:

      None
        
         """
         pass


      def OnEnterBreakPoint(self,prdat:'PyIRemoteDebugApplicationThread') -> 'None':
         """
         Description of OnEnterBreakPoint.

Args:

      prdat(PyIRemoteDebugApplicationThread):Description for prdat

Returns:

      None
        
         """
         pass


      def OnLeaveBreakPoint(self,prdat:'PyIRemoteDebugApplicationThread') -> 'None':
         """
         Description of OnLeaveBreakPoint.

Args:

      prdat(PyIRemoteDebugApplicationThread):Description for prdat

Returns:

      None
        
         """
         pass


      def OnCreateThread(self,prdat:'PyIRemoteDebugApplicationThread') -> 'None':
         """
         Description of OnCreateThread.

Args:

      prdat(PyIRemoteDebugApplicationThread):Description for prdat

Returns:

      None
        
         """
         pass


      def OnDestroyThread(self,prdat:'PyIRemoteDebugApplicationThread') -> 'None':
         """
         Description of OnDestroyThread.

Args:

      prdat(PyIRemoteDebugApplicationThread):Description for prdat

Returns:

      None
        
         """
         pass


      def OnBreakFlagChange(self,abf:'typing.Any',prdatSteppingThread:'PyIRemoteDebugApplicationThread') -> 'None':
         """
         Description of OnBreakFlagChange.

Args:

      abf(typing.Any):Description for abf
      prdatSteppingThread(PyIRemoteDebugApplicationThread):Description for prdatSteppingThread

Returns:

      None
        
         """
         pass


class PyIRemoteDebugApplicationThread(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetSystemThreadId(self,) -> 'None':
         """
         Description of GetSystemThreadId.

Args:



Returns:

      None
        
         """
         pass


      def GetApplication(self,) -> 'None':
         """
         Description of GetApplication.

Args:



Returns:

      None
        
         """
         pass


      def EnumStackFrames(self,) -> 'None':
         """
         Description of EnumStackFrames.

Args:



Returns:

      None
        
         """
         pass


      def GetDescription(self,) -> 'None':
         """
         Description of GetDescription.

Args:



Returns:

      None
        
         """
         pass


      def SetNextStatement(self,pStackFrame:'PyIDebugStackFrame',pCodeContext:'PyIDebugCodeContext') -> 'None':
         """
         Description of SetNextStatement.

Args:

      pStackFrame(PyIDebugStackFrame):Description for pStackFrame
      pCodeContext(PyIDebugCodeContext):Description for pCodeContext

Returns:

      None
        
         """
         pass


      def GetState(self,) -> 'None':
         """
         Description of GetState.

Args:



Returns:

      None
        
         """
         pass


      def Suspend(self,) -> 'None':
         """
         Description of Suspend.

Args:



Returns:

      None
        
         """
         pass


      def Resume(self,) -> 'None':
         """
         Description of Resume.

Args:



Returns:

      None
        
         """
         pass


      def GetSuspendCount(self,) -> 'None':
         """
         Description of GetSuspendCount.

Args:



Returns:

      None
        
         """
         pass


class PyIRunningObjectTable(object):
      """A Python interface to IRunningObjectTable"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Register(self,) -> 'typing.Any':
         """
         Registers an object and its identifying moniker in the Running Object 

Table (ROT).

Args:



Returns:

      typing.Any
        
         """
         pass


      def Revoke(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def IsRunning(self,objectName:'PyIMoniker') -> 'typing.Any':
         """
         Checks whether an object is running.

Args:

      objectName(PyIMoniker):The PyIMoniker interface on the moniker to search for in the Running Object Table.Return ValueDescriptionS_OK (ie, 0)The object identified by objectName is running.S_FALSE (ie, 1)There is no entry for objectName in the ROT, or that the object it identifies is no longer running (in which case, the entry is revoked).

Returns:

      typing.Any
        
         """
         pass


      def GetObject(self,objectName:'PyIMoniker') -> 'PyIUnknown':
         """
         Checks whether an object is running.

Args:

      objectName(PyIMoniker):The PyIMoniker interface on the moniker to search for in the Running Object Table.

Returns:

      PyIUnknown
        
         """
         pass


      def EnumRunning(self,) -> 'PyIEnumMoniker':
         """
         Creates an enumerator that can list the monikers of 

all the objects currently registered in the Running Object Table (ROT).

Args:



Returns:

      PyIEnumMoniker
        
         """
         pass


class PyIScheduledWorkItem(object):
      """Python object that encapsulates the IScheduledWorkItem interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateTrigger(self,) -> 'typing.Tuple[typing.Any, PyITaskTrigger]':
         """
         Creates a new trigger for a task, returns index and 

new ITaskTrigger interface

Args:



Returns:

      typing.Tuple[typing.Any, PyITaskTrigger]
        
         """
         pass


      def DeleteTrigger(self,Trigger:'typing.Any') -> 'None':
         """
         Deletes specified trigger

Args:

      Trigger(typing.Any):Index of trigger to delete

Returns:

      None
        
         """
         pass


      def GetTriggerCount(self,) -> 'typing.Any':
         """
         Returns number of triggers defined for the task

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetTrigger(self,iTrigger:'typing.Any') -> 'PyITaskTrigger':
         """
         Retrieves ITaskTrigger interface for specified trigger 

index

Args:

      iTrigger(typing.Any):Index of trigger to retrieve

Returns:

      PyITaskTrigger
        
         """
         pass


      def GetTriggerString(self,) -> 'typing.Any':
         """
         Creates a human-readable summary of specified trigger

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetRunTimes(self,Count:'typing.Any',Begin:'PyTime',End:'PyTime') -> 'typing.Tuple[PyTime, typing.Any, typing.Any, typing.Any]':
         """
         Return specified number of run times within given time 

frame

Args:

      Count(typing.Any):Number of run times to retrieve
      Begin(PyTime):Start time, defaults to current time if not passed or None
      End(PyTime):End time, defaults to unlimited if not passed or None

Returns:

      typing.Tuple[PyTime, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetNextRunTime(self,) -> 'PyTime':
         """
         Returns next time that task is scheduled to run

Args:



Returns:

      PyTime
        
         """
         pass


      def SetIdleWait(self,wIdleMinutes:'typing.Any',wDeadlineMinutes:'typing.Any') -> 'None':
         """
         Sets idle parms for task with trigger of type TASK_EVENT_TRIGGER_ON_IDLE

Args:

      wIdleMinutes(typing.Any):Nbr of minutes computer must be idle before task fires
      wDeadlineMinutes(typing.Any):Maximum nbr of minutes task will wait for computer to become idle

Returns:

      None
        
         """
         pass


      def GetIdleWait(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Gets IdleMinutes and DeadlineMinutes parms for task with trigger 

of type TASK_EVENT_TRIGGER_ON_IDLE

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def Run(self,) -> 'None':
         """
         Starts task

Args:



Returns:

      None
        
         """
         pass


      def Terminate(self,) -> 'None':
         """
         Terminate process if task is running

Args:



Returns:

      None
        
         """
         pass


      def EditWorkItem(self,hParent:'int',dwReserved:'typing.Any') -> 'None':
         """
         Brings up standard Scheduled Task dialog

Args:

      hParent(int):Reserved, use 0 or None if passed
      dwReserved(typing.Any):Reserved, use 0 if passed

Returns:

      None
        
         """
         pass


      def GetMostRecentRunTime(self,) -> 'PyTime':
         """
         Returns last time task ran

Args:



Returns:

      PyTime
        
         """
         pass


      def GetStatus(self,) -> 'typing.Any':
         """
         Returns status (SCHED_S_TASK... constants)

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetExitCode(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Returns tuple of task's exit code and error returned to Task 

Scheduler if process could not start

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def SetComment(self,Comment:'typing.Any') -> 'None':
         """
         Set comment string for task

Args:

      Comment(typing.Any):Freeform comment string

Returns:

      None
        
         """
         pass


      def GetComment(self,) -> 'str':
         """
         Return comment string associated with task.

Args:



Returns:

      str
        
         """
         pass


      def SetCreator(self,Creator:'typing.Any') -> 'None':
         """
         Specify who (or what) created task, can be any string

Args:

      Creator(typing.Any):Originator of task, does not have to be valid username

Returns:

      None
        
         """
         pass


      def GetCreator(self,) -> 'None':
         """
         Returns creator info, can be any string data

Args:



Returns:

      None
        
         """
         pass


      def SetWorkItemData(self,Data:'str') -> 'None':
         """
         Set data associated with task (treated as uninterpreted bytes)

Args:

      Data(str):Character data, treated as uninterpreted bytes

Returns:

      None
        
         """
         pass


      def GetWorkItemData(self,) -> 'str':
         """
         Retrieve data associated with task

Args:



Returns:

      str
        
         """
         pass


      def SetErrorRetryCount(self,wRetryCount:'typing.Any') -> 'None':
         """
         Specify nbr of times to attempt to run task if it can't start (not 

currently implemented)

Args:

      wRetryCount(typing.Any):Nbr of attemps to start task

Returns:

      None
        
         """
         pass


      def GetErrorRetryCount(self,) -> 'None':
         """
         Return nbr of times Task scheduler should try to run task (not 

currently implemented)

Args:



Returns:

      None
        
         """
         pass


      def SetErrorRetryInterval(self,RetryInterval:'typing.Any') -> 'None':
         """
         Interval in minutes between attempts to run task. Not 

implemented according to SDK

Args:

      RetryInterval(typing.Any):Interval in minutes

Returns:

      None
        
         """
         pass


      def GetErrorRetryInterval(self,) -> 'None':
         """
         Returns nbr of minutes between attempts to run task. Not 

implemented according to SDK

Args:



Returns:

      None
        
         """
         pass


      def SetFlags(self,dwFlags:'typing.Any') -> 'None':
         """
         Set flags for task

Args:

      dwFlags(typing.Any):Combination of TASK_FLAG_* constants

Returns:

      None
        
         """
         pass


      def GetFlags(self,) -> 'typing.Any':
         """
         Returns flags for task (TASK_FLAG_* constants)

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetAccountInformation(self,AccountName:'typing.Any',Password:'typing.Any') -> 'None':
         """
         Set username and password under which task will run

Args:

      AccountName(typing.Any):AccountName, use "" for local system account (can only be used by Administrators)
      Password(typing.Any):Password - Can be None for local System account, or if TASK_FLAG_RUN_ONLY_IF_LOGGED_ON is setCommentsOn some systems, username and password are verified at the time the task is saved, on others when the task tries to run

Returns:

      None
        
         """
         pass


      def GetAccountInformation(self,) -> 'typing.Any':
         """
         Returns username that task will run under

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIServerSecurity(object):
      """Interface used to access client security settings and perform impersonation"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def QueryBlanket(self,Capabilities:'typing.Any'=0) -> 'typing.Any':
         """
         Retrieves security settings specified by the client

Args:

      Capabilities(typing.Any):Can be EOAC_MAKE_FULLSIC for SChannel provider

Returns:

      typing.Any
        
         """
         pass


      def ImpersonateClient(self,) -> 'None':
         """
         Initiates impersonation of client

Args:



Returns:

      None
        
         """
         pass


      def RevertToSelf(self,) -> 'None':
         """
         Ends impersonation of client

Args:



Returns:

      None
        
         """
         pass


      def IsImpersonating(self,) -> 'typing.Any':
         """
         Determines if server is currently impersonating a client

Args:



Returns:

      typing.Any
        
         """
         pass


class PyIServiceProvider(object):
      """A Python interface to IServiceProvider"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def QueryService(self,clsid:'PyIID',iid:'PyIID') -> 'PyIUnknown':
         """
         Creates or accesses the specified service and returns an 

interface object to the specified interface for the service.

Args:

      clsid(PyIID):Unique identifier for the requested service.
      iid(PyIID):Unique identifier for the requested interface on the service.

Returns:

      PyIUnknown
        
         """
         pass


class PyIShellBrowser(object):
      """Exposed by Windows Explorer and the Open File common dialog box to provide services for 

namespace extensions."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def InsertMenusSB(self,hmenuShared:'int',lpMenuWidths:'PyOLEMENUGROUPWIDTHS') -> 'PyOLEMENUGROUPWIDTHS':
         """
         Updates a composite menu with container's options

Args:

      hmenuShared(int):Newly created menu that contains no items
      lpMenuWidths(PyOLEMENUGROUPWIDTHS):Tuple of 6 ints.  Items 0,2,and 4 are updated when the tuple is returned.

Returns:

      PyOLEMENUGROUPWIDTHS
        
         """
         pass


      def SetMenuSB(self,hmenuShared:'int',holemenuRes:'int',hwndActiveObject:'int') -> 'None':
         """
         Attaches a shared menu to a shell view window

Args:

      hmenuShared(int):Handle to the shared menu
      holemenuRes(int):Reserved, use only None (or 0)
      hwndActiveObject(int):Handle to the shell window

Returns:

      None
        
         """
         pass


      def RemoveMenusSB(self,hmenuShared:'int') -> 'None':
         """
         Asks container to remove any items it added to a composite menu

Args:

      hmenuShared(int):Handle to the composite menu

Returns:

      None
        
         """
         pass


      def SetStatusTextSB(self,pszStatusText:'typing.Any') -> 'None':
         """
         Sets the status text in view's status bar

Args:

      pszStatusText(typing.Any):New status to be displayed

Returns:

      None
        
         """
         pass


      def EnableModelessSB(self,fEnable:'typing.Any') -> 'None':
         """
         Enables or disables modeless dialogs

Args:

      fEnable(typing.Any):Use True to enable or False to disable modeless dialog boxes

Returns:

      None
        
         """
         pass


      def TranslateAcceleratorSB(self,pmsg:'PyMSG',wID:'typing.Any') -> 'None':
         """
         Translates keystrokes used as menu item activators

Args:

      pmsg(PyMSG):Keystroke message to be translated
      wID(typing.Any):Menu command id for the keystroke

Returns:

      None
        
         """
         pass


      def BrowseObject(self,pidl:'PyIDL',wFlags:'typing.Any') -> 'None':
         """
         Navigates to a different location

Args:

      pidl(PyIDL):Item id list that specifies the new browse location, can be None
      wFlags(typing.Any):Combination of shellcon.SBSP_* flags

Returns:

      None
        
         """
         pass


      def GetViewStateStream(self,grfMode:'typing.Any') -> 'PyIStream':
         """
         Returns a stream that can be used to access view state 

information

Args:

      grfMode(typing.Any):Read/write mode, one of STGM_READ,STGM_WRITE,STGM_READWRITE

Returns:

      PyIStream
        
         """
         pass


      def GetControlWindow(self,_id:'typing.Any') -> 'None':
         """
         Returns a handle to one of the browser's control elements

Args:

      _id(typing.Any):One of shellcon.FCW_* values

Returns:

      None
        
         """
         pass


      def SendControlMsg(self,_id:'typing.Any',uMsg:'typing.Any',wParam:'typing.Any',lParam:'typing.Any') -> 'typing.Any':
         """
         Sends a control msg to browser's toolbar or status bar

Args:

      _id(typing.Any):shellcon.FCW_TOOLBAR or FCW_STATUS
      uMsg(typing.Any):The message to send
      wParam(typing.Any):Value is dependent on the message
      lParam(typing.Any):Value is dependent on the message

Returns:

      typing.Any
        
         """
         pass


      def QueryActiveShellView(self,) -> 'PyIShellView':
         """
         Returns the currently displayed view

Args:



Returns:

      PyIShellView
        
         """
         pass


      def OnViewWindowActive(self,pshv:'PyIShellView') -> 'None':
         """
         Callback triggered when a view window is activated

Args:

      pshv(PyIShellView):The activated view object

Returns:

      None
        
         """
         pass


      def SetToolbarItems(self,lpButtons:'typing.Any',uFlags:'typing.Any') -> 'None':
         """
         Adds toolbar buttons to the browser's toolbar

Args:

      lpButtons(typing.Any):Sequence of tuples describing the buttons to be added
      uFlags(typing.Any):Indicates button positions, combination of shellcon.FCT_*

Returns:

      None
        
         """
         pass


class PyIShellExtInit(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Initialize(self,pFolder:'PyIDL',pDataObject:'PyIDataObject',hkey:'int') -> 'None':
         """
         Description of Initialize.

Args:

      pFolder(PyIDL):Description for pFolder
      pDataObject(PyIDataObject):Description for pDataObject
      hkey(int):Description for hkey

Returns:

      None
        
         """
         pass


class PyIShellFolder(object):
      """Interface that represents an Explorer folder"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ParseDisplayName(self,hwndOwner:'int',pbc:'PyIBindCtx',DisplayName:'typing.Any',Attributes:'typing.Any'=0) -> 'typing.Any':
         """
         Returns the PIDL of an item in a shell folder

Args:

      hwndOwner(int):Window in which to display any dialogs or message boxes, can be 0
      pbc(PyIBindCtx):Bind context that affects how parsing is performed, can be None
      DisplayName(typing.Any):Display name to parse, format is dependent on the shell folder. Desktop folder will accept a file path, as well as guids of the form ::{guid} Example: '::%s\\::%s' %(shell.CLSID_MyComputer,shell.CLSID_ControlPanel)
      Attributes(typing.Any):Combination of shellcon.SFGAO_* constants specifying which attributes should be returnedReturn ValueThe result is a tuple of cchEaten, pidl, attrItems[0] int : cchEatenthe number of characters of the input name that were parsed[1] PyIDL : pidlspecifies the relative path from the parsing folder to the object[2] int : Attributesreturns any requested attributes

Returns:

      typing.Any:Combination of shellcon.SFGAO_* constants specifying which attributes should be returned
Return ValueThe result is a tuple of cchEaten, pidl, attr
Items[0] int : cchEaten
the number of characters of the input name that were parsed
[1] PyIDL : pidl
specifies the relative path from the parsing folder to the object
[2] int : Attributes
returns any requested attributes

        
         """
         pass


      def EnumObjects(self,grfFlags:'typing.Any',hwndOwner:'int'=None) -> 'PyIEnumIDList':
         """
         Creates an enumerator to list the contents of the shell folder

Args:

      grfFlags(typing.Any):Combination of shellcon.SHCONTF_* constants
      hwndOwner(int):Window to use if any user interaction is required

Returns:

      PyIEnumIDList
        
         """
         pass


      def BindToObject(self,pidl:'PyIDL',pbc:'PyIBindCtx',riid:'PyIID') -> 'PyIShellFolder':
         """
         Returns an IShellFolder interface for a subfolder

Args:

      pidl(PyIDL):Relative item id list that identifies the subfolder, can be multi-level
      pbc(PyIBindCtx):Bind context to be used, can be None
      riid(PyIID):IID of the desired interface, usually IID_IShellFolder

Returns:

      PyIShellFolder
        
         """
         pass


      def BindToStorage(self,pidl:'PyIDL',pbc:'PyIBindCtx',riid:'PyIID') -> 'typing.Any':
         """
         Returns an interface to a storage object in a shell folder

Args:

      pidl(PyIDL):Relative pidl for the folder item, must be a single item id
      pbc(PyIBindCtx):Bind context that affects how binding is performed, can be None
      riid(PyIID):IID of the desired interface, one of IID_IStream, IID_IStorage, IID_IPropertySetStorageReturn ValueReturns PyIStream, PyIStorage or PyIPropertySetStorage depending on the riid passed in

Returns:

      typing.Any:IID of the desired interface, one of IID_IStream, IID_IStorage, IID_IPropertySetStorageReturn ValueReturns PyIStream, PyIStorage or PyIPropertySetStorage depending on the riid passed in

        
         """
         pass


      def CompareIDs(self,lparam:'typing.Any',pidl1:'PyIDL',pidl2:'PyIDL') -> 'typing.Any':
         """
         Determines the sorting order of 2 items in shell folder

Args:

      lparam(typing.Any):Lower 16 bits specify folder-dependent sorting rules, 0 means to sort by display name. System folder view uses these as a column number. Upper sixteen bits is used for flags SHCIDS_ALLFIELDS or SHCIDS_CANONICALONLY
      pidl1(PyIDL):Item id list that idenfies an object relative to the folder
      pidl2(PyIDL):Item id list that idenfies an object relative to the folderReturn ValueReturns 0 if items compare equal, -1 if the pidl1 comes first, or 1 if pidl2 comes first

Returns:

      typing.Any:Item id list that idenfies an object relative to the folderReturn ValueReturns 0 if items compare equal, -1 if the pidl1 comes first, or 1 if pidl2 comes first

        
         """
         pass


      def CreateViewObject(self,hwndOwner:'typing.Any',riid:'PyIID') -> 'PyIShellView':
         """
         Creates a view object for a shell folder.

Args:

      hwndOwner(typing.Any):Parent window for a custom folder view, or 0
      riid(PyIID):IID of the desired interface, usually IID_IShellView

Returns:

      PyIShellView
        
         """
         pass


      def GetAttributesOf(self,pidl:'typing.Tuple[PyIDL, ...]',rgfInOut:'typing.Any') -> 'typing.Any':
         """
         Queries attributes of items within the shell folder

Args:

      pidl(typing.Tuple[PyIDL, ...]):A sequence of single-level pidls identifying items directly contained by the folder
      rgfInOut(typing.Any):Combination of shellcon.SFGAO_* constantsReturn ValueThe requested attributes are only returned if they are common to all of the specified items

Returns:

      typing.Any:Combination of shellcon.SFGAO_* constantsReturn ValueThe requested attributes are only returned if they are common to all of the specified items

        
         """
         pass


      def GetUIObjectOf(self,hwndOwner:'int',pidl:'typing.Tuple[PyIDL, ...]',riid:'PyIID',iidout:'PyIID',Reserved:'typing.Any'=0) -> 'typing.Tuple[typing.Any, PyIUnknown]':
         """
         Creates an interface to one or more items in a shell 

folder

Args:

      hwndOwner(int):Specifies a window in which to display any required dialogs or errors, can be 0
      pidl(typing.Tuple[PyIDL, ...]):A sequence of single-level pidls identifying items in the folder
      riid(PyIID):The interface to create, one of IID_IContextMenu, IID_IContextMenu2, IID_IDataObject, IID_IDropTarget, IID_IExtractIcon, IID_IQueryInfo
      iidout(PyIID):The interface to return.  Can be used in the case where there is not a python wrapper for the desired interface.  You must make certain that the interface identified by riid actually supports the iidout interface, or Bad Things Will Happen. It should always be safe to return PyIUnknown, which is the base for all interfaces.Return ValueReturns the Reserved parameter and the requested interface
      Reserved(typing.Any):Reserved, use 0 if passed in

Returns:

      typing.Tuple[typing.Any, PyIUnknown]:The interface to return.  Can be used in the case where there is not a 

python wrapper for the desired interface.  You must make certain that the interface identified by riid 

actually supports the iidout interface, or Bad Things Will Happen. 

It should always be safe to return PyIUnknown, which is the base for all interfaces.
Return ValueReturns the Reserved parameter and the requested interface

        
         """
         pass


      def GetDisplayNameOf(self,pidl:'PyIDL',uFlags:'typing.Any') -> 'typing.Any':
         """
         Returns the display name of an item within this shell folder

Args:

      pidl(PyIDL):PIDL that identifies the item relative to the parent folder
      uFlags(typing.Any):Combination of shellcon.SHGDN_* flags

Returns:

      typing.Any
        
         """
         pass


      def SetNameOf(self,hwndOwner:'typing.Any',pidl:'PyIDL',Name:'typing.Any',Flags:'typing.Any') -> 'PyIDL':
         """
         Sets the display name of an item and changes its PIDL

Args:

      hwndOwner(typing.Any):Window in which to display any message boxes or dialogs, can be 0
      pidl(PyIDL):PIDL that identifies the item relative to the parent folder
      Name(typing.Any):New name for the item
      Flags(typing.Any):Combination of shellcon.SHGDM_* valuesReturn ValueReturns the new PIDL for item

Returns:

      PyIDL:Combination of shellcon.SHGDM_* valuesReturn ValueReturns the new PIDL for item

        
         """
         pass


class PyIShellFolder2(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDefaultSearchGUID(self,pguid:'PyIID') -> 'PyIID':
         """
         Retrieves the default search for the folder

Args:

      pguid(PyIID):Description for pguid

Returns:

      PyIID
        
         """
         pass


      def EnumSearches(self,) -> 'typing.Any':
         """
         Returns an interface that lists searches defined for 

the folder

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetDefaultColumn(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Returns the columns used for sorting and display

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def GetDefaultColumnState(self,iColumn:'typing.Any') -> 'typing.Any':
         """
         Returns flags indicating the default behaviour of the column

Args:

      iColumn(typing.Any):Zero-based index of the columnReturn ValueReturns a combination of shellcon.SHCOLSTATE_* flags

Returns:

      typing.Any:Zero-based index of the columnReturn ValueReturns a combination of shellcon.SHCOLSTATE_* flags

        
         """
         pass


      def GetDetailsEx(self,pidl:'PyIDL',pscid:'typing.Any') -> 'typing.Any':
         """
         Returns the details of an item by Column ID

Args:

      pidl(PyIDL):Relative id list of an item in the folder
      pscid(typing.Any):The Column id/property key of a column in the folder's Details viewReturn ValueThe type of returned object is determined by the variant type of the requested column

Returns:

      typing.Any:The Column id/property key of a column in the folder's Details viewReturn ValueThe type of returned object is determined by the variant type of the requested column

        
         """
         pass


      def GetDetailsOf(self,pidl:'PyIDL',iColumn:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Returns the value or title of a column in the folder's Details 

view.

Args:

      pidl(PyIDL):The relative idl of an item in the folder.  Use None to retrieve column title.
      iColumn(typing.Any):Zero based index of columnReturn ValueReturns a tuple representing a SHELLDETAILS struct, containing the formst (LVCFMT_*), column width in characters, and string representation of the requested value

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]:Zero based index of columnReturn ValueReturns a tuple representing a SHELLDETAILS struct, containing the formst (LVCFMT_*), column width in 

characters, 

and string representation of the requested value

        
         """
         pass


      def MapColumnToSCID(self,Column:'typing.Any') -> 'typing.Any':
         """
         Returns the unique identifier (FMTID, pid) of a column

Args:

      Column(typing.Any):The zero-based index of the column as presented by the folder's Details viewReturn ValueOn XP and earlier, this is the Column Id as provided by PyIColumnProvider. For Vista and later, this is the Property Key used with the property system interfaces.

Returns:

      typing.Any:The zero-based index of the column as presented by the folder's Details viewReturn ValueOn XP and earlier, this is the Column Id as provided by PyIColumnProvider. 

For Vista and later, this is the Property Key used with the property system interfaces.

        
         """
         pass


class PyIShellIcon(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetIconOf(self,pidl:'PyIDL') -> 'None':
         """
         Description of GetIconOf.

Args:

      pidl(PyIDL):Description for pidl

Returns:

      None
        
         """
         pass


class PyIShellIconOverlay(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetOverlayIndex(self,pidl:'PyIDL') -> 'None':
         """
         Description of GetOverlayIndex.

Args:

      pidl(PyIDL):Description for pidl

Returns:

      None
        
         """
         pass


      def GetOverlayIconIndex(self,pidl:'PyIDL') -> 'None':
         """
         Description of GetOverlayIconIndex.

Args:

      pidl(PyIDL):Description for pidl

Returns:

      None
        
         """
         pass


class PyIShellIconOverlayIdentifier(object):
      """Interface that supplies icon overlay information to the shell"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def IsMemberOf(self,path:'str',attrib:'typing.Any') -> 'typing.Any':
         """
         Determines if a shell object should have an icon overlay

Args:

      path(str):Fully qualified path of the shell object
      attrib(typing.Any):Shell attributes, combination of shellcon.SFGAO_* flagsReturn ValueThe gateway implementation of this function should return winerror.S_OK to display the overlay, S_FALSE if not, or throw a COM exception with E_FAIL on error. The client implementation of this function returns the same values - ie, Python's True and False should not be used, as S_OK==0==False.

Returns:

      typing.Any:Shell attributes, combination of shellcon.SFGAO_* flagsReturn ValueThe gateway implementation of this function should return winerror.S_OK to 

display the overlay, S_FALSE if not, or throw a COM exception with E_FAIL on error. 

The client implementation of this function returns the same values - ie, 

Python's True and False should not be used, as S_OK==0==False.

        
         """
         pass


      def GetOverlayInfo(self,) -> 'typing.Tuple[str, typing.Any, typing.Any]':
         """
         Retrieves the path to the overlay 

icon

Args:



Returns:

      typing.Tuple[str, typing.Any, typing.Any]:PyIShellIconOverlayIdentifier.GetOverlayInfo

(PyUnicode, int, int) = GetOverlayInfo()Retrieves the path to the overlay 

icon
Return ValueReturns the path to the icon file, the index of icon within the file, and Flags containing 

combination of shellcon.ISIOI_ICON* flags

        
         """
         pass


      def GetPriority(self,) -> 'typing.Any':
         """
         Retrieves the relative priority of the overlay

Args:



Returns:

      typing.Any:PyIShellIconOverlayIdentifier.GetPriority

int = GetPriority()Retrieves the relative priority of the overlay
Return ValueImplementation of this function should return a number in the range 0-100 (0 is highest priority)

        
         """
         pass


class PyIShellIconOverlayManager(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetFileOverlayInfo(self,path:'typing.Any',attrib:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Returns an index into the system image list for the icon 

image or overlay image

Args:

      path(typing.Any):Full path to the file
      attrib(typing.Any):File attributes (win32com.FILE_ATTRIBUTE_*)
      flags(typing.Any):SIOM_OVERLAYINDEX (1) or SIOM_ICONINDEX (2)

Returns:

      typing.Any
        
         """
         pass


      def GetReservedOverlayInfo(self,path:'typing.Any',attrib:'typing.Any',flags:'typing.Any',ireservedID:'typing.Any') -> 'None':
         """
         Description of GetReservedOverlayInfo.

Args:

      path(typing.Any):Description for path
      attrib(typing.Any):Description for attrib
      flags(typing.Any):Description for flags
      ireservedID(typing.Any):Description for ireservedID

Returns:

      None
        
         """
         pass


      def RefreshOverlayImages(self,flags:'typing.Any') -> 'None':
         """
         Description of RefreshOverlayImages.

Args:

      flags(typing.Any):Description for flags

Returns:

      None
        
         """
         pass


      def LoadNonloadedOverlayIdentifiers(self,) -> 'None':
         """
         Description of LoadNonloadedOverlayIdentifiers.

Args:



Returns:

      None
        
         """
         pass


      def OverlayIndexFromImageIndex(self,iImage:'typing.Any',fAdd:'typing.Any') -> 'None':
         """
         Description of OverlayIndexFromImageIndex.

Args:

      iImage(typing.Any):Description for iImage
      fAdd(typing.Any):Description for fAdd

Returns:

      None
        
         """
         pass


class PyIShellItem(object):
      """Interface that represents an item in the Explorer shell"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def BindToHandler(self,pbc:'PyIBindCtx',bhid:'PyIID',riid:'PyIID') -> 'typing.Any':
         """
         Creates an instance of one of the item's handlers

Args:

      pbc(PyIBindCtx):Used to pass parameters that influence the binding operation, can be None
      bhid(PyIID):GUID that identifies a handler (shell.BHID_*)
      riid(PyIID):The interface to return

Returns:

      typing.Any
        
         """
         pass


      def GetParent(self,) -> 'PyIShellItem':
         """
         Retrieves the parent of this item

Args:



Returns:

      PyIShellItem
        
         """
         pass


      def GetDisplayName(self,sigdnName:'typing.Any') -> 'typing.Any':
         """
         Returns the display name of the item in the specified format

Args:

      sigdnName(typing.Any):Format of name to return, shellcon.SIGDN_*

Returns:

      typing.Any
        
         """
         pass


      def GetAttributes(self,Mask:'typing.Any') -> 'typing.Any':
         """
         Returns shell attributes of the item

Args:

      Mask(typing.Any):Combination of shellcon.SFGAO_* values indicating the flags to returnReturn ValueReturns a combination of shellcon.SFGAO_* values

Returns:

      typing.Any:Combination of shellcon.SFGAO_* values indicating the flags to returnReturn ValueReturns a combination of shellcon.SFGAO_* values

        
         """
         pass


      def Compare(self,psi:'PyIShellItem',hint:'typing.Any') -> 'typing.Any':
         """
         Compares another shell item with this item

Args:

      psi(PyIShellItem):A shell item to be compared with this item
      hint(typing.Any):shellcon.SICHINT_* value indicating how the comparison is to be performedReturn ValueReturns 0 if items compare as equal, nonzero otherwise

Returns:

      typing.Any:shellcon.SICHINT_* value indicating how the comparison is to be performedReturn ValueReturns 0 if items compare as equal, nonzero otherwise

        
         """
         pass


class PyIShellItem2(object):
      """Extends the IShellItem interface, giving access to an item's properties"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPropertyStore(self,Flags:'typing.Any',riid:'PyIID') -> 'PyIPropertyStore':
         """
         Returns a collection of the item's properties

Args:

      Flags(typing.Any):Combination of GETPROPERTYSTOREFLAGS values (shellcon.GPS_*)
      riid(PyIID):The interface to return

Returns:

      PyIPropertyStore
        
         """
         pass


      def GetPropertyStoreForKeys(self,Keys:'typing.Tuple[typing.Any, ...]',Flags:'typing.Any',riid:'PyIID') -> 'PyIPropertyStore':
         """
         Creates a property store containing just the 

specified properties of the item

Args:

      Keys(typing.Tuple[typing.Any, ...]):A sequence of property identifiers
      Flags(typing.Any):Combination of GETPROPERTYSTOREFLAGS values (shellcon.GPS_*)
      riid(PyIID):The interface to return

Returns:

      PyIPropertyStore
        
         """
         pass


      def GetPropertyStoreWithCreateObject(self,Flags:'typing.Any',CreateObject:'PyIUnknown',riid:'PyIID') -> 'PyIPropertyStore':
         """
         Returns the property store for the 

item, with alternate handler instantiation

Args:

      Flags(typing.Any):Combination of GETPROPERTYSTOREFLAGS values (shellcon.GPS_*)
      CreateObject(PyIUnknown):An interface that implements ICreateObject, used to create the property handler
      riid(PyIID):The interface to be createdCommentsPrimarily used to create a handler in a separate process with reduced privileges

Returns:

      PyIPropertyStore
        
         """
         pass


      def GetPropertyDescriptionList(self,Type:'PyPROPERTYKEY',riid:'PyIID') -> 'PyIPropertyDescriptionList':
         """
         Retrieves descriptions of 

properties in a particular group

Args:

      Type(PyPROPERTYKEY):Property list identifier (pscon.PKEY_PropList_*)
      riid(PyIID):The interface to return

Returns:

      PyIPropertyDescriptionList
        
         """
         pass


      def Update(self,BindCtx:'typing.Any'=None) -> 'None':
         """
         Refreshes properties that have been modified since interface was created

Args:

      BindCtx(typing.Any):Bind context used when requesting the interface, or None

Returns:

      None
        
         """
         pass


      def GetProperty(self,key:'PyPROPERTYKEY') -> 'typing.Any':
         """
         Retrieves the value of a property, converted to an appropriate python type

Args:

      key(PyPROPERTYKEY):The id of the property to retrieveReturn ValueType of returned object is determined by the variant type of the property

Returns:

      typing.Any:The id of the property to retrieveReturn ValueType of returned object is determined by the variant type of the property

        
         """
         pass


      def GetCLSID(self,key:'PyPROPERTYKEY') -> 'PyIID':
         """
         Retrieves the value of a property as a CLSID (VT_CLSID)

Args:

      key(PyPROPERTYKEY):The id of the property to retrieve

Returns:

      PyIID
        
         """
         pass


      def GetFileTime(self,key:'PyPROPERTYKEY') -> 'PyTime':
         """
         Retrieves the value of a property as a FILETIME

Args:

      key(PyPROPERTYKEY):The id of the property to retrieve

Returns:

      PyTime
        
         """
         pass


      def GetInt32(self,key:'PyPROPERTYKEY') -> 'typing.Any':
         """
         Retrieves the value of a property as a 32 bit int.

Args:

      key(PyPROPERTYKEY):The id of the property to retrieve

Returns:

      typing.Any
        
         """
         pass


      def GetString(self,key:'PyPROPERTYKEY') -> 'typing.Any':
         """
         Retrieves the value of a property as a string

Args:

      key(PyPROPERTYKEY):The id of the property to retrieve

Returns:

      typing.Any
        
         """
         pass


      def GetUInt32(self,key:'PyPROPERTYKEY') -> 'typing.Any':
         """
         Returns the value of a property as a 32 bit unsigned int

Args:

      key(PyPROPERTYKEY):The id of the property to retrieve

Returns:

      typing.Any
        
         """
         pass


      def GetUInt64(self,key:'PyPROPERTYKEY') -> 'typing.Any':
         """
         Returns the value of a property as an unsigned 64-bit int

Args:

      key(PyPROPERTYKEY):The id of the property to retrieve

Returns:

      typing.Any
        
         """
         pass


      def GetBool(self,key:'PyPROPERTYKEY') -> 'typing.Any':
         """
         Returns the value of a property as a boolean

Args:

      key(PyPROPERTYKEY):The id of the property to retrieve

Returns:

      typing.Any
        
         """
         pass


class PyIShellItemArray(object):
      """Container for a number of shell items"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def BindToHandler(self,pbc:'PyIBindCtx',rbhid:'PyIID',riid:'PyIID') -> 'typing.Any':
         """
         Creates an instance of a handler for the items in the container

Args:

      pbc(PyIBindCtx):Bind context, can be None
      rbhid(PyIID):Bind handler GUID (shell.BHID_*)
      riid(PyIID):The interface to return

Returns:

      typing.Any
        
         """
         pass


      def GetPropertyStore(self,flags:'typing.Any',riid:'PyIID') -> 'PyIPropertyStore':
         """
         Retrieves a store containing consolidated 

properties of items in container

Args:

      flags(typing.Any):Flags indicating how the properties are retrieved (shellcon.GPS_*)
      riid(PyIID):The interface to return, IID_IPropertyStore or related interface

Returns:

      PyIPropertyStore
        
         """
         pass


      def GetPropertyDescriptionList(self,Type:'PyPROPERTYKEY',riid:'PyIID') -> 'PyIPropertyDescriptionList':
         """
         Retrieves descriptions for a 

defined group of properties

Args:

      Type(PyPROPERTYKEY):Property list identifier (pscon.PKEY_PropList_*)
      riid(PyIID):The interface to return

Returns:

      PyIPropertyDescriptionList
        
         """
         pass


      def GetAttributes(self,AttribFlags:'typing.Any',Mask:'typing.Any') -> 'typing.Any':
         """
         Retrieves shell attributes of contained items

Args:

      AttribFlags(typing.Any):SIATTRIBFLAGS value (shellcon.SIATTRIBFLAGS_*) specifying how to combine attributes of multiple items
      Mask(typing.Any):Combination of SFGAOF flags (shellcon.SFGAO_*) specifying which attributes to return

Returns:

      typing.Any
        
         """
         pass


      def GetCount(self,) -> 'typing.Any':
         """
         Returns the number of items in the container

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetItemAt(self,dwIndex:'typing.Any') -> 'PyIShellItem':
         """
         Retrieves an item by index

Args:

      dwIndex(typing.Any):Zero-based index of item to retrieve

Returns:

      PyIShellItem
        
         """
         pass


      def EnumItems(self,) -> 'PyIEnumShellItems':
         """
         Returns an enumeration interface to list contained items

Args:



Returns:

      PyIEnumShellItems
        
         """
         pass


class PyIShellItemResources(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetAttributes(self,) -> 'None':
         """
         Description of GetAttributes.

Args:



Returns:

      None
        
         """
         pass


      def GetSize(self,) -> 'typing.Any':
         """
         Description of GetSize.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetTimes(self,) -> 'None':
         """
         Description of GetTimes.

Args:



Returns:

      None
        
         """
         pass


      def SetTimes(self,pftCreation:'PyTime',pftWrite:'PyTime',pftAccess:'PyTime') -> 'None':
         """
         Description of SetTimes.

Args:

      pftCreation(PyTime):Description for pftCreation
      pftWrite(PyTime):Description for pftWrite
      pftAccess(PyTime):Description for pftAccess

Returns:

      None
        
         """
         pass


      def GetResourceDescription(self,pcsir:'PySHELL_ITEM_RESOURCE') -> 'None':
         """
         Description of GetResourceDescription.

Args:

      pcsir(PySHELL_ITEM_RESOURCE):Description for pcsir

Returns:

      None
        
         """
         pass


      def EnumResources(self,) -> 'PyIEnumResources':
         """
         Description of EnumResources.

Args:



Returns:

      PyIEnumResources
        
         """
         pass


      def SupportsResource(self,pcsir:'PySHELL_ITEM_RESOURCE') -> 'typing.Any':
         """
         Description of SupportsResource.

Args:

      pcsir(PySHELL_ITEM_RESOURCE):Description for pcsir

Returns:

      typing.Any
        
         """
         pass


      def OpenResource(self,pcsir:'PySHELL_ITEM_RESOURCE',riid:'PyIID') -> 'PyIUnknown':
         """
         Description of OpenResource.

Args:

      pcsir(PySHELL_ITEM_RESOURCE):Description for pcsir
      riid(PyIID):The interface to return

Returns:

      PyIUnknown
        
         """
         pass


      def CreateResource(self,sir:'PySHELL_ITEM_RESOURCE',riid:'PyIID') -> 'typing.Any':
         """
         Description of CreateResource.

Args:

      sir(PySHELL_ITEM_RESOURCE):Resource identifier
      riid(PyIID):The interface to return

Returns:

      typing.Any
        
         """
         pass


      def MarkForDelete(self,) -> 'None':
         """
         Description of MarkForDelete.

Args:



Returns:

      None
        
         """
         pass


class PyIShellLibrary(object):
      """Interface used to access Libraries"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def LoadLibraryFromItem(self,Library:'PyIShellItem',Mode:'typing.Any') -> 'None':
         """
         Loads an existing library file

Args:

      Library(PyIShellItem):Shell item interface representing the library file
      Mode(typing.Any):Access mode, combination of storagecon.STGM_* flags

Returns:

      None
        
         """
         pass


      def LoadLibraryFromKnownFolder(self,Library:'PyIID',Mode:'typing.Any') -> 'None':
         """
         Initializes library from a known folder

Args:

      Library(PyIID):Known folder id, shell.FOLDERID_*
      Mode(typing.Any):Access mode, combination of storagecon.STGM_* flags

Returns:

      None
        
         """
         pass


      def AddFolder(self,Location:'PyIShellItem') -> 'None':
         """
         Includes a folder

Args:

      Location(PyIShellItem):Shell item interface representing the folder

Returns:

      None
        
         """
         pass


      def RemoveFolder(self,Location:'PyIShellItem') -> 'None':
         """
         Removes a folder

Args:

      Location(PyIShellItem):Shell item interface representing the folder

Returns:

      None
        
         """
         pass


      def GetFolders(self,Filter:'typing.Any',riid:'PyIID') -> 'PyIShellItemArray':
         """
         Retrieves a collection of folders in the library

Args:

      Filter(typing.Any):Specifies what types of folder to return (shellcon.LFF_*)
      riid(PyIID):The interface to return, IObjectCollection and IObjectArray also accepted.

Returns:

      PyIShellItemArray
        
         """
         pass


      def ResolveFolder(self,FolderToResolve:'PyIShellItem',Timeout:'typing.Any',riid:'PyIID') -> 'PyIShellItem':
         """
         Attempts to locate a folder that has been moved or renamed

Args:

      FolderToResolve(PyIShellItem):Library item whose location has changed
      Timeout(typing.Any):Max search time, specified in milliseconds
      riid(PyIID):The interface to return

Returns:

      PyIShellItem
        
         """
         pass


      def GetDefaultSaveFolder(self,Type:'typing.Any',riid:'PyIID') -> 'PyIShellItem':
         """
         Returns the default folder in which new items are 

saved

Args:

      Type(typing.Any):Specifies whether to return public or private save location, shellcon.DSFT_*
      riid(PyIID):The interface to return

Returns:

      PyIShellItem
        
         """
         pass


      def SetDefaultSaveFolder(self,Type:'typing.Any',SaveFolder:'PyIShellItem') -> 'None':
         """
         Sets the default save location

Args:

      Type(typing.Any):Specifies public or private save location, shellcon.DSFT_*
      SaveFolder(PyIShellItem):New default location, must be in the library

Returns:

      None
        
         """
         pass


      def GetOptions(self,) -> 'typing.Any':
         """
         Retrieves library option flags

Args:



Returns:

      typing.Any:PyIShellLibrary.GetOptions

int = GetOptions()Retrieves library option flags
Return ValueReturns a combination of shellcon.LOF_* flags

        
         """
         pass


      def SetOptions(self,Mask:'typing.Any',Options:'typing.Any') -> 'None':
         """
         Sets library option flags

Args:

      Mask(typing.Any):Bitmask of flags to be changed, combination of shellcon.LOF_* values
      Options(typing.Any):New options, combination of shellcon.LOF_* values

Returns:

      None
        
         """
         pass


      def GetFolderType(self,) -> 'PyIID':
         """
         Returns the library type, shell.FOLDERTYPEID_*

Args:



Returns:

      PyIID
        
         """
         pass


      def SetFolderType(self,Type:'PyIID') -> 'None':
         """
         Sets the folder type for the library

Args:

      Type(PyIID):New type, shell.FOLDERTYPEID_*

Returns:

      None
        
         """
         pass


      def GetIcon(self,) -> 'typing.Any':
         """
         Returns the location of the library's icon

Args:



Returns:

      typing.Any:PyIShellLibrary.GetIcon

str = GetIcon()Returns the location of the library's icon
Return ValueUses "module,resource" format

        
         """
         pass


      def SetIcon(self,Icon:'typing.Any') -> 'None':
         """
         Sets the library icon

Args:

      Icon(typing.Any):Icon location in "module,resource" syntax

Returns:

      None
        
         """
         pass


      def Commit(self,) -> 'None':
         """
         Saves changes (only if loaded from an existing library)

Args:



Returns:

      None
        
         """
         pass


      def Save(self,FolderToSaveIn:'PyIShellItem',LibraryName:'typing.Any',Flags:'typing.Any') -> 'PyIShellItem':
         """
         Saves the library to a specific location

Args:

      FolderToSaveIn(PyIShellItem):The destination folder, use None to save in current user's Libraries folder
      LibraryName(typing.Any):Filename for the new library, without file extension
      Flags(typing.Any):Determines behaviour if file already exists, shellcon.LSF_*Return ValueReturns a shell item for the saved file.

Returns:

      PyIShellItem:Determines behaviour if file already exists, shellcon.LSF_*Return ValueReturns a shell item for the saved file.

        
         """
         pass


      def SaveInKnownFolder(self,FolderToSaveIn:'PyIID',LibraryName:'typing.Any',Flags:'typing.Any') -> 'PyIShellItem':
         """
         Saves the library in a known folder

Args:

      FolderToSaveIn(PyIID):The destination folder, shell.FOLDERID_*
      LibraryName(typing.Any):Filename for the new library, without file extension
      Flags(typing.Any):Determines behaviour if file already exists, shellcon.LSF_*

Returns:

      PyIShellItem
        
         """
         pass


class PyIShellLink(object):
      """Interface used to access the properties of a shell link file (*.lnk)"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPath(self,fFlags:'typing.Any',cchMaxPath:'typing.Any') -> 'typing.Tuple[typing.Any, WIN32_FIND_DATA]':
         """
         Retrieves the target path and file name of a shell link 

object

Args:

      fFlags(typing.Any):One of the following values:ValueDescriptionSLGP_SHORTPATHRetrieves the standard short (8.3 format) file name.SLGP_UNCPRIORITYRetrieves the Universal Naming Convention (UNC) path name of the file.SLGP_RAWPATHRetrieves the raw path name. A raw path is something that might not exist and may include environment variables that need to be expanded.
      cchMaxPath(typing.Any):Number of characters to allocate for returned filenameCommentsThe AlternateFileName (8.3) member of WIN32_FIND_DATA does not return information

Returns:

      typing.Tuple[typing.Any, WIN32_FIND_DATA]
        
         """
         pass


      def GetIDList(self,) -> 'PyIDL':
         """
         Retrieves the item id list that identifies the target of the shell link.

Args:



Returns:

      PyIDL
        
         """
         pass


      def SetIDList(self,pidl:'PyIDL') -> 'None':
         """
         Sets the target of the link using an item id list

Args:

      pidl(PyIDL):Absolute item id list that identifies the target

Returns:

      None
        
         """
         pass


      def GetDescription(self,cchMaxName:'typing.Any'=1024) -> 'typing.Any':
         """
         Retrieves the description of the link (displays as Comment in the UI)

Args:

      cchMaxName(typing.Any):Number of character to allocate for the retrieved text

Returns:

      typing.Any
        
         """
         pass


      def SetDescription(self,Name:'typing.Any') -> 'None':
         """
         Sets the description of the link (displays as Comment in the UI)

Args:

      Name(typing.Any):The description for the link

Returns:

      None
        
         """
         pass


      def GetWorkingDirectory(self,cchMaxName:'typing.Any'=1024) -> 'typing.Any':
         """
         Retrieves the working directory for the link

Args:

      cchMaxName(typing.Any):Number of characters to allocate for returned text

Returns:

      typing.Any
        
         """
         pass


      def SetWorkingDirectory(self,Dir:'typing.Any') -> 'None':
         """
         Sets the working directory for the link.

Args:

      Dir(typing.Any):The working directory for the link

Returns:

      None
        
         """
         pass


      def GetArguments(self,cchMaxName:'typing.Any'=1024) -> 'typing.Any':
         """
         Retrieves the command-line arguments associated with a shell link object.

Args:

      cchMaxName(typing.Any):Number of characters to fetch.

Returns:

      typing.Any
        
         """
         pass


      def SetArguments(self,args:'typing.Any') -> 'None':
         """
         Sets the command-line arguments associated with a shell link object.

Args:

      args(typing.Any):The new arguments.

Returns:

      None
        
         """
         pass


      def GetHotkey(self,) -> 'typing.Any':
         """
         Retrieves the hot key for a shell link object.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetHotkey(self,wHotkey:'typing.Any') -> 'None':
         """
         Sets the hot key for a shell link object.

Args:

      wHotkey(typing.Any):The virtual key code is in the low-order byte, and the modifier flags are in the high-order byte. The modifier flags can be a combination of the values specified in the description of the PyIShellLink::GetHotkey method.

Returns:

      None
        
         """
         pass


      def GetShowCmd(self,) -> 'typing.Any':
         """
         Retrieves the show (SW_) command for a shell link object.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetShowCmd(self,iShowCmd:'typing.Any') -> 'None':
         """
         Sets the show (SW_) command for a shell link object.

Args:

      iShowCmd(typing.Any):The new show command value.

Returns:

      None
        
         """
         pass


      def GetIconLocation(self,cchMaxPath:'typing.Any') -> 'typing.Any':
         """
         Retrieves the location (path and index) of the icon for a shell link 

object.

Args:

      cchMaxPath(typing.Any):Number of characters to allocate for the result string.

Returns:

      typing.Any
        
         """
         pass


      def SetIconLocation(self,iconPath:'str',iIcon:'typing.Any') -> 'None':
         """
         Sets the location (path and index) of the icon for a shell link object.

Args:

      iconPath(str):Path to the file with the icon.
      iIcon(typing.Any):Index of the icon.

Returns:

      None
        
         """
         pass


      def SetRelativePath(self,relPath:'str',reserved:'typing.Any'=0) -> 'None':
         """
         Sets the relative path for a shell link object.

Args:

      relPath(str):The relative path.
      reserved(typing.Any):Reserved - must be zero.CommentsThis mechanism allows for moved link files to reestablish connection with relative files through similar-prefix comparisons

Returns:

      None
        
         """
         pass


      def Resolve(self,hwnd:'int',fFlags:'typing.Any') -> 'None':
         """
         Resolves a shell link by searching for the shell link object and updating the 

shell link path and its list of identifiers (if necessary)

Args:

      hwnd(typing.Any):The parent window of a dialog which will pop up if resolution fails.
      fFlags(typing.Any):One of the following constants:ValueDescriptionSLR_INVOKE_MSICall the Microsoft Windows Installer.SLR_NOLINKINFODisable distributed link tracking. By default, distributed link tracking tracks removable media across multiple devices based on the volume name. It also uses the UNC path to track remote file systems whose drive letter has changed. Setting SLR_NOLINKINFO disables both types of tracking.SLR_NO_UIDo not display a dialog box if the link cannot be resolved. When SLR_NO_UI is set, the high-order word of fFlags can be set to a time-out value that specifies the maximum amount of time to be spent resolving the link. The function returns if the link cannot be resolved within the time-out duration. If the high-order word is set to zero, the time-out duration will be set to the default value of 3,000 milliseconds (3 seconds). To specify a value, set the high word of fFlags to the desired time-out duration, in milliseconds.SLR_NOUPDATEDo not update the link information.SLR_NOSEARCHDo not execute the search heuristics.SLR_NOTRACKDo not use distributed link tracking.SLR_UPDATEIf the link object has changed, update its path and list of identifiers. If SLR_UPDATE is set, you do not need to call IPersistFile::IsDirty to determine whether or not the link object has changed.

Returns:

      None
        
         """
         pass


      def SetPath(self,path:'str') -> 'None':
         """
         Sets the path and file name of a shell link object.

Args:

      path(str):The path and filename of the link.

Returns:

      None
        
         """
         pass


class PyIShellLinkDataList(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddDataBlock(self,DataBlock:'typing.Any') -> 'None':
         """
         Inserts a data block into the link

Args:

      DataBlock(typing.Any):Contents are dependent on type of data block being addedCommentsInput should be one of NT_CONSOLE_PROPS, NT_FE_CONSOLE_PROPS, EXP_SPECIAL_FOLDER, EXP_DARWIN_LINK, or EXP_SZ_LINK.  Expected form is indicated by the Signature member.

Returns:

      None
        
         """
         pass


      def CopyDataBlock(self,Sig:'typing.Any') -> 'typing.Any':
         """
         Retrieves the specified data block from the link

Args:

      Sig(typing.Any):The type of data block to retrieve, one of the shellcon.*_SIG constantsReturn ValueThe returned dictionary will contain different information depending on the value passed in

Returns:

      typing.Any:The type of data block to retrieve, one of the shellcon.*_SIG constantsReturn ValueThe returned dictionary will contain different information depending on the value passed in

        
         """
         pass


      def GetFlags(self,) -> 'typing.Any':
         """
         Retrieves the link's flags

Args:



Returns:

      typing.Any:PyIShellLinkDataList.GetFlags

int = GetFlags()Retrieves the link's flags
Return ValueReturns combination of shellcon.SLDF_* flags

        
         """
         pass


      def RemoveDataBlock(self,Sig:'typing.Any') -> 'None':
         """
         Deletes one of the link's data blocks

Args:

      Sig(typing.Any):Identifies which block is to be removed, one of shellcon.*_SIG constants

Returns:

      None
        
         """
         pass


      def SetFlags(self,Flags:'typing.Any') -> 'None':
         """
         Sets the flags indicating which data blocks are present

Args:

      Flags(typing.Any):Combination of shellcon.SLDF_* flags

Returns:

      None
        
         """
         pass


class PyIShellView(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def TranslateAccelerator(self,pmsg:'typing.Any') -> 'typing.Any':
         """
         Description of TranslateAccelerator.

Args:

      pmsg(typing.Any):Description for pmsgReturn ValueThe result is the HRESULT from the underlying TranslateAccelerator call

Returns:

      typing.Any:Description for pmsgReturn ValueThe result is the HRESULT from the underlying TranslateAccelerator call

        
         """
         pass


      def EnableModeless(self,fEnable:'typing.Any') -> 'None':
         """
         Description of EnableModeless.

Args:

      fEnable(typing.Any):Description for fEnable

Returns:

      None
        
         """
         pass


      def UIActivate(self,uState:'typing.Any') -> 'None':
         """
         Description of UIActivate.

Args:

      uState(typing.Any):Description for uState

Returns:

      None
        
         """
         pass


      def Refresh(self,) -> 'None':
         """
         Description of Refresh.

Args:



Returns:

      None
        
         """
         pass


      def CreateViewWindow(self,psvPrevious:'PyIShellView',pfs:'typing.Tuple[typing.Any, typing.Any]',psb:'PyIShellBrowser',prcView:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'typing.Any':
         """
         Description of CreateViewWindow.

Args:

      psvPrevious(PyIShellView):Description for psvPrevious
      pfs(typing.Tuple[typing.Any, typing.Any]):Description for pfs
      psb(PyIShellBrowser):Description for psb
      prcView(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Description for prcViewReturn ValueThe result is an integer handle to the new window.

Returns:

      typing.Any:Description for prcViewReturn ValueThe result is an integer handle to the new window.

        
         """
         pass


      def DestroyViewWindow(self,) -> 'None':
         """
         Description of DestroyViewWindow.

Args:



Returns:

      None
        
         """
         pass


      def GetCurrentInfo(self,) -> 'typing.Any':
         """
         Description of GetCurrentInfo.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SaveViewState(self,) -> 'None':
         """
         Description of SaveViewState.

Args:



Returns:

      None
        
         """
         pass


      def SelectItem(self,pidlItem:'PyIDL',uFlags:'typing.Any') -> 'None':
         """
         Description of SelectItem.

Args:

      pidlItem(PyIDL):Description for pidlItem
      uFlags(typing.Any):Description for uFlags

Returns:

      None
        
         """
         pass


      def GetItemObject(self,uItem:'typing.Any',riid:'PyIID') -> 'PyIUnknown':
         """
         Description of GetItemObject.

Args:

      uItem(typing.Any):Description for uItem
      riid(PyIID):Description for riid

Returns:

      PyIUnknown
        
         """
         pass


class PyISpecifyPropertyPages(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPages(self,) -> 'None':
         """
         Description of GetPages.

Args:



Returns:

      None
        
         """
         pass


class PyIStorage(object):
      """Structured storage compound storage object"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateStream(self,Name:'typing.Any',Mode:'typing.Any',reserved1:'typing.Any'=0,reserved2:'typing.Any'=0) -> 'PyIStream':
         """
         Creates and opens a stream object with the specified name contained 

in this storage object. All elements within a storage object  both streams and other storage objects  are kept in 

the same name space.

Args:

      Name(typing.Any):Name of the new stream
      Mode(typing.Any):Access mode, storagecon.STGM_*
      reserved1(typing.Any):Reserved - must be zero.
      reserved2(typing.Any):Reserved - must be zero.

Returns:

      PyIStream
        
         """
         pass


      def OpenStream(self,Name:'typing.Any',reserved1:'typing.Any',Mode:'typing.Any',reserved2:'typing.Any'=0) -> 'PyIStream':
         """
         Opens an existing stream object within this storage object in the 

specified access mode.

Args:

      Name(typing.Any):Name of stream to be opened
      reserved1(typing.Any):A reserved param.  Always pass None.  NULL is always passed to the COM function
      Mode(typing.Any):Access mode, storagecon.STGM_*
      reserved2(typing.Any):Reserved - must be zero.

Returns:

      PyIStream
        
         """
         pass


      def CreateStorage(self,Name:'typing.Any',Mode:'typing.Any',StgFmt:'typing.Any',reserved2:'typing.Any'=0) -> 'PyIStorage':
         """
         Creates and opens a new storage object nested within this storage 

object.

Args:

      Name(typing.Any):The name of the newly created stream.
      Mode(typing.Any):Access mode - combination of storagecon.STGM_* flags
      StgFmt(typing.Any):Documented as "reserved"!
      reserved2(typing.Any):Description for reserved2

Returns:

      PyIStorage
        
         """
         pass


      def OpenStorage(self,Name:'typing.Any',Priority:'PyIStorage',Mode:'typing.Any',snbExclude:'typing.Any',reserved:'typing.Any'=0) -> 'PyIStorage':
         """
         Opens an existing storage object with the specified name in the 

specified access mode.

Args:

      Name(typing.Any):Name of the storage, or None.
      Priority(PyIStorage):If the pstgPriority parameter is not None, it is a PyIStorage object to a previous opening of an element of the storage object, usually one that was opened in priority mode. The storage object should be closed and re-opened according to grfMode. When the PyIStorage::OpenStorage method returns, pstgPriority is no longer valid - use the result value. If the pstgPriority parameter is None, it is ignored.
      Mode(typing.Any):Access mode - combination of storagecon.STGM_* flags (must include STGM_SHARE_EXCLUSIVE)
      snbExclude(typing.Any):Reserved for later - Must be None
      reserved(typing.Any):Reserved integer param.

Returns:

      PyIStorage
        
         """
         pass


      def CopyTo(self,rgiidExclude:'typing.Tuple[typing.Any, typing.Any]',snbExclude:'typing.Any',stgDest:'PyIStorage') -> 'None':
         """
         Copies the entire contents of an open storage object to another storage object.

Args:

      rgiidExclude(typing.Tuple[typing.Any, typing.Any]):List of IID's to be excluded.  Use empty seq to exclude all objects, or None to indicate no excludes.
      snbExclude(typing.Any):Reserved for later - Must be None
      stgDest(PyIStorage):The open storage object into which this storage object is to be copied. The destination storage object can be a different implementation of the PyIStorage interface from the source storage object. Thus, IStorage::CopyTo can only use publicly available methods of the destination storage object. If stgDest is open in transacted mode, it can be reverted by calling its PyIStorage::Revert method.

Returns:

      None
        
         """
         pass


      def MoveElementTo(self,Name:'typing.Any',stgDest:'PyIStorage',NewName:'typing.Any',Flags:'typing.Any') -> 'None':
         """
         Copies or moves a substorage or stream from this storage object to another 

storage object.

Args:

      Name(typing.Any):A string that contains the name of the element in this storage object to be moved or copied.
      stgDest(PyIStorage):PyIStorage for the destination storage object.
      NewName(typing.Any):A string that contains the new name for the element in its new storage object.
      Flags(typing.Any):Specifies whether to move or copy (storagecon.STGMOVE_MOVE or STGMOVE_COPY)

Returns:

      None
        
         """
         pass


      def Commit(self,grfCommitFlags:'typing.Any') -> 'None':
         """
         Ensures that any changes made to a storage object open in transacted mode are reflected 

in the parent storage; for a root storage, reflects the changes in the actual device, for example, a file on disk. 

For a root storage object opened in direct mode, this method has no effect except to flush all memory buffers to the 

disk. For non-root storage objects in direct mode, this method has no effect.

Args:

      grfCommitFlags(typing.Any):Controls how the changes are committed to the storage object. See the STGC enumeration for a definition of these values.

Returns:

      None
        
         """
         pass


      def Revert(self,) -> 'None':
         """
         Discards all changes that have been made to the storage object since the last commit.

Args:



Returns:

      None
        
         """
         pass


      def EnumElements(self,reserved1:'typing.Any'=0,reserved2:'typing.Any'=None,reserved3:'typing.Any'=0) -> 'PyIEnumSTATSTG':
         """
         Retrieves an enumerator object that can be used to enumerate the 

storage and stream objects contained within this storage object.

Args:

      reserved1(typing.Any):Reserved - must be zero.
      reserved2(typing.Any):A reserved param.  Always pass None.  NULL is always passed to the COM function
      reserved3(typing.Any):Reserved - must be zero.

Returns:

      PyIEnumSTATSTG
        
         """
         pass


      def DestroyElement(self,name:'str') -> 'None':
         """
         Removes the specified storage or stream from this storage object.

Args:

      name(str):The name of the element to be removed.

Returns:

      None
        
         """
         pass


      def RenameElement(self,OldName:'typing.Any',NewName:'typing.Any') -> 'None':
         """
         Renames the specified substorage or stream in this storage object.

Args:

      OldName(typing.Any):The name of the substorage or stream to be changed.
      NewName(typing.Any):The new name for the specified sustorage or stream.

Returns:

      None
        
         """
         pass


      def SetElementTimes(self,name:'typing.Any',ctime:'PyTime',atime:'PyTime',mtime:'PyTime') -> 'None':
         """
         Sets the modification, access, and creation times of the specified storage 

element, if supported by the underlying file system.

Args:

      name(typing.Any):The name of the storage object element whose times are to be modified. If NULL, the time is set on the root storage rather than one of its elements.
      ctime(PyTime):Either the new creation time for the element or None if the creation time is not to be modified.
      atime(PyTime):Either the new access time for the element or None if the access time is not to be modified.
      mtime(PyTime):Either the new modification time for the element or None if the modification time is not to be modified.

Returns:

      None
        
         """
         pass


      def SetClass(self,clsid:'PyIID') -> 'None':
         """
         Assigns the specified CLSID to this storage object.

Args:

      clsid(PyIID):The class identifier (CLSID) that is to be associated with the storage object.

Returns:

      None
        
         """
         pass


      def SetStateBits(self,grfStateBits:'typing.Any',grfMask:'typing.Any') -> 'None':
         """
         Stores up to 32 bits of state information in this storage object.

Args:

      grfStateBits(typing.Any):Specifies the new values of the bits to set. No legal values are defined for these bits; they are all reserved for future use and must not be used by applications.
      grfMask(typing.Any):A binary mask indicating which bits in grfStateBits are significant in this call.

Returns:

      None
        
         """
         pass


      def Stat(self,grfStatFlag:'typing.Any') -> 'STATSTG':
         """
         Retrieves the STATSTG structure for this open storage object.

Args:

      grfStatFlag(typing.Any):Specifies that some of the fields in the STATSTG structure are not returned, thus saving a memory allocation operation. Values are taken from the STATFLAG enumeration.

Returns:

      STATSTG
        
         """
         pass


class PyIStream(object):
      """A Python interface to IStream"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Read(self,numBytes:'typing.Any') -> 'str':
         """
         Read the specified number of bytes from the string.

Args:

      numBytes(typing.Any):The number of bytes to read from the stream.  Must not be zero.Return ValueThe result is a string containing binary data.

Returns:

      str:The number of bytes to read from the stream.  Must not be zero.Return ValueThe result is a string containing binary data.

        
         """
         pass


      def read(self,numBytes:'typing.Any') -> 'str':
         """
         Read the specified number of bytes from the string.

Args:

      numBytes(typing.Any):The number of bytes to read from the stream.  Must not be zero.Return ValueThe result is a string containing binary data.

Returns:

      str:The number of bytes to read from the stream.  Must not be zero.Return ValueThe result is a string containing binary data.

        
         """
         pass


      def Write(self,data:'str') -> 'None':
         """
         Write data to a stream

Args:

      data(str):The binary data to write.

Returns:

      None
        
         """
         pass


      def write(self,data:'str') -> 'None':
         """
         Write data to a stream

Args:

      data(str):The binary data to write.

Returns:

      None
        
         """
         pass


      def Seek(self,offset:'typing.Any',origin:'typing.Any') -> 'ULARGE_INTEGER':
         """
         Changes the seek pointer to a new location.

Args:

      offset(typing.Any):The new location
      origin(typing.Any):Relative to where?

Returns:

      ULARGE_INTEGER
        
         """
         pass


      def SetSize(self,newSize:'ULARGE_INTEGER') -> 'None':
         """
         Changes the size of the stream object.

Args:

      newSize(ULARGE_INTEGER):The new size

Returns:

      None
        
         """
         pass


      def CopyTo(self,stream:'PyIStream',cb:'ULARGE_INTEGER') -> 'ULARGE_INTEGER':
         """
         Copies a specified number of bytes from the current seek pointer in the 

stream to the current seek pointer in another stream.

Args:

      stream(PyIStream):The stream to write to.
      cb(ULARGE_INTEGER):The number of bytes to write.Return ValueThe return value is the number of bytes actually written.

Returns:

      ULARGE_INTEGER:The number of bytes to write.Return ValueThe return value is the number of bytes actually written.

        
         """
         pass


      def Commit(self,flags:'typing.Any') -> 'None':
         """
         Ensures that any changes made to a stream object open in transacted mode are reflected in 

the parent storage.

Args:

      flags(typing.Any):Controls how changes are performed.

Returns:

      None
        
         """
         pass


      def Revert(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def LockRegion(self,offset:'ULARGE_INTEGER',cb:'ULARGE_INTEGER',lockType:'typing.Any') -> 'None':
         """
         Restricts access to a specified range of bytes in the stream.

Args:

      offset(ULARGE_INTEGER):Integer that specifies the byte offset for the beginning of the range.
      cb(ULARGE_INTEGER):The number of bytes to restrict.
      lockType(typing.Any):Restrictions requested.

Returns:

      None
        
         """
         pass


      def UnLockRegion(self,offset:'ULARGE_INTEGER',cb:'ULARGE_INTEGER',lockType:'typing.Any') -> 'None':
         """
         None

Args:

      offset(ULARGE_INTEGER):Integer that specifies the byte offset for the beginning of the range.
      cb(ULARGE_INTEGER):The number of bytes to restrict.
      lockType(typing.Any):Restrictions requested.

Returns:

      None
        
         """
         pass


      def Clone(self,) -> 'PyIStream':
         """
         Creates a new stream object with its own seek pointer that references the 

same bytes as the original stream.

Args:



Returns:

      PyIStream
        
         """
         pass


      def Stat(self,grfStatFlag:'typing.Any'=0) -> 'STATSTG':
         """
         Returns information about the stream

Args:

      grfStatFlag(typing.Any):Flags.

Returns:

      STATSTG
        
         """
         pass


class PyITask(object):
      """Python object that encapsulates the ITask interface, inherits all the methods of PyIScheduledWorkItem"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetApplicationName(self,ApplicationName:'typing.Any') -> 'None':
         """
         Specify which program the task will run

Args:

      ApplicationName(typing.Any):Program to execute

Returns:

      None
        
         """
         pass


      def GetApplicationName(self,) -> 'typing.Any':
         """
         Retrieve name of program that task will run

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetParameters(self,Parameters:'typing.Any') -> 'None':
         """
         Sets command line parameters

Args:

      Parameters(typing.Any):String containing command line parameters

Returns:

      None
        
         """
         pass


      def GetParameters(self,) -> 'typing.Any':
         """
         Returns command line parameters for task

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetWorkingDirectory(self,WorkingDirectory:'typing.Any') -> 'None':
         """
         Sets initial working directory for task

Args:

      WorkingDirectory(typing.Any):Initial working directory

Returns:

      None
        
         """
         pass


      def GetWorkingDirectory(self,) -> 'typing.Any':
         """
         Return working directory that the task will start out in

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetPriority(self,Priority:'typing.Any') -> 'None':
         """
         Sets priority for task

Args:

      Priority(typing.Any):One of REALTIME_PRIORITY_CLASS, HIGH_PRIORITY_CLASS, NORMAL_PRIORITY_CLASS, IDLE_PRIORITY_CLASS

Returns:

      None
        
         """
         pass


      def GetPriority(self,) -> 'typing.Any':
         """
         Gets priority that will be assigned to process when task starts

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetTaskFlags(self,dwFlags:'typing.Any') -> 'None':
         """
         Sets flag for task.

Args:

      dwFlags(typing.Any):None currently defined

Returns:

      None
        
         """
         pass


      def GetTaskFlags(self,) -> 'typing.Any':
         """
         Retrieve task flags (None currently defined)

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetMaxRunTime(self,MaxRunTimeMS:'typing.Any') -> 'None':
         """
         Sets maximun run time for task, use -1 to disable

Args:

      MaxRunTimeMS(typing.Any):Specified in milliseconds (use -1 to disable, not 0)

Returns:

      None
        
         """
         pass


      def GetMaxRunTime(self,) -> 'typing.Any':
         """
         Returns maximun run time for task

Args:



Returns:

      typing.Any
        
         """
         pass


class PyITaskScheduler(object):
      """Interface to the Windows Task Scheduler"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetTargetComputer(self,Computer:'typing.Any') -> 'None':
         """
         Connect to another machine to manage its tasks

Args:

      Computer(typing.Any):Name of system to connect toCommentsLeading backslashes are required.  Call will succeed without them, but no other methods will work.

Returns:

      None
        
         """
         pass


      def GetTargetComputer(self,) -> 'typing.Any':
         """
         Returns name of computer that the Task Scheduler is 

connected to

Args:



Returns:

      typing.Any
        
         """
         pass


      def Enum(self,) -> 'typing.Tuple[str, ...]':
         """
         Retrieve list of task names

Args:



Returns:

      typing.Tuple[str, ...]
        
         """
         pass


      def Activate(self,Name:'typing.Any',riid:'PyIID') -> 'PyITask':
         """
         Opens the specified task and returns an ITask interface for it

Args:

      Name(typing.Any):Name of task to retreive
      riid(PyIID):IID to return, currently only IID_ITask accepted

Returns:

      PyITask
        
         """
         pass


      def Delete(self,TaskName:'typing.Any') -> 'None':
         """
         Delete task by name

Args:

      TaskName(typing.Any):Name of task to delete

Returns:

      None
        
         """
         pass


      def NewWorkItem(self,TaskName:'typing.Any',rclsid:'PyIID',riid:'PyIID') -> 'PyITask':
         """
         Creates a new task

Args:

      TaskName(typing.Any):Name of new task
      rclsid(PyIID):Class id of work item, currently only CLSID_CTask (defaults if not passed in)
      riid(PyIID):Interface IID to return, currently only IID_ITask (defaults if not passed in)

Returns:

      PyITask
        
         """
         pass


      def AddWorkItem(self,TaskName:'typing.Any',WorkItem:'PyITask') -> 'None':
         """
         Create a new scheduled task from PyITask object

Args:

      TaskName(typing.Any):Name of task to be created
      WorkItem(PyITask):Existing PyITask objectCommentsThe PyItask passed in is modified in place and on success is associated with the new task, not the old one

Returns:

      None
        
         """
         pass


      def IsOfType(self,Name:'typing.Any',riid:'PyIID') -> 'None':
         """
         Check if named object supports specified interface

Args:

      Name(typing.Any):Name of object
      riid(PyIID):Named object is checked that it supports the interface of this IID

Returns:

      None
        
         """
         pass


class PyITaskTrigger(object):
      """Python object that encapsulates the ITaskTrigger interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetTrigger(self,Trigger:'PyTASK_TRIGGER') -> 'None':
         """
         Set trigger parameters from a PyTASK_TRIGGER object

Args:

      Trigger(PyTASK_TRIGGER):Python object representing a TASK_TRIGGER struct

Returns:

      None
        
         """
         pass


      def GetTrigger(self,) -> 'PyTASK_TRIGGER':
         """
         Retrieves trigger parms as a PyTASK_TRIGGER object

Args:



Returns:

      PyTASK_TRIGGER
        
         """
         pass


      def GetTriggerString(self,) -> 'str':
         """
         Build text summary of trigger

Args:



Returns:

      str
        
         """
         pass


class PyITaskbarList(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def HrInit(self,) -> 'None':
         """
         Intializes the interface before use

Args:



Returns:

      None
        
         """
         pass


      def AddTab(self,hwnd:'int') -> 'None':
         """
         Places a window on the taskbar

Args:

      hwnd(int):Handle to window, should have WS_CAPTION style

Returns:

      None
        
         """
         pass


      def DeleteTab(self,hwnd:'int') -> 'None':
         """
         Removes a window from the taskbar

Args:

      hwnd(int):Handle to window, should have WS_CAPTION style

Returns:

      None
        
         """
         pass


      def ActivateTab(self,hwnd:'int') -> 'None':
         """
         Marks a window as the active tab on the taskbar

Args:

      hwnd(int):Handle to window, should have WS_CAPTION style

Returns:

      None
        
         """
         pass


      def SetActiveAlt(self,hwnd:'int') -> 'None':
         """
         Sets the window as the active tab, without displaying it as pressed on the 

taskbar

Args:

      hwnd(int):Handle to window, should have WS_CAPTION style

Returns:

      None
        
         """
         pass


class PyITransferAdviseSink(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def UpdateProgress(self,SizeCurrent:'typing.Any',SizeTotal:'typing.Any',FilesCurrent:'typing.Any',FilesTotal:'typing.Any',FoldersCurrent:'typing.Any',FoldersTotal:'typing.Any') -> 'None':
         """
         Gives an estimate of amount of work completed

Args:

      SizeCurrent(typing.Any):Bytes transferred so far
      SizeTotal(typing.Any):Total number of bytes
      FilesCurrent(typing.Any):Number of files processed already
      FilesTotal(typing.Any):Total number of files
      FoldersCurrent(typing.Any):Number of folders processed already
      FoldersTotal(typing.Any):Total number of folder

Returns:

      None
        
         """
         pass


      def UpdateTransferState(self,State:'typing.Any') -> 'None':
         """
         Notifies client of current operation state

Args:

      State(typing.Any):A TRANSFER_ADVISE_STATE value (shellcon.TS_*)

Returns:

      None
        
         """
         pass


      def ConfirmOverwrite(self,Source:'PyIShellItem',DestParent:'PyIShellItem',Name:'typing.Any') -> 'typing.Any':
         """
         Asks user for permission to overwrite an existing item

Args:

      Source(PyIShellItem):The item that will replace existing item
      DestParent(PyIShellItem):Folder into which item will be placed
      Name(typing.Any):New name for item, or None if item is to keep original name

Returns:

      typing.Any
        
         """
         pass


      def ConfirmEncryptionLoss(self,Source:'PyIShellItem') -> 'typing.Any':
         """
         Notifies user when an item can't be encrypted at 

destination

Args:

      Source(PyIShellItem):Item that failed to be encrypted

Returns:

      typing.Any
        
         """
         pass


      def FileFailure(self,Item:'PyIShellItem',ItemName:'typing.Any',Error:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Notifies user of failure, and queries how to proceed

Args:

      Item(PyIShellItem):The shell item that caused the failure
      ItemName(typing.Any):Name of item if different than above, can be None
      Error(typing.Any):HRESULT error code from operationReturn ValueReturns the HRESULT and new file name if renaming resolved the failure

Returns:

      typing.Tuple[typing.Any, typing.Any]:HRESULT error code from operationReturn ValueReturns the HRESULT and new file name if renaming resolved the failure

        
         """
         pass


      def SubStreamFailure(self,Item:'PyIShellItem',StreamName:'typing.Any',Error:'typing.Any') -> 'typing.Any':
         """
         Notifies user of failure on a substream, and queries how to 

proceed

Args:

      Item(PyIShellItem):The item whose stream couldn't be created
      StreamName(typing.Any):Name of the failed stream
      Error(typing.Any):HRESULT failure code from operationReturn ValueReturns COPYENGINE_S_* if operation is to continue, or COPYENGINE_E_* HRESULT if cancelled

Returns:

      typing.Any:HRESULT failure code from operationReturn ValueReturns COPYENGINE_S_* if operation is to continue, or COPYENGINE_E_* HRESULT if cancelled

        
         """
         pass


      def PropertyFailure(self,Item:'PyIShellItem',key:'PyPROPERTYKEY',Error:'typing.Any') -> 'typing.Any':
         """
         Notifies user of failure to set an item's properties

Args:

      Item(PyIShellItem):The item whose property could not be set
      key(PyPROPERTYKEY):Identifies the property that caused the error, or None if all properties failed
      Error(typing.Any):HRESULT error code returned by the operationReturn ValueReturns COPYENGINE_S_* to indicate that the failure was handled, or COPYENGINE_E_USERCANCELLED to cancel pending operations

Returns:

      typing.Any:HRESULT error code returned by the operationReturn ValueReturns COPYENGINE_S_* to indicate that the failure was handled, or 

COPYENGINE_E_USERCANCELLED to cancel pending operations

        
         """
         pass


class PyITransferDestination(object):
      """Implemented by shell extensions that act as targets for item copy or move operations"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Advise(self,Sink:'PyITransferAdviseSink') -> 'typing.Any':
         """
         Connects an advise sink

Args:

      Sink(PyITransferAdviseSink):Event sink to receive notificationsReturn ValueReturns an id for the connection, to be passed to PyITransferDestination::Unadvise

Returns:

      typing.Any:Event sink to receive notificationsReturn ValueReturns an id for the connection, to be passed to PyITransferDestination::Unadvise

        
         """
         pass


      def Unadvise(self,Cookie:'typing.Any') -> 'None':
         """
         Disconnects an advise sink

Args:

      Cookie(typing.Any):Connection identifier as returned by PyITransferDestination::Advise

Returns:

      None
        
         """
         pass


      def CreateItem(self,Name:'typing.Any',Attributes:'typing.Any',Size:'typing.Any',Flags:'typing.Any',riidItem:'PyIID',riidResources:'PyIID') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Requests that a new item be created

Args:

      Name(typing.Any):Filename to be created
      Attributes(typing.Any):File attributes
      Size(typing.Any):Size of file
      Flags(typing.Any):Combination of shellcon.TSF_* flags
      riidItem(PyIID):Item interface to return
      riidResources(PyIID):Resource interface to returnReturn ValueReturns the HRESULT and requested interfaces.  Interfaces may be None if function returns one of the informational codes (shellcon.COPYENGINE_S_*)

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]:Resource interface to return
Return ValueReturns the HRESULT and requested interfaces.  Interfaces may be None if 

function returns one of the informational codes (shellcon.COPYENGINE_S_*)

        
         """
         pass


class PyITransferMediumItem(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyITransferSource(object):
      """Implemented by shell folders that can act as the source of shell item operations"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Advise(self,Sink:'PyITransferAdviseSink') -> 'typing.Any':
         """
         Connects an advise sink to receive notifications

Args:

      Sink(PyITransferAdviseSink):Event sink to respond to notifications

Returns:

      typing.Any
        
         """
         pass


      def Unadvise(self,Cookie:'typing.Any') -> 'None':
         """
         Disconnects an event sink

Args:

      Cookie(typing.Any):Connection id as returned by PyITransferSource::Advise

Returns:

      None
        
         """
         pass


      def SetProperties(self,proparray:'PyIPropertyChangeArray') -> 'None':
         """
         Specifies changes to be applied to items' properties

Args:

      proparray(PyIPropertyChangeArray):Property changes to be applied by PyITransferSource::ApplyPropertiesToItem

Returns:

      None
        
         """
         pass


      def OpenItem(self,Item:'PyIShellItem',flags:'typing.Any',riid:'PyIID') -> 'typing.Tuple[typing.Any, PyIShellItemResources]':
         """
         Initiates the copying of an item

Args:

      Item(PyIShellItem):The item to be copied.
      flags(typing.Any):Combination of shellcon.TSF_* flags
      riid(PyIID):The interface to return

Returns:

      typing.Tuple[typing.Any, PyIShellItemResources]
        
         """
         pass


      def MoveItem(self,Item:'PyIShellItem',ParentDst:'PyIShellItem',NameDst:'typing.Any',flags:'typing.Any') -> 'typing.Tuple[typing.Any, PyIShellItem]':
         """
         Moves a shell item into another folder

Args:

      Item(PyIShellItem):Item to be moved
      ParentDst(PyIShellItem):The folder into which it will be moved
      NameDst(typing.Any):New name for item after move, None to keep same name
      flags(typing.Any):Combination of shellcon.TSF_* flagsReturn ValueReturns the HRESULT from the operation and the new shell item, which may be None when the code in one of the informational COPYENGINE_S_* values.  See MSDN for descriptions of expected actions for specific error codes.

Returns:

      typing.Tuple[typing.Any, PyIShellItem]:Combination of shellcon.TSF_* flagsReturn ValueReturns the HRESULT from the operation and the new shell item, which may be None 

when the code in one of the informational COPYENGINE_S_* values.  See MSDN for descriptions 

of expected actions for specific error codes.

        
         """
         pass


      def RecycleItem(self,Source:'PyIShellItem',ParentDest:'PyIShellItem',flags:'typing.Any') -> 'typing.Tuple[typing.Any, PyIShellItem]':
         """
         Moves an item to the recycle bin

Args:

      Source(PyIShellItem):The item to be recycled
      ParentDest(PyIShellItem):Shell item representing the recycle bin
      flags(typing.Any):Combination of shellcon.TSF_* flags

Returns:

      typing.Tuple[typing.Any, PyIShellItem]
        
         """
         pass


      def RemoveItem(self,Source:'PyIShellItem',flags:'typing.Any') -> 'typing.Any':
         """
         Deletes an item without recycling

Args:

      Source(PyIShellItem):The item to be deleted
      flags(typing.Any):Combination of shellcon.TSF_* flagsReturn ValueReturns the HRESULT of the operation

Returns:

      typing.Any:Combination of shellcon.TSF_* flagsReturn ValueReturns the HRESULT of the operation

        
         """
         pass


      def RenameItem(self,Source:'PyIShellItem',NewName:'typing.Any',flags:'typing.Any') -> 'typing.Tuple[typing.Any, PyIShellItem]':
         """
         Renames a shell item

Args:

      Source(PyIShellItem):Item to be renamed
      NewName(typing.Any):The name to be given to the item
      flags(typing.Any):Combination of shellcon.TSF_* flags

Returns:

      typing.Tuple[typing.Any, PyIShellItem]
        
         """
         pass


      def LinkItem(self,Source:'PyIShellItem',ParentDest:'PyIShellItem',NewName:'typing.Any',flags:'typing.Any') -> 'typing.Tuple[typing.Any, PyIShellItem]':
         """
         Not implemented, according to MSDN

Args:

      Source(PyIShellItem):Description for psiSource
      ParentDest(PyIShellItem):Description for psiParentDest
      NewName(typing.Any):Description for NewName
      flags(typing.Any):Combination of shellcon.TSF_* flags

Returns:

      typing.Tuple[typing.Any, PyIShellItem]
        
         """
         pass


      def ApplyPropertiesToItem(self,Source:'PyIShellItem') -> 'PyIShellItem':
         """
         None

Args:

      Source(PyIShellItem):Item whose properties are to be changed

Returns:

      PyIShellItem
        
         """
         pass


      def GetDefaultDestinationName(self,Source:'PyIShellItem',ParentDest:'PyIShellItem') -> 'typing.Any':
         """
         Determines the name of an item as it would appear in a 

given folder

Args:

      Source(PyIShellItem):The item whose name is wanted
      ParentDest(PyIShellItem):The destination folder

Returns:

      typing.Any
        
         """
         pass


      def EnterFolder(self,ChildFolderDest:'PyIShellItem') -> 'typing.Any':
         """
         Informs the copy engine that a folder will be the target of a file 

operation

Args:

      ChildFolderDest(PyIShellItem):The destination folder for the operation

Returns:

      typing.Any
        
         """
         pass


      def LeaveFolder(self,ChildFolderDest:'PyIShellItem') -> 'typing.Any':
         """
         Informs the copy engine that the operation on a destination folder is 

finished

Args:

      ChildFolderDest(PyIShellItem):Destination folder

Returns:

      typing.Any
        
         """
         pass


class PyITypeComp(object):
      """An object that implements the ITypeComp interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Bind(self,szName:'str',wflags:'typing.Any'=0) -> 'typing.Any':
         """
         binds to a variable/type

Args:

      szName(str):The name to bind to
      wflags(typing.Any):the bind flags

Returns:

      typing.Any
        
         """
         pass


      def BindType(self,szName:'str') -> 'typing.Any':
         """
         binds to a type

Args:

      szName(str):The name to bind to

Returns:

      typing.Any
        
         """
         pass


class PyITypeInfo(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetContainingTypeLib(self,) -> 'typing.Tuple[PyITypeLib, typing.Any]':
         """
         Retrieves the containing type library and the index of 

the type description within that type library.

Args:



Returns:

      typing.Tuple[PyITypeLib, typing.Any]
        
         """
         pass


      def GetDocumentation(self,memberId:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Retrieves the documentation string, 

the complete Help file name and path, and the context ID for the Help topic for a specified type description.

Args:

      memberId(typing.Any):

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetFuncDesc(self,memberId:'typing.Any') -> 'FUNCDESC':
         """
         None

Args:

      memberId(typing.Any):

Returns:

      FUNCDESC
        
         """
         pass


      def GetImplTypeFlags(self,index:'typing.Any') -> 'typing.Any':
         """
         Retrieves the IMPLTYPEFLAGS enumeration for one implemented interface or 

base interface in a type description.

Args:

      index(typing.Any):

Returns:

      typing.Any
        
         """
         pass


      def GetIDsOfNames(self,) -> 'typing.Any':
         """
         Maps between member names and member IDs, and parameter names and parameter 

IDs.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetNames(self,memberId:'typing.Any') -> 'typing.Any':
         """
         Retrieves the variable with the specified member ID (or the name of 

the property or method and its parameters) that correspond to the specified function ID.

Args:

      memberId(typing.Any):

Returns:

      typing.Any
        
         """
         pass


      def GetTypeAttr(self,) -> 'TYPEATTR':
         """
         None

Args:



Returns:

      TYPEATTR
        
         """
         pass


      def GetRefTypeInfo(self,hRefType:'typing.Any') -> 'PyITypeInfo':
         """
         If a type description references other type descriptions, it 

retrieves the referenced type descriptions.

Args:

      hRefType(typing.Any):

Returns:

      PyITypeInfo
        
         """
         pass


      def GetRefTypeOfImplType(self,hRefType:'typing.Any') -> 'typing.Any':
         """
         Retrieves the type description of the implemented interface types.

Args:

      hRefType(typing.Any):CommentsIf a type description describes a COM class, it retrieves the type description of the implemented interface types. For an interface, GetRefTypeOfImplType returns the type information for inherited interfaces, if any exist.

Returns:

      typing.Any
        
         """
         pass


      def GetVarDesc(self,memberId:'typing.Any') -> 'VARDESC':
         """
         None

Args:

      memberId(typing.Any):

Returns:

      VARDESC
        
         """
         pass


      def GetTypeComp(self,) -> 'PyITypeComp':
         """
         None

Args:



Returns:

      PyITypeComp
        
         """
         pass


class PyITypeLib(object):
      """An object that implements the ITypeLib interface."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDocumentation(self,index:'typing.Any') -> 'typing.Any':
         """
         Retrieves documentation information about the library.

Args:

      index(typing.Any):The index of the type description within the libraryReturn ValueThe return type is a tuple of (name of item, documentation string, help context integer, help file name)

Returns:

      typing.Any:The index of the type description within the libraryReturn ValueThe return type is a tuple of (name of item, documentation string, help context integer, help file name)

        
         """
         pass


      def GetLibAttr(self,) -> 'TLIBATTR':
         """
         Retrieves the libraries attributes

Args:



Returns:

      TLIBATTR
        
         """
         pass


      def GetTypeComp(self,) -> 'PyITypeComp':
         """
         None

Args:



Returns:

      PyITypeComp
        
         """
         pass


      def GetTypeInfo(self,index:'typing.Any') -> 'PyITypeInfo':
         """
         Retrieves the specified type description in the library.

Args:

      index(typing.Any):The index of the type description within the library

Returns:

      PyITypeInfo
        
         """
         pass


      def GetTypeInfoCount(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetTypeInfoOfGuid(self,iid:'PyIID') -> 'PyITypeInfo':
         """
         Retrieves the type info of the specified GUID.

Args:

      iid(PyIID):GUID of the type description.

Returns:

      PyITypeInfo
        
         """
         pass


      def GetTypeInfoType(self,index:'typing.Any') -> 'typing.Any':
         """
         Retrieves the type of a type description.

Args:

      index(typing.Any):The index of the type description within the library

Returns:

      typing.Any
        
         """
         pass


class PyIUniformResourceLocator(object):
      """Interface to an internet shortcut"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetURL(self,) -> 'typing.Any':
         """
         Returns the URL for the shortcut

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetURL(self,URL:'typing.Any',InFlags:'typing.Any'=0) -> 'None':
         """
         Sets the URL for the shortcut

Args:

      URL(typing.Any):The url to be set
      InFlags(typing.Any):One of the shellcon.IURL_SETURL* flags

Returns:

      None
        
         """
         pass


      def InvokeCommand(self,Verb:'typing.Any',Flags:'typing.Any'=0,hwndParent:'int'=0) -> 'typing.Any':
         """
         Performs one of the object's predefined actions

Args:

      Verb(typing.Any):The verb to be invoked
      Flags(typing.Any):Combination of shellcon.IURL_INVOKECOMMAND_* flags
      hwndParent(int):Handle to parent window

Returns:

      typing.Any
        
         """
         pass


class PyIUnknown(object):
      """The base object for all PythonCOM objects.  Wraps a COM IUnknown object."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def QueryInterface(self,iid:'typing.Any',useIID:'typing.Any'=None) -> 'PyIUnknown':
         """
         Queries an object for a specific interface.

Args:

      iid(typing.Any):The IID requested.
      useIID(typing.Any):If provided and not None, will return an interface for the specified IID if (and only if) a native interface can not be supported. If the interface specified by iid is natively supported, this option is ignored.CommentsThe useIID parameter is a very dangerous option, and should only be used when you are sure you need it! By specifying this parameter, you are telling the COM framework that regardless of the true type of the result (as specified by iid), a Python wrapper of type useIID will be created.  If iid does not derive from useIID, then it is almost certain that using the object will cause an Access Violation. For example, this option can be used to obtain a PyIUnknown object if pythoncom does not natively support the interface. Another example might be to return an unsupported persistence interface as a PyIPersist instance. For backwards compatibility: the integer 0 implies None, and the integer 1 implies IID_IUnknown.Return ValueThe result is always an object derived from PyIUnknown. Any error (including E_NOINTERFACE) will generate a com_error exception.

Returns:

      PyIUnknown:If provided and not None, will return an 

interface for the specified IID if (and only if) a native interface can not be supported. 

If the interface specified by iid is natively supported, this option is ignored.
Comments

The useIID parameter is a very dangerous option, and should only 

be used when you are sure you need it! 

By specifying this parameter, you are telling the COM framework that regardless 

of the true type of the result (as specified by iid), a Python wrapper 

of type useIID will be created.  If iid does not derive from useIID, 

then it is almost certain that using the object will cause an Access Violation. 

For example, this option can be used to obtain a PyIUnknown object if 

pythoncom does not natively support the interface. 

Another example might be to return an unsupported persistence interface as a 

PyIPersist instance. 

For backwards compatibility: the integer 0 implies None, and the 

integer 1 implies IID_IUnknown.
Return ValueThe result is always an object derived from PyIUnknown. 

Any error (including E_NOINTERFACE) will generate a com_error exception.

        
         """
         pass


class PyIViewObject(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Draw(self,dwDrawAspect:'typing.Any',lindex:'typing.Any',aspectFlags:'typing.Any',hdcTargetDev:'typing.Any',hdcDraw:'typing.Any',arg:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',arg1:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',funcContinue:'typing.Any',obContinue:'typing.Any') -> 'None':
         """
         Description of Draw.

Args:

      dwDrawAspect(typing.Any):Description for dwDrawAspect
      lindex(typing.Any):Description for lindex
      aspectFlags(typing.Any):Integer value for the dwFlags item of the DVASPECTINFO structure.
      hdcTargetDev(typing.Any):Description for hdcTargetDev
      hdcDraw(typing.Any):Description for hdcDraw
      arg(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Bounds rectangle.
      arg1(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):WBounds rectangle.
      funcContinue(typing.Any):A continue function.
      obContinue(typing.Any):Value passed to the function.

Returns:

      None
        
         """
         pass


      def GetColorSet(self,dwDrawAspect:'typing.Any',lindex:'typing.Any',aspectFlags:'typing.Any',hicTargetDev:'typing.Any') -> 'None':
         """
         Description of GetColorSet.

Args:

      dwDrawAspect(typing.Any):Description for dwDrawAspect
      lindex(typing.Any):Description for lindex
      aspectFlags(typing.Any):Integer value for the dwFlags item of the DVASPECTINFO structure.
      hicTargetDev(typing.Any):Description for hicTargetDev

Returns:

      None
        
         """
         pass


      def Freeze(self,dwDrawAspect:'typing.Any',lindex:'typing.Any',aspectFlags:'typing.Any') -> 'None':
         """
         Description of Freeze.

Args:

      dwDrawAspect(typing.Any):Description for dwDrawAspect
      lindex(typing.Any):Description for lindex
      aspectFlags(typing.Any):Integer value for the dwFlags item of the DVASPECTINFO structure.

Returns:

      None
        
         """
         pass


      def Unfreeze(self,dwFreeze:'typing.Any') -> 'None':
         """
         Description of Unfreeze.

Args:

      dwFreeze(typing.Any):Description for dwFreeze

Returns:

      None
        
         """
         pass


      def SetAdvise(self,aspects:'typing.Any',advf:'typing.Any',pAdvSink:'typing.Any') -> 'None':
         """
         Description of SetAdvise.

Args:

      aspects(typing.Any):Description for aspects
      advf(typing.Any):Description for advf
      pAdvSink(typing.Any):Description for pAdvSink

Returns:

      None
        
         """
         pass


      def GetAdvise(self,) -> 'None':
         """
         Description of GetAdvise.

Args:



Returns:

      None
        
         """
         pass


class PyIViewObject2(object):
      """Description of the interface"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetExtent(self,dwDrawAspect:'typing.Any',lindex:'typing.Any',targetDevice:'typing.Any') -> 'None':
         """
         Description of GetExtent.

Args:

      dwDrawAspect(typing.Any):Description for dwDrawAspect
      lindex(typing.Any):Description for lindex
      targetDevice(typing.Any):Description for lindex

Returns:

      None
        
         """
         pass


class PyMAPINAMEIDArray(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyOLEMENUGROUPWIDTHS(object):
      """Tuple containing 6 ints indicating nbr of options in each menu group"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyPROPERTYKEY(object):
      """A tuple of a fmtid and property id (IID, int) that uniquely identifies a property"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyPROPVARIANT(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def vt(self)->'typing.Any':
         """The variant type, a combination of VARENUM values including flags.  (read only)MethodsGetValueReturns an object representing the variant value ToStringReturns the value as a string ChangeTypeCoerce to a different variant type """
         pass


      def GetValue(self,) -> 'typing.Any':
         """
         Returns an object representing the variant value

Args:



Returns:

      typing.Any
        
         """
         pass


      def ToString(self,) -> 'typing.Any':
         """
         Returns the value as a string

Args:



Returns:

      typing.Any
        
         """
         pass


      def ChangeType(self,Type:'typing.Any',Flags:'typing.Any'=0) -> 'PyPROPVARIANT':
         """
         Coerce to a different variant type

Args:

      Type(typing.Any):New variant type, combination of pythoncom.VT_* values
      Flags(typing.Any):Reserved (PROPVAR_CHANGE_FLAGS)Win32 API References

Returns:

      PyPROPVARIANT
        
         """
         pass


class PySAndRestriction(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySBinaryArray(object):
      """A sequence of strings containing binary data."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySBitMaskRestriction(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySContentRestriction(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySExistRestriction(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySHELL_ITEM_RESOURCE(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySNotRestriction(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySOrRestriction(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySPropTagArray(object):
      """A sequence of integers"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySPropValue(object):
      """A MAPI property value.  Property values can either be passed from 

python into MAPI functions, or returned from MAPI functions to Python."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySPropValueArray(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySPropertyRestriction(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySRestriction(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySRow(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySRowSet(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySSortOrderItem(object):
      """An item in a SortOrderSet."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySSortOrderSet(object):
      """An object describing a SortOrderSet."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PySTGMEDIUM(object):
      """A STGMEDIUM object represents a COM STGMEDIUM structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def tymed(self)->'typing.Any':
         """An integer indicating the type of data in the stgmedium"""
         pass


      @property
      def data(self)->'typing.Any':
         """The data in the stgmedium. The result depends on the value of the 'tymed' property of the PySTGMEDIUM object.tymedResult TypeTYMED_GDIAn integer GDI handleTYMED_MFPICTAn integer METAFILE handleTYMED_ENHMFAn integer ENHMETAFILE handleTYMED_HGLOBALA string with the bytes of the global memory object.TYMED_FILEA string/unicode filenameTYMED_ISTREAMA PyIStream objectTYMED_ISTORAGEA PyIStorage object"""
         pass


      @property
      def data_handle(self)->'typing.Any':
         """The raw 'integer' representation of the data. For TYMED_HGLOBAL, this is the handle rather than the string data. For the string and interface types, this is an integer holding the pointer."""
         pass


      def set(self,tymed:'typing.Any',data:'typing.Any') -> 'None':
         """
         Sets the type and data of the object.

Args:

      tymed(typing.Any):The type of the data
      data(typing.Any):

Returns:

      None
        
         """
         pass


class PyTASK_TRIGGER(object):
      """Python object representing a TASK_TRIGGER structure via the structmember Api"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class RTF_WCSINFO(object):
      """A tuple representing a RTF_WCSINFO structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class SHFILEINFO(object):
      """A tuple representing a SHFILEINFO structure 

Represented as a tuple of (hIcon, iIcon, dwAttributes, displayName, typeName)"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class SHFILEOPSTRUCT(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class SI_ACCESS(object):
      """Tuple of 4 items representing SI_ACCESS struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class SI_INHERIT_TYPE(object):
      """Tuple of 3 items describing a method of inheritance"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class SI_OBJECT_INFO(object):
      """Six-tuple representing SI_OBJECT_INFO struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class STATSTG(object):
      """A tuple representing a STATSTG structure"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class TLIBATTR(object):
      """Type library attributes are represented as a tuple of:"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class TYPEATTR(object):
      """A TYPEATTR object represents a COM TYPEATTR structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def iid(self)->'PyIID':
         """The IID"""
         pass


      @property
      def lcid(self)->'typing.Any':
         """The lcid"""
         pass


      @property
      def memidConstructor(self)->'typing.Any':
         """ID of constructor"""
         pass


      @property
      def memidDestructor(self)->'typing.Any':
         """ID of destructor"""
         pass


      @property
      def cbSizeInstance(self)->'typing.Any':
         """The size of an instance of this type"""
         pass


      @property
      def typekind(self)->'typing.Any':
         """The kind of type this information describes.  One of the win32con.TKIND_* constants."""
         pass


      @property
      def cFuncs(self)->'typing.Any':
         """Number of functions."""
         pass


      @property
      def cVars(self)->'typing.Any':
         """Number of variables/data members."""
         pass


      @property
      def cImplTypes(self)->'typing.Any':
         """Number of implemented interfaces."""
         pass


      @property
      def cbSizeVft(self)->'typing.Any':
         """The size of this type's VTBL"""
         pass


      @property
      def cbAlignment(self)->'typing.Any':
         """Byte alignment for an instance of this type."""
         pass


      @property
      def wTypeFlags(self)->'typing.Any':
         """One of the pythoncom TYPEFLAG_"""
         pass


      @property
      def wMajorVerNum(self)->'typing.Any':
         """Major version number."""
         pass


      @property
      def wMinorVerNum(self)->'typing.Any':
         """Minor version number."""
         pass


      @property
      def tdescAlias(self)->'TYPEDESC':
         """If TypeKind == pythoncom.TKIND_ALIAS, specifies the type for which this type is an alias."""
         pass


      @property
      def idldeskType(self)->'IDLDESC':
         """IDL attributes of the described type."""
         pass


class TYPEDESC(object):
      """A typedesc is a complicated, recursive object, 

It may be either a simple Python type, or a tuple of (indirectType, object), where object 

may be a simple Python type, or a tuple of etc ..."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class VARDESC(object):
      """A VARDESC object represents a COM VARDESC structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def memid(self)->'typing.Any':
         """The dispid of the member"""
         pass


      @property
      def value(self)->'typing.Union[typing.Any]':
         """A value for the variant.  If PERINSTANCE then an offset into the instance, otherwise a variant converted to a Python object."""
         pass


      @property
      def elemdescVar(self)->'ELEMDESC':
         """Object describing the member."""
         pass


      @property
      def varFlags(self)->'typing.Any':
         """Variable flags"""
         pass


      @property
      def varkind(self)->'typing.Any':
         """Kind flags."""
         pass


class CHARFORMAT(object):
      """Describes a CHARFORMAT tuple"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class CREATESTRUCT(object):
      """A representation of a Windows CREATESTRUCT structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class LV_COLUMN(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class LV_ITEM(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PARAFORMAT(object):
      """Describes a PARAFORMAT tuple"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyAssocCObject(object):
      """An internal class."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyAssocObject(object):
      """An internal class."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AttachObject(self,) -> 'None':
         """
         Attaches a Python object for lookup of "virtual" functions.

Args:



Returns:

      None
        
         """
         pass


      def GetAttachedObject(self,) -> 'typing.Any':
         """
         Returned the attached Python object, or None.

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCBitmap(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateCompatibleBitmap(self,dc:'PyCDC',width:'typing.Any',height:'typing.Any') -> 'None':
         """
         Creates a bitmap compatible with the specified device context.

Args:

      dc(PyCDC):Specifies the device context.
      width(typing.Any):The width (in bits) of the bitmap
      height(typing.Any):The height (in bits) of the bitmap.

Returns:

      None
        
         """
         pass


      def GetSize(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Returns the size of the bitmap object.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def GetHandle(self,) -> 'PyGdiHANDLE':
         """
         Returns the HBITMAP for a bitmap object

Args:



Returns:

      typing.Any
        
         """
         pass


      def LoadBitmap(self,idRes:'typing.Any',obDLL:'PyDLL'=None) -> 'None':
         """
         Loads a bitmap from a DLL object.

Args:

      idRes(typing.Any):The resource ID of the bitmap
      obDLL(PyDLL):The DLL object to load from.

Returns:

      None
        
         """
         pass


      def LoadBitmapFile(self,fileObject:'typing.Any') -> 'None':
         """
         Loads a bitmap (.BMP) format 

from a file object.

Args:

      fileObject(typing.Any):The file object to load the .BMP format file from.

Returns:

      None
        
         """
         pass


      def LoadPPMFile(self,fileObject:'typing.Any',cols:'typing.Any',rows:'typing.Any') -> 'None':
         """
         Loads a bitmap in Portable Pix Map (PPM) format 

from a file object.

Args:

      fileObject(typing.Any):The file object to load the PPM format file from.
      cols(typing.Any):The number of columns in the bitmap.
      rows(typing.Any):The number of rows in the bitmap.

Returns:

      None
        
         """
         pass


      def Paint(self,dcObject:'PyCDC',arg:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',arg1:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'None':
         """
         Paint a bitmap.

Args:

      dcObject(PyCDC):The DC object to paint the bitmap to.
      arg(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The destination rectangle to paint to.
      arg1(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The source rectangle to paint from.

Returns:

      None
        
         """
         pass


      def GetInfo(self,) -> 'typing.Any':
         """
         Returns the BITMAP structure info

Args:



Returns:

      typing.Any:PyCBitmap.GetInfo

dict = GetInfo()Returns the BITMAP structure info
Return ValueA dictionary of integers, keyed by the following strings: 

bmType 

bmWidth 

bmHeight 

bmWidthBytes 

bmPlanes 

bmBitsPixel

        
         """
         pass


      def GetBitmapBits(self,asString:'typing.Any'=0) -> 'typing.Union[str, typing.Any]':
         """
         Returns the bitmap bits.

Args:

      asString(typing.Any):If False, the result is a tuple of integers, if True, the result is a Python string

Returns:

      typing.Union[str, typing.Any]
        
         """
         pass


      def SaveBitmapFile(self,dcObject:'PyCDC',Filename:'str') -> 'typing.Any':
         """
         Saves a bitmap to a file.

Args:

      dcObject(PyCDC):The DC object that has rendered the bitmap.
      Filename(str):The file to save the bitmap to

Returns:

      typing.Any
        
         """
         pass


class PyCBrush(object):
      """An object encapsulating an MFC PyCBrush class."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateSolidBrush(self,) -> 'None':
         """
         Initializes a brush with a specified solid color.

Args:



Returns:

      None
        
         """
         pass


      def GetSafeHandle(self,) -> 'typing.Any':
         """
         Retrieves the HBRUSH for the brush as an integer

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCButton(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateWindow(self,caption:'str',style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',parent:'PyCWnd',_id:'typing.Any') -> 'None':
         """
         Creates the window for a new button object.

Args:

      caption(str):The caption (text) for the button.
      style(typing.Any):The style for the button.  Use any of the win32con.BS_* constants.
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The size and position of the button.
      parent(PyCWnd):The parent window of the button.  Usually a PyCDialog.
      _id(typing.Any):The buttons control ID.

Returns:

      None
        
         """
         pass


      def GetBitmap(self,) -> 'typing.Any':
         """
         Get the button's bitmap

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetBitmap(self,hBitmap:'typing.Any'=1) -> 'typing.Any':
         """
         Set the button's bitmap

Args:

      hBitmap(typing.Any):Handle of the new bitmap

Returns:

      typing.Any
        
         """
         pass


      def GetCheck(self,) -> 'typing.Any':
         """
         Retrieves the check state of a radio button or check box.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetCheck(self,idCheck:'typing.Any') -> 'None':
         """
         Sets or resets the state of a radio button or check box.

Args:

      idCheck(typing.Any):The ID of the button.

Returns:

      None
        
         """
         pass


      def GetState(self,) -> 'typing.Any':
         """
         Returns the state of the button.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetState(self,bHighlight:'typing.Any') -> 'typing.Any':
         """
         Sets the state of the button.

Args:

      bHighlight(typing.Any):The new state for the button.CommentsHighlighting affects the exterior of a button control. It has no effect on the check state of a radio button or check box.

Returns:

      typing.Any
        
         """
         pass


      def GetButtonStyle(self,) -> 'typing.Any':
         """
         Gets the style of the button.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetButtonStyle(self,style:'typing.Any',bRedraw:'typing.Any'=1) -> 'typing.Any':
         """
         Sets the style of the button.

Args:

      style(typing.Any):The new style for the button.
      bRedraw(typing.Any):Should the button be redrawn?

Returns:

      typing.Any
        
         """
         pass


class PyCCmdTarget(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def BeginWaitCursor(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def EndWaitCursor(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def HookCommand(self,obHandler:'typing.Any',_id:'typing.Any') -> 'typing.Any':
         """
         Hook a windows command handler.

Args:

      obHandler(typing.Any):The handler for the command message.  This must be a callable object.
      _id(typing.Any):The ID of the command to be handled, or zero to handle all command messages.CommentsobHandler will be called as the application receives command notification messages with the specified ID. Command notification messages are usually sent in response to menu or toolbar commands. When updating a user interface element, Pythonwin will first check if a handler has been installed via  PyCCmdTarget::HookCommandUpdate.  If so, this alone determines the state of the interface object.  If no Update handler exists, PythonWin will automatically enable a menu/toolbar item if a command handler exists The handler will be called with 2 arguments * The command id being handled. * The command notification code. If the handler returns TRUE, then the command will be passed on to the default handler, otherwise the message will be consumed. This method is best suited to handling messages from user interface elements, such as menus, toolbars, etc.  To handle notification messages from a control, you should use PyCCmdTarget::HookNotifyReturn ValueThe return value is the previous handler, or None.

Returns:

      typing.Any:The ID of the command to be handled, or zero to handle all command messages.Comments

obHandler will be called as the application receives command notification messages with the specified ID. 

Command notification messages are usually sent in response to menu or toolbar commands. 

When updating a user interface element, Pythonwin will first check if a 

handler has been installed via  PyCCmdTarget::HookCommandUpdate.  If so, this alone 

determines the state of the interface object.  If no Update handler exists, 

PythonWin will automatically enable a menu/toolbar item if a command handler exists 

The handler will be called with 2 arguments 

* The command id being handled. 

* The command notification code. 

If the handler returns TRUE, then the command will be passed on to the 

default handler, otherwise the message will be consumed. 

This method is best suited to handling messages from user interface 

elements, such as menus, toolbars, etc.  To handle notification messages from a control, 

you should use PyCCmdTarget::HookNotify
Return ValueThe return value is the previous handler, or None.

        
         """
         pass


      def HookCommandUpdate(self,obHandler:'typing.Any',_id:'typing.Any') -> 'typing.Any':
         """
         Hook a windows command update handler.

Args:

      obHandler(typing.Any):The handler for the command message.  This must be a callable object.
      _id(typing.Any):The ID of the command to be handled.CommentsThe handler object passed will be called as the application updates user interface elements with the specified ID. See PyCCmdTarget::HookCommand for a description of the rules used to determine command routing and updating.Return ValueThe return value is the previous handler, or None.

Returns:

      typing.Any:The ID of the command to be handled.Comments

The handler object passed will be called as 

the application updates user interface elements 

with the specified ID. 

See PyCCmdTarget::HookCommand for a description 

of the rules used to determine command routing and updating.
Return ValueThe return value is the previous handler, or None.

        
         """
         pass


      def HookOleEvent(self,) -> 'typing.Any':
         """
         Hook an OLE Event.

Args:



Returns:

      typing.Any:PyCCmdTarget.HookOleEvent

object = HookOleEvent()Hook an OLE Event.
Return ValueThe return value is the previous handler, or None.

        
         """
         pass


      def HookNotify(self,obHandler:'typing.Any',_id:'typing.Any') -> 'typing.Any':
         """
         Hook a windows command handler.

Args:

      obHandler(typing.Any):The handler for the command message.  This must be a callable object.
      _id(typing.Any):The ID of the command to be handled, or zero to handle all command messages.CommentsobHandler will be called as the application receives control notification messages. These may also be handled via  PyCCmdTarget::HookCommand, but this method is specific to control notifications, and therefore provides more information.The handler will be called with 2 arguments A tuple describing standard notification information. A tuple describing extra notification params, or an integer containing the address of the first byte of the extended information. If the handler returns TRUE, then the command will be passed on to the default handler, otherwise the message will be consumed.Certain notification codes are recognised internally, and these are converted to a Python tuple. If the extra information is not recognised, the address is passed.  These addresses could be extracted using win32ui::GetBytes and the struct module, or using Sam Rushing's calldll/dynwin module. (It would be possible to extend Pythonwin so a program can install certain knowledge about handlers, but this has not been implemented.)Return ValueThe return value is the previous handler, or None.

Returns:

      typing.Any:The ID of the command to be handled, or zero to handle all command messages.Comments

obHandler will be called as the application receives control notification messages. 

These may also be handled via  PyCCmdTarget::HookCommand, but this method is specific 

to control notifications, and therefore provides more information.

The handler will be called with 2 arguments 

A tuple describing standard notification information. 

A tuple describing extra notification params, or an integer containing the address of the first byte of the 

extended information. If the handler returns TRUE, then the command will be passed on to the default handler, 

otherwise the message will be consumed.

Certain notification codes are recognised internally, and these are converted to a Python tuple. 

If the extra information is not recognised, the address is passed.  These addresses could be 

extracted using win32ui::GetBytes and the struct module, or using 

Sam Rushing's calldll/dynwin module. (It would be possible to extend Pythonwin so a program 

can install certain knowledge about handlers, but this has not been implemented.)
Return ValueThe return value is the previous handler, or None.

        
         """
         pass


      def RestoreWaitCursor(self,) -> 'None':
         """
         Restores the appropriate hourglass cursor after the system cursor has 

changed.

Args:



Returns:

      None
        
         """
         pass


class PyCCmdUI(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def m_nIndex(self)->'typing.Any':
         """"""
         pass


      @property
      def m_nID(self)->'typing.Any':
         """"""
         pass


      @property
      def m_pMenu(self)->'PyCMenu':
         """"""
         pass


      @property
      def m_pSubMenu(self)->'PyCMenu':
         """"""
         pass


      def Enable(self,bEnable:'typing.Any'=1) -> 'None':
         """
         Enables or disables the user-interface item for this command.

Args:

      bEnable(typing.Any):TRUE if the item should be enabled, false otherwise.

Returns:

      None
        
         """
         pass


      def SetCheck(self,state:'typing.Any'=1) -> 'None':
         """
         Sets the check state of the user-interface item for this command.

Args:

      state(typing.Any):0 for unchecked, 1 for checked, or 2 for indeterminate.

Returns:

      None
        
         """
         pass


      def SetRadio(self,bOn:'typing.Any'=1) -> 'None':
         """
         Like the SetCheck member function, but operates on radio groups.

Args:

      bOn(typing.Any):TRUE if the item should be enabled, false otherwise.

Returns:

      None
        
         """
         pass


      def SetText(self,text:'str') -> 'None':
         """
         Sets the text for the user-interface item for this command.

Args:

      text(str):The text for the interface element.

Returns:

      None
        
         """
         pass


      def ContinueRouting(self,) -> 'None':
         """
         Tells the command-routing mechanism to continue routing the current message down 

the chain of handlers.

Args:



Returns:

      None
        
         """
         pass


class PyCColorDialog(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetColor(self,) -> 'typing.Any':
         """
         Determines the selected color.

Args:



Returns:

      typing.Any
        
         """
         pass


      def DoModal(self,) -> 'typing.Any':
         """
         Displays a dialog and allows the user to make a selection.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSavedCustomColors(self,) -> 'typing.Any':
         """
         Returns the saved custom colors.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetCurrentColor(self,color:'typing.Any') -> 'None':
         """
         Sets the currently selected color.

Args:

      color(typing.Any):The color to set.MFC References

Returns:

      None
        
         """
         pass


      def SetCustomColors(self,) -> 'None':
         """
         Sets one or more custom colors

Args:



Returns:

      None
        
         """
         pass


      def GetCustomColors(self,) -> 'typing.Tuple[typing.Any, ...]':
         """
         Gets the 16 currently defined custom colors

Args:



Returns:

      typing.Tuple[typing.Any, ...]
        
         """
         pass


class PyCComboBox(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddString(self,_object:'typing.Any') -> 'typing.Any':
         """
         Adds a string to a combobox.

Args:

      _object(typing.Any):Any object.  If not a string, __str__, __repr__ or a default repr() will be usedMFC References

Returns:

      typing.Any:CComboBox::AddString
Return ValueThe zero based index of the new string.

        
         """
         pass


      def DeleteString(self,pos:'typing.Any') -> 'typing.Any':
         """
         Deletes an item from a combobox.

Args:

      pos(typing.Any):The zero based index of the item to delete.MFC References

Returns:

      typing.Any:CComboBox::DeleteString
Return ValueThe count of the items remaining in the list.

        
         """
         pass


      def Dir(self,attr:'typing.Any',wild:'str') -> 'typing.Any':
         """
         Fills the list portion of a combobox with a directory listing.

Args:

      attr(typing.Any):The attributes of the files to locate
      wild(str):A file specification string - eg, *.*MFC References

Returns:

      typing.Any:CComboBox::Dir
Return ValueThe index of the last file name added to the list.

        
         """
         pass


      def GetCount(self,) -> 'typing.Any':
         """
         Returns the count of items in the combobox.

Args:



Returns:

      typing.Any:CListBox::GetCount
Return ValueReturns the number of items currently in the combobox.

        
         """
         pass


      def GetCurSel(self,) -> 'typing.Any':
         """
         Returns the index of the currently selected item.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetEditSel(self,) -> 'typing.Any':
         """
         Returns the selection of the edit control portion of a combo box.

Args:



Returns:

      typing.Any:CComboBox::GetEditSel
Return ValueA 32-bit value that contains the starting position in the low-order word and 

the position of the first nonselected character after the end of 

the selection in the high-order word. If this function is used on a combo box 

without an edit control, an exception is raised.

        
         """
         pass


      def GetExtendedUI(self,) -> 'typing.Any':
         """
         Indicates if the combo has the extended interface.

Args:



Returns:

      typing.Any:CComboBox::GetExtendedUI
Return ValueNonzero if the combo box has the extended user interface; otherwise 0.

        
         """
         pass


      def GetItemData(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the application-specific object associated with an item.

Args:

      item(typing.Any):The index of the item whose data is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def GetItemValue(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the application-specific value associated with an item.

Args:

      item(typing.Any):The index of the item whose data is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def GetLBText(self,index:'typing.Any') -> 'str':
         """
         Gets the string from the list of a combo box.

Args:

      index(typing.Any):The index of the item to return the string for.Return ValueThe requested string. If index does not specify a valid index, no exception is raised.

Returns:

      str:The index of the item to return the string for.Return ValueThe requested string. If index does 

not specify a valid index, no exception is raised.

        
         """
         pass


      def GetLBTextLen(self,index:'typing.Any') -> 'typing.Any':
         """
         Returns the length of a string in the list of a combobox.

Args:

      index(typing.Any):The index of the item to return the length of.MFC References

Returns:

      typing.Any
        
         """
         pass


      def InsertString(self,pos:'typing.Any',_object:'typing.Any') -> 'typing.Any':
         """
         Insert a string into a combobox.

Args:

      pos(typing.Any):The zero based index in the combobox to insert the new string
      _object(typing.Any):The object to be added to the comboboxMFC References

Returns:

      typing.Any:CComboBox::InsertString
Return ValueThe zero based index of the new string added.

        
         """
         pass


      def LimitText(self,_max:'typing.Any') -> 'typing.Any':
         """
         Limits the amount of text the edit portion of a combo box can hold.

Args:

      _max(typing.Any):The maximum number of characters the user can enter. If zero, the size is set to (virtually) unlimited.MFC References

Returns:

      typing.Any
        
         """
         pass


      def ResetContent(self,) -> 'None':
         """
         Clear all the items from a combobox.

Args:



Returns:

      None
        
         """
         pass


      def SelectString(self,after:'typing.Any',string:'str') -> 'None':
         """
         Searches for a combobox item that matches the specified string, and selects it.

Args:

      after(typing.Any):Contains the zero-based index of the item before the first item to be searched, or -1 for the entire combobox.
      string(str):The string to search for.MFC References

Returns:

      None:CComboBoxBox::SelectString
Return ValueThe return value is always None - an exception is raised if the string can not be located.

        
         """
         pass


      def SetCurSel(self,index:'typing.Any') -> 'None':
         """
         Selects an item in a combobox.

Args:

      index(typing.Any):The zero based index of the item to select.MFC References

Returns:

      None
        
         """
         pass


      def SetEditSel(self,start:'typing.Any',end:'typing.Any') -> 'None':
         """
         Sets the selection in the edit control portion of a combo box.

Args:

      start(typing.Any):Specifies the starting position. If the starting position is set to -1, then any existing selection is removed.
      end(typing.Any):Specifies the ending position. If the ending position is set to -1, then all text from the starting position to the last character in the edit control is selected.MFC References

Returns:

      None:PyCComboBox::SetEditSel
Return ValueThe return value is always None - an exception is raised if the combo is a dropdown style, or does not 

have an edit control.

        
         """
         pass


      def SetExtendedUI(self,bExtended:'typing.Any'=1) -> 'None':
         """
         Selects the Extended UI mode for a combo box.

Args:

      bExtended(typing.Any):Indicates if the combo should have the extended user interface.CommentsA combo box with the Extended UI flag set can be identified in the following ways:~ Clicking the static control displays the list box only for combo boxes with the CBS_DROPDOWNLIST style.~ Pressing the DOWN ARROW key displays the list box (F4 is disabled).~ Scrolling in the static control is disabled when the item list is not visible (the arrow keys are disabled).MFC References

Returns:

      None
        
         """
         pass


      def SetItemData(self,item:'typing.Any',Data:'typing.Any') -> 'typing.Any':
         """
         Sets the item's application-specific object value.

Args:

      item(typing.Any):Index of the item whose Data is to be set.
      Data(typing.Any):New value for the data.CommentsNote that a reference count is not added to the object.  This it is your responsibility to make sure the object remains alive while in the list.

Returns:

      typing.Any
        
         """
         pass


      def SetItemValue(self,item:'typing.Any',data:'typing.Any') -> 'typing.Any':
         """
         Sets the item's application-specific value.

Args:

      item(typing.Any):Index of the item whose Data is to be set.
      data(typing.Any):New value for the data.

Returns:

      typing.Any
        
         """
         pass


      def ShowDropDown(self,bShowIt:'typing.Any'=1) -> 'None':
         """
         Shows or hides the listbox portion of a combo box.

Args:

      bShowIt(typing.Any):Indicates if the listbox should be shown or hidden.

Returns:

      None
        
         """
         pass


class PyCCommonDialog(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCControl(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCControlBar(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def dockSite(self)->'PyCFrameWnd':
         """Current dock site, if dockable"""
         pass


      @property
      def dockBar(self)->'PyCWnd':
         """Current dock bar, if dockable"""
         pass


      @property
      def dockContext(self)->'PyCDockContext':
         """Used during dragging"""
         pass


      @property
      def dwStyle(self)->'typing.Any':
         """creation style (used for layout)"""
         pass


      @property
      def dwDockStyle(self)->'typing.Any':
         """indicates how bar can be docked"""
         pass


      def CalcDynamicLayout(self,length:'typing.Any',dwMode:'typing.Any') -> 'typing.Any':
         """
         The framework calls this member function to calculate the dimensions of 

a dynamic toolbar.

Args:

      length(typing.Any):The requested dimension of the control bar, either horizontal or vertical, depending on dwMode.
      dwMode(typing.Any):A combination of flags.

Returns:

      typing.Any
        
         """
         pass


      def CalcFixedLayout(self,bStretch:'typing.Any',bHorz:'typing.Any') -> 'typing.Any':
         """
         Calculates the horizontal size of a control bar

Args:

      bStretch(typing.Any):Indicates whether the bar should be stretched to the size of the frame. The bStretch parameter is nonzero when the bar is not a docking bar (not available for docking) and is 0 when it is docked or floating (available for docking).
      bHorz(typing.Any):Indicates that the bar is horizontally or vertically oriented.

Returns:

      typing.Any
        
         """
         pass


      def EnableDocking(self,style:'typing.Any') -> 'None':
         """
         pecifies whether the control bar supports docking and the sides of its parent 

window.

Args:

      style(typing.Any):Enables a control bar to be docked.

Returns:

      None
        
         """
         pass


      def EraseNonClient(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def GetBarStyle(self,) -> 'typing.Any':
         """
         Retrieves the control bar style settings.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetCount(self,) -> 'typing.Any':
         """
         Returns the number of non-HWND elements in the control bar.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetDockingFrame(self,) -> 'PyCFrameWnd':
         """
         Returns the frame window to which a control bar is docked.

Args:



Returns:

      PyCFrameWnd
        
         """
         pass


      def IsFloating(self,) -> 'typing.Any':
         """
         Returns a nonzero value if the control bar in question is a floating control 

bar.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetBarStyle(self,style:'typing.Any') -> 'None':
         """
         Modifies the control bar style settings.

Args:

      style(typing.Any):The new style

Returns:

      None
        
         """
         pass


      def ShowWindow(self,) -> 'typing.Any':
         """
         Shows the toolbar, and recalculates the button layout.

Args:



Returns:

      typing.Any:PyCControlBar.ShowWindow

int = ShowWindow()Shows the toolbar, and recalculates the button layout.
Comments

This method is provided for convenience.  For further details, see 

PyCWnd::ShowWindow and PyCFrameWnd::RecalcLayout
Return ValueThe return value is that returned from PyCWnd::ShowWindow

        
         """
         pass


class PyCCtrlView(object):
      """A class which implementes a CCtrlView (ie, a view based on a dialog resource."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def OnCommand(self,wparam:'typing.Any',lparam:'typing.Any') -> 'None':
         """
         Calls the standard Python framework OnCommand handler

Args:

      wparam(typing.Any):
      lparam(typing.Any):See Also

Returns:

      None
        
         """
         pass


class PyCDC(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AbortDoc(self,) -> 'None':
         """
         Aborts a print job

Args:



Returns:

      None
        
         """
         pass


      def Arc(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',pointStart:'typing.Tuple[typing.Any, typing.Any]',pointEnd:'typing.Tuple[typing.Any, typing.Any]') -> 'None':
         """
         Draws an eliptical arc.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Specifies the ellipse's bounding rectangle
      pointStart(typing.Tuple[typing.Any, typing.Any]):Specifies the x- and y-coordinates of the point that defines the arc's starting point (in logical units). This point does not have to lie exactly on the arc.
      pointEnd(typing.Tuple[typing.Any, typing.Any]):Specifies the x- and y-coordinates of the point that defines the arc's ending point (in logical units). This point does not have to lie exactly on the arc.CommentsThe arc drawn by using the function is a segment of the ellipse defined by the specified bounding rectangle. The actual starting point of the arc is the point at which a ray drawn from the center of the bounding rectangle through the specified starting point intersects the ellipse. The actual ending point of the arc is the point at which a ray drawn from the center of the bounding rectangle through the specified ending point intersects the ellipse. The arc is drawn in a counterclockwise direction. Since an arc is not a closed figure, it is not filled. Both the width and height of the rectangle must be greater than 2 units and less than 32,767 units.MFC References

Returns:

      None:CDC::Arc
Return ValueAlways none.  If the function fails, an exception is raised.

        
         """
         pass


      def BeginPath(self,) -> 'None':
         """
         Opens a path bracket in the device context

Args:



Returns:

      None
        
         """
         pass


      def BitBlt(self,destPos:'typing.Tuple[typing.Any, typing.Any]',size:'typing.Tuple[typing.Any, typing.Any]',dc:'PyCDC',srcPos:'typing.Tuple[typing.Any, typing.Any]',rop:'typing.Any') -> 'None':
         """
         Copies a bitmap from the source device context to this device context.

Args:

      destPos(typing.Tuple[typing.Any, typing.Any]):The logical x,y coordinates of the upper-left corner of the destination rectangle.
      size(typing.Tuple[typing.Any, typing.Any]):Specifies the width and height (in logical units) of the destination rectangle and source bitmap.
      dc(PyCDC):Specifies the PyCDC object from which the bitmap will be copied. It must be None if rop specifies a raster operation that does not include a source.
      srcPos(typing.Tuple[typing.Any, typing.Any]):Specifies the logical x,y coordinates of the upper-left corner of the source bitmap.
      rop(typing.Any):Specifies the raster operation to be performed. See the win32 api documentation for details.MFC References

Returns:

      None
        
         """
         pass


      def Chord(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',pointStart:'typing.Tuple[typing.Any, typing.Any]',pointEnd:'typing.Tuple[typing.Any, typing.Any]') -> 'None':
         """
         Draws a chord.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Specifies the ellipse's bounding rectangle
      pointStart(typing.Tuple[typing.Any, typing.Any]):Specifies the x- and y-coordinates of the point that defines the arc's starting point (in logical units). This point does not have to lie exactly on the arc.
      pointEnd(typing.Tuple[typing.Any, typing.Any]):Specifies the x- and y-coordinates of the point that defines the arc's ending point (in logical units). This point does not have to lie exactly on the arc.CommentsDraws a chord (a closed figure bounded by the intersection of an ellipse and a line segment). The rect parameter specify the upper-left and lower-right corners, respectively, of a rectangle bounding the ellipse that is part of the chord. The pointStart and pointEnd parameters specify the endpoints of a line that intersects the ellipse. The chord is drawn by using the selected pen and filled by using the selected brush.MFC References

Returns:

      None:CDC::Chord
Return ValueAlways none.  If the function fails, an exception is raised.

        
         """
         pass


      def CreateCompatibleDC(self,dcFrom:'PyCDC'=None) -> 'PyCDC':
         """
         Creates a memory device context that is compatible with this DC.

Args:

      dcFrom(PyCDC):The source DC, or None to make a screen compatible DC.CommentsNote that unlike the MFC version, this function calls the global CreateCompatibleDC function and returns a new PyCDC object.MFC References

Returns:

      None
        
         """
         pass


      def CreatePrinterDC(self,printerName:'str'=None) -> 'None':
         """
         Creates a device context for a specific printer

Args:

      printerName(str):The printer name, or None for the default printerMFC References

Returns:

      None
        
         """
         pass


      def DeleteDC(self,) -> 'None':
         """
         Deletes all resources associated with a device context.

Args:



Returns:

      None
        
         """
         pass


      def DPtoLP(self,point:'typing.Tuple[typing.Any, typing.Any]',x:'typing.Any',y:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Converts device units into logical units.

Args:

      point(typing.Tuple[typing.Any, typing.Any]):The point to convertAlternative Parameters
      x(typing.Any):The x coordinate to convert.
      y(typing.Any):The y coordinate to convert.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any]:CDC::DPtoLP
 To Do Should really handle list of (x,y) points
Return ValueThe converted coordinates.

        
         """
         pass


      def Draw3dRect(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',colorTopLeft:'typing.Any',colorBotRight:'typing.Any') -> 'None':
         """
         Draws a three-dimensional rectangle.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Specifies the bounding rectangle, in logical units.
      colorTopLeft(typing.Any):Specifies the color of the top and left sides of the three-dimensional rectangle.
      colorBotRight(typing.Any):Specifies the color of the bottom and right sides of the three-dimensional rectangle.MFC References

Returns:

      None
        
         """
         pass


      def DrawFocusRect(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'None':
         """
         Draws a rectangle in the style used to 

indicate the rectangle has focus

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The coordinates of the rectangleMFC References

Returns:

      None
        
         """
         pass


      def DrawFrameControl(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',typ:'typing.Any',state:'typing.Any') -> 'None':
         """
         Draws a frame control of the specified type and style.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Specifies the bounding rectangle, in logical units.
      typ(typing.Any):
      state(typing.Any):MFC References

Returns:

      None
        
         """
         pass


      def DrawIcon(self,point:'typing.Tuple[typing.Any, typing.Any]',hIcon:'int') -> 'None':
         """
         Draws an icon on the DC.

Args:

      point(typing.Tuple[typing.Any, typing.Any]):The point coordinate to draw to.
      hIcon(int):The handle of the icon to draw.MFC References

Returns:

      None
        
         """
         pass


      def DrawText(self,s:'str',_tuple:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',_format:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Formats text in the given rectangle

Args:

      s(str):The desired output string
      _tuple(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The bounding rectangle in the form: (left, top, right, bottom) expressed in logical units (depending on selected coordinate system - see PyCDC::SetMapMode)
      _format(typing.Any):Specifies one or more bit-or'd format values, such as DT_BOTTOM, DT_CENTERDT_RIGHT, DT_VCENTER. For a complete list, see the Microsoft Win32 API documentation.ExampleExampleimport win32ui&ltnl&gt import win32con&ltnl&gt INCH = 1440   # twips - 1440 per inch allows fine res&ltnl&gt def drawtext_test():&ltnl&gt     dc = win32ui.CreateDC()&ltnl&gt     dc.CreatePrinterDC()                # ties to default printer&ltnl&gt     dc.StartDoc('My Python Document')&ltnl&gt     dc.StartPage()&ltnl&gt &ltnl&gt     # note: upper left is 0,0 with x increasing to the right,&ltnl&gt     #       and y decreasing (negative) moving down&ltnl&gt     dc.SetMapMode(win32con.MM_TWIPS)&ltnl&gt &ltnl&gt     # Centers "TEST" about an inch down on page&ltnl&gt     dc.DrawText('TEST', (0,INCH*-1,INCH*8,INCH*-2), win32con.DT_CENTER )&ltnl&gt     dc.EndPage()&ltnl&gt     dc.EndDoc()&ltnl&gt     del dc&ltnl&gtReturn ValueHeight of text in pixelsThe return value is the height of the text, in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from rect.top to the bottom of the drawn text. If the function fails, the return value is zero (no Python exception is thrown)

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]:Specifies one or more bit-or'd format values, such as 

DT_BOTTOM, DT_CENTERDT_RIGHT, DT_VCENTER. For a complete list, see 

the Microsoft Win32 API documentation.ExampleExample
import win32ui&ltnl&gt

 import win32con&ltnl&gt

 INCH = 1440   # twips - 1440 per inch allows fine res&ltnl&gt

 def drawtext_test():&ltnl&gt

     dc = win32ui.CreateDC()&ltnl&gt

     dc.CreatePrinterDC()                # ties to default printer&ltnl&gt

     dc.StartDoc('My Python Document')&ltnl&gt

     dc.StartPage()&ltnl&gt

 &ltnl&gt

     # note: upper left is 0,0 with x increasing to the right,&ltnl&gt

     #       and y decreasing (negative) moving down&ltnl&gt

     dc.SetMapMode(win32con.MM_TWIPS)&ltnl&gt

 &ltnl&gt

     # Centers "TEST" about an inch down on page&ltnl&gt

     dc.DrawText('TEST', (0,INCH*-1,INCH*8,INCH*-2), win32con.DT_CENTER )&ltnl&gt

     dc.EndPage()&ltnl&gt

     dc.EndDoc()&ltnl&gt

     del dc&ltnl&gt


Return ValueHeight of text in pixels



The return value is the height of the text, in logical units. 

If DT_VCENTER or DT_BOTTOM is specified, the return value is the 

offset from rect.top to the bottom of the drawn text. 

If the function fails, the return value is zero (no Python exception is thrown)

        
         """
         pass


      def Ellipse(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'None':
         """
         Draws an Ellipse.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Specifies the ellipse's bounding rectangleCommentsThe center of the ellipse is the center of the bounding rectangle specified by rect. The ellipse is drawn with the current pen, and its interior is filled with the current brush.MFC References

Returns:

      None:CDC::Ellipse
Return ValueAlways none.  If the function fails, an exception is raised.

        
         """
         pass


      def EndDoc(self,) -> 'None':
         """
         Finishes spooling the document and starts printing it

Args:



Returns:

      None
        
         """
         pass


      def EndPage(self,) -> 'None':
         """
         Finishes a page on a printer DC

Args:



Returns:

      None
        
         """
         pass


      def EndPath(self,) -> 'None':
         """
         Closes a path bracket and selects the path defined by the bracket into the specified device 

context

Args:



Returns:

      None
        
         """
         pass


      def ExtTextOut(self,_int:'typing.Any',_int1:'typing.Any',_int2:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',string:'typing.Any',_tuple:'typing.Tuple[typing.Tuple[typing.Any, typing.Any], ...]') -> 'None':
         """
         Writes text to the DC.

Args:

      _int(typing.Any):The x coordinate to write the text to.
      _int1(typing.Any):The y coordinate to write the text to.
      _int2(typing.Any):Specifies the rectangle type. This parameter can be one, both, or neither of ETO_CLIPPED and ETO_OPAQUE
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Specifies the text's bounding rectangle.  (Can be None.)
      string(typing.Any):The text to write.
      _tuple(typing.Tuple[typing.Tuple[typing.Any, typing.Any], ...]):Optional array of values that indicate distance between origins of character cells.MFC References

Returns:

      None:CDC::ExtTextOut
Return ValueAlways none.  If the function fails, an exception is raised.

        
         """
         pass


      def FillPath(self,) -> 'None':
         """
         Closes any open figures in the current path and fills the path's interior by using the 

current brush and polygon-filling mode. After its interior is filled, the path is discarded from the device context.

Args:



Returns:

      None
        
         """
         pass


      def FillRect(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',brush:'PyCBrush') -> 'None':
         """
         Fills a given rectangle with the specified brush

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Specifies the bounding rectangle, in logical units.
      brush(PyCBrush):Specifies the brush to use.MFC References

Returns:

      None
        
         """
         pass


      def FillSolidRect(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',color:'typing.Any') -> 'None':
         """
         Fills the given rectangle with the specified solid color.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Specifies the bounding rectangle, in logical units.
      color(typing.Any):Specifies the color to use.MFC References

Returns:

      None
        
         """
         pass


      def FrameRect(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',brush:'PyCBrush') -> 'None':
         """
         Draws a border around the rectangle specified by rect

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Specifies the bounding rectangle, in logical units.
      brush(PyCBrush):Specifies the brush to use.MFC References

Returns:

      None
        
         """
         pass


      def GetBrushOrg(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Retrieves the origin (in device units) of the brush currently selected for the 

device context.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def GetClipBox(self,) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Retrieves the dimensions of the smallest bounding rectangle 

around the current clipping boundary.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]:CDC::GetClipBox
Return ValueA tuple of integers specifying the rectangle.

        
         """
         pass


      def GetCurrentPosition(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Retrieves the current position (in logical coordinates).

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def GetDeviceCaps(self,index:'typing.Any') -> 'typing.Any':
         """
         Retrieves a capability of the device context.

Args:

      index(typing.Any):The information requested.  See the win32api documentation for details.MFC References

Returns:

      typing.Any:CDC::GetDeviceCaps
Return ValueThe value of the requested capability

        
         """
         pass


      def GetHandleAttrib(self,) -> 'typing.Any':
         """
         Retrieves the handle of the attribute device context.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetHandleOutput(self,) -> 'typing.Any':
         """
         Retrieves the handle of the output device context.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetMapMode(self,) -> 'typing.Any':
         """
         Gets the mapping mode for the device context.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetNearestColor(self,color:'typing.Any') -> 'typing.Any':
         """
         Returns the closest color a device can map.

Args:

      color(typing.Any):Specifies the color to be matched.

Returns:

      typing.Any
        
         """
         pass


      def GetPixel(self,x:'typing.Any',y:'typing.Any') -> 'None':
         """
         Gets a pixel at a local in a device context

Args:

      x(typing.Any):Horizontal coordinate.
      y(typing.Any):Vertical coordinate.

Returns:

      None
        
         """
         pass


      def GetSafeHdc(self,) -> 'typing.Any':
         """
         Returns the HDC of this DC object.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetTextExtent(self,text:'str') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Calculates the width and height of a line of text using the current font to 

determine the dimensions.

Args:

      text(str):The text to calculate for.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any]:CFC::GetTextExtent
Return ValueA tuple of integers with the size of the string, in logical units.

        
         """
         pass


      def GetTextExtentPoint(self,text:'str') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         None

Args:

      text(str):The text to calculate for.Return ValueA tuple of integers with the size of the string, in logical units.

Returns:

      typing.Tuple[typing.Any, typing.Any]:The text to calculate for.Return ValueA tuple of integers with the size of the string, in logical units.

        
         """
         pass


      def GetTextFace(self,) -> 'str':
         """
         Returns typeface name of the current font.

Args:



Returns:

      str
        
         """
         pass


      def GetTextMetrics(self,) -> 'typing.Any':
         """
         Retrieves the metrics for the current font in this device context.

Args:



Returns:

      typing.Any:CDC::GetTextMetrics
Return ValueA dictionary of integers, keyed by the following strings: 

tmHeight 

tmAscent 

tmDescent 

tmInternalLeading 

tmExternalLeading 

tmAveCharWidth 

tmMaxCharWidth 

tmWeight 

tmItalic 

tmUnderlined 

tmStruckOut 

tmFirstChar 

tmLastChar 

tmDefaultChar 

tmBreakChar 

tmPitchAndFamily 

tmCharSet 

tmOverhang 

tmDigitizedAspectX 

tmDigitizedAspectY

        
         """
         pass


      def GetViewportExt(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Gets the viewport extent of the device context

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def GetViewportOrg(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Gets the viewport origin of the device context

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def GetWindowExt(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Gets the window extent of the device context

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def GetWindowOrg(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Retrieves the x- and y-coordinates of the origin of the window associated with the 

device context.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def IntersectClipRect(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'None':
         """
         Creates a new clipping region by forming the intersection of the current region 

and the rectangle specified

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Specifies the bounding rectangle, in logical units.MFC References

Returns:

      None:CDC::IntersectClipRect
Return Valueregion type as integer

        
         """
         pass


      def IsPrinting(self,) -> 'typing.Any':
         """
         Returns 1 if the DC is currently printing, else 0

Args:



Returns:

      typing.Any
        
         """
         pass


      def LineTo(self,point:'typing.Tuple[typing.Any, typing.Any]',x:'typing.Any',y:'typing.Any') -> 'None':
         """
         Draws a line to a specified point, using the currently selected pen.

Args:

      point(typing.Tuple[typing.Any, typing.Any]):The point coordinate to draw to.Alternative Parameters
      x(typing.Any):The x coordinate to draw to.
      y(typing.Any):The y coordinate to draw to.MFC References

Returns:

      None
        
         """
         pass


      def LPtoDP(self,point:'typing.Tuple[typing.Any, typing.Any]',x:'typing.Any',y:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Converts logical units into device units.

Args:

      point(typing.Tuple[typing.Any, typing.Any]):The point coordinate to convert.Alternative Parameters
      x(typing.Any):The x coordinate to convert.
      y(typing.Any):The y coordinate to convert.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any]:CDC::LPtoDP
Return ValueThe converted coordinates.

        
         """
         pass


      def MoveTo(self,point:'typing.Tuple[typing.Any, typing.Any]',x:'typing.Any',y:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Moves the current position to a specified point.

Args:

      point(typing.Tuple[typing.Any, typing.Any]):The point coordinate to move to.Alternative Parameters
      x(typing.Any):The x coordinate to move to.
      y(typing.Any):The y coordinate to move to.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any]:CDC::MoveTo
Return ValueThe previous position.

        
         """
         pass


      def OffsetWindowOrg(self,arg:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Modifies the coordinates of the window origin relative to the coordinates of the 

current window origin.

Args:

      arg(typing.Tuple[typing.Any, typing.Any]):The new origin offset.Return ValueThe previous origin as a tuple (x,y)

Returns:

      typing.Tuple[typing.Any, typing.Any]:The new origin offset.Return ValueThe previous origin as a tuple (x,y)

        
         """
         pass


      def OffsetViewportOrg(self,arg:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Modifies the coordinates of the viewport origin relative to the coordinates of 

the current viewport origin

Args:

      arg(typing.Tuple[typing.Any, typing.Any]):The new origin offset.Return ValueThe previous viewport origin as a tuple (x,y)

Returns:

      typing.Tuple[typing.Any, typing.Any]:The new origin offset.Return ValueThe previous viewport origin as a tuple (x,y)

        
         """
         pass


      def PatBlt(self,destPos:'typing.Tuple[typing.Any, typing.Any]',size:'typing.Tuple[typing.Any, typing.Any]',rop:'typing.Any') -> 'None':
         """
         Creates a bit pattern on the device.

Args:

      destPos(typing.Tuple[typing.Any, typing.Any]):The logical x,y coordinates of the upper-left corner of the destination rectangle.
      size(typing.Tuple[typing.Any, typing.Any]):Specifies the width and height (in logical units) of the destination rectangle and source bitmap.
      rop(typing.Any):Specifies the raster operation to be performed. See the win32 api documentation for details.MFC References

Returns:

      None
        
         """
         pass


      def Pie(self,x1:'typing.Any',y1:'typing.Any',x2:'typing.Any',y2:'typing.Any',x3:'typing.Any',y3:'typing.Any',x4:'typing.Any',y4:'typing.Any') -> 'None':
         """
         Draws a pie slice in a device context

Args:

      x1(typing.Any):X coordinate of upper left corner
      y1(typing.Any):Y coordinate of upper left corner
      x2(typing.Any):X coordinate of lower right corner
      y2(typing.Any):Y coordinate of lower right corner
      x3(typing.Any):X coordinate of starting point of arc
      y3(typing.Any):Y coordinate of starting point of arc
      x4(typing.Any):X coordinate of ending point of arc
      y4(typing.Any):Y coordinate of ending point of arc

Returns:

      None
        
         """
         pass


      def PolyBezier(self,) -> 'None':
         """
         Draws one or more Bezier splines.

Args:



Returns:

      None
        
         """
         pass


      def Polygon(self,) -> 'None':
         """
         Draws an Polygon.

Args:



Returns:

      None
        
         """
         pass


      def Polyline(self,points:'typing.List[typing.Tuple[typing.Any, typing.Any]]') -> 'None':
         """
         Draws a Polyline.

Args:

      points(typing.List[typing.Tuple[typing.Any, typing.Any]]):A sequence of points

Returns:

      None
        
         """
         pass


      def RealizePalette(self,) -> 'typing.Any':
         """
         Maps palette entries in the current logical palette to the system palette.

Args:



Returns:

      typing.Any:PyCDC.RealizePalette

int = RealizePalette()Maps palette entries in the current logical palette to the system palette.
Return ValueIndicates how many entries in the logical palette were mapped to different entries 

in the system palette. This represents the number of entries that this function 

remapped to accommodate changes in the system palette since the logical palette 

was last realized.

        
         """
         pass


      def Rectangle(self,) -> 'typing.Any':
         """
         Draws a rectangle using the current pen. The interior of the rectangle is filled using 

the current brush.

Args:



Returns:

      typing.Any
        
         """
         pass


      def RectVisible(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'typing.Any':
         """
         Determines whether any part of the given rectangle lies within the clipping region of 

the display context.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The coordinates of the reactangle to be checked.MFC References

Returns:

      typing.Any:CDC::RectVisible
Return ValueNon zero if any part of the rectangle lies within the clipping region, else zero.

        
         """
         pass


      def RestoreDC(self,saved:'typing.Any') -> 'None':
         """
         Restores the state of the device context.

Args:

      saved(typing.Any):The id of a previously saved device context.  See PyCDC::SaveDCMFC References

Returns:

      None
        
         """
         pass


      def SaveDC(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any:CDC::SaveDC
Return ValueAn integer identifying the context, which can be used by PyCDC::RestoreDC. 

An exception is raised if this function fails.

        
         """
         pass


      def ScaleWindowExt(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Modifies the window extents relative to the current values.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def ScaleViewportExt(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Modifies the viewport extents relative to the current values.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def SelectClipRgn(self,) -> 'typing.Any':
         """
         Selects the given region as the current clipping region for the device context

Args:



Returns:

      typing.Any:PyCDC.SelectClipRgn

obRgn = SelectClipRgn()Selects the given region as the current clipping region for the device context
Return ValueThe return value specifies the region's complexity (integer)

        
         """
         pass


      def SelectObject(self,ob:'typing.Any') -> 'typing.Any':
         """
         None

Args:

      ob(typing.Any):The object to select.MFC References

Returns:

      typing.Any:CDC::SelectObject
Return ValueThe previously selected object.  This will be the same type as the object parameter.

        
         """
         pass


      def SetBkColor(self,color:'typing.Any') -> 'typing.Any':
         """
         Sets the current background color to the specified color.

Args:

      color(typing.Any):A windows color specification.  See the win32api documentation for details.CommentsIf the background mode is OPAQUE, the system uses the background color to fill the gaps in styled lines, the gaps between hatched lines in brushes, and the background in character cells. The system also uses the background color when converting bitmaps between color and monochrome device contexts.MFC References

Returns:

      typing.Any:CDC::SetBkColor
Return ValueThe return value is the previous background color.

        
         """
         pass


      def SetBkMode(self,mode:'typing.Any') -> 'typing.Any':
         """
         Sets the current background mode to the specified mode.

Args:

      mode(typing.Any):A background mode.  May be either TRANSPARENT or OPAQUE.CommentsSpecifies the mode to be set.  This parameter can be either OPAQUE or TRANSPARENTMFC References

Returns:

      typing.Any:CDC::SetBkMode
Return ValueThe return value is the previous background mode.

        
         """
         pass


      def SetBrushOrg(self,point:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Specifies the origin that GDI will assign to the next brush that the 

application selects into the device context.

Args:

      point(typing.Tuple[typing.Any, typing.Any]):The new origin in device units.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any]:CDC::SetBrushOrg
Return ValueThe previous origin in device units.

        
         """
         pass


      def SetGraphicsMode(self,mode:'typing.Any') -> 'typing.Any':
         """
         Sets the graphics mode for the specified device context

Args:

      mode(typing.Any):The new mode.

Returns:

      typing.Any
        
         """
         pass


      def SetMapMode(self,newMode:'typing.Any') -> 'typing.Any':
         """
         Sets the mapping mode for the device context.

Args:

      newMode(typing.Any):The new mode.  Can be one of MM_ANISOTROPIC, MM_HIENGLISH, MM_HIMETRIC, MM_ISOTROPIC, MM_LOENGLISH, MM_LOMETRIC, MM_TEXT, MM_TWIPSMFC References

Returns:

      typing.Any:CDC::SetMapMode
Return ValueThe previous mapping mode.

        
         """
         pass


      def SetPixel(self,x:'typing.Any',y:'typing.Any',color:'typing.Any') -> 'None':
         """
         Sets a pixel in a device context

Args:

      x(typing.Any):Horizontal coordinate.
      y(typing.Any):Vertical coordinate.
      color(typing.Any):The brush color.

Returns:

      None
        
         """
         pass


      def SetPolyFillMode(self,point:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Any':
         """
         Sets the polygon-filling mode.

Args:

      point(typing.Tuple[typing.Any, typing.Any]):The new origin in device units.MFC References

Returns:

      typing.Any:CDC::SetPolyFillMode
Return ValueThe previous PolyFillMode as integer



The previous PolyFillMode.

        
         """
         pass


      def SetROP2(self,mode:'typing.Any') -> 'typing.Any':
         """
         Sets the current drawing mode.

Args:

      mode(typing.Any):The new drawing mode.MFC References

Returns:

      typing.Any
        
         """
         pass


      def SetTextAlign(self,newFlags:'typing.Any') -> 'typing.Any':
         """
         Sets the text-alignment flags.

Args:

      newFlags(typing.Any):The new alignment flags.  Can be a combination of (TA_CENTER, TA_LEFT, TA_RIGHT), (TA_BASELINE, TA_BOTTOM, TA_TOP) and (TA_NOUPDATECP, TA_UPDATECP) The default is TA_LEFT|TA_TOP|TA_NOUPDATECPMFC References

Returns:

      typing.Any:CDC::SetTextAlign
Return ValueThe old alignment flags.

        
         """
         pass


      def SetTextColor(self,color:'typing.Any') -> 'typing.Any':
         """
         Sets the text color to the specified color.

Args:

      color(typing.Any):A windows color specification.  See the win32api documentation for details.CommentsThis text color is used when writing text to this device context and also when converting bitmaps between color and monochrome device contexts. If the device cannot represent the specified color, the system sets the text color to the nearest physical color. The background color for a character is specified by the SetBkColor and SetBkMode member functions.MFC References

Returns:

      typing.Any:CDC::SetTextColor
Return ValueThe return value is the previous text color.

        
         """
         pass


      def SetWindowExt(self,size:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Sets the x,y extents of the window associated with the device context.

Args:

      size(typing.Tuple[typing.Any, typing.Any]):The new size.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any]:CDC::SetWindowExt
Return ValueThe previous extents of the window (in logical units).

        
         """
         pass


      def SetWindowOrg(self,arg:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Sets the window origin of the device context

Args:

      arg(typing.Tuple[typing.Any, typing.Any]):The new origin.

Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def SetViewportExt(self,size:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Sets the x,y extents of the viewport of the device context.

Args:

      size(typing.Tuple[typing.Any, typing.Any]):The new size.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any]:CDC::SetViewportExt
Return ValueThe previous extents of the viewport (in logical units).

        
         """
         pass


      def SetViewportOrg(self,arg:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Sets the viewport origin of the device context

Args:

      arg(typing.Tuple[typing.Any, typing.Any]):The new origin.

Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def SetWorldTransform(self,) -> 'typing.Any':
         """
         sets a two-dimensional linear transformation between world space and page space 

for the specified device context. This transformation can be used to scale, rotate, shear, or translate graphics 

output.

Args:



Returns:

      typing.Any
        
         """
         pass


      def StartDoc(self,docName:'str',outputFile:'str') -> 'None':
         """
         Starts spooling a document to a printer DC

Args:

      docName(str):The document name
      outputFile(str):The output file name. Use this to spool to a file. Omit to send to the printer.

Returns:

      None
        
         """
         pass


      def StartPage(self,) -> 'None':
         """
         Starts a new page on a printer DC

Args:



Returns:

      None
        
         """
         pass


      def StretchBlt(self,destPos:'typing.Tuple[typing.Any, typing.Any]',size:'typing.Tuple[typing.Any, typing.Any]',dc:'PyCDC',srcPos:'typing.Tuple[typing.Any, typing.Any]',size1:'typing.Tuple[typing.Any, typing.Any]',rop:'typing.Any') -> 'None':
         """
         Copies a bitmap from the source device context to this device context.

Args:

      destPos(typing.Tuple[typing.Any, typing.Any]):The logical x,y coordinates of the upper-left corner of the destination rectangle.
      size(typing.Tuple[typing.Any, typing.Any]):Specifies the width and height (in logical units) of the destination rectangle and source bitmap.
      dc(PyCDC):Specifies the PyCDC object from which the bitmap will be copied. It must be None if rop specifies a raster operation that does not include a source.
      srcPos(typing.Tuple[typing.Any, typing.Any]):Specifies the logical x,y coordinates of the upper-left corner of the source bitmap.
      size1(typing.Tuple[typing.Any, typing.Any]):Specifies the width and height (in logical units) of the destination rectangle and source bitmap.
      rop(typing.Any):Specifies the raster operation to be performed. See the win32 api documentation for details.MFC References

Returns:

      None
        
         """
         pass


      def StrokeAndFillPath(self,) -> 'None':
         """
         Closes any open figures in a path, strokes the outline of the path by using the 

current pen, and fills its interior by using the current brush. The device context must contain a closed path.

Args:



Returns:

      None
        
         """
         pass


      def StrokePath(self,) -> 'None':
         """
         Renders the specified path by using the current pen.

Args:



Returns:

      None
        
         """
         pass


      def TextOut(self,_int:'typing.Any',_int1:'typing.Any',string:'typing.Any') -> 'None':
         """
         Outputs text to the display context, using the currently selected font.

Args:

      _int(typing.Any):The x coordinate to write the text to.
      _int1(typing.Any):The y coordinate to write the text to.
      string(typing.Any):The text to write.MFC References

Returns:

      None:CDC::TextOut
Return ValueAlways none.  If the function fails, an exception is raised.

        
         """
         pass


class PyCDialog(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateWindow(self,obParent:'PyCWnd'=None) -> 'None':
         """
         Create a modeless window for the dialog box.

Args:

      obParent(PyCWnd):The parent window for the new windowMFC References

Returns:

      None
        
         """
         pass


      def DoModal(self,) -> 'typing.Any':
         """
         Create a modal window for the dialog box.

Args:



Returns:

      typing.Any:CDialog::DoModal
Return ValueThe return value from the dialog.  This is the value passed to PyCDialog::EndDialog.

        
         """
         pass


      def EndDialog(self,result:'typing.Any') -> 'None':
         """
         Ends a modal dialog box.

Args:

      result(typing.Any):The value to be returned by the PyCDialog::DoModal method.MFC References

Returns:

      None
        
         """
         pass


      def GotoDlgCtrl(self,control:'PyCWnd') -> 'None':
         """
         Moves the focus to the specified control in the dialog box.

Args:

      control(PyCWnd):The control to get the focus.

Returns:

      None
        
         """
         pass


      def MapDialogRect(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Converts the dialog-box units of a rectangle to screen 

units.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The rect to be converted

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def OnCancel(self,) -> 'None':
         """
         Calls the default MFC OnCancel handler.

Args:



Returns:

      None
        
         """
         pass


      def OnOK(self,) -> 'None':
         """
         Calls the default MFC OnOK handler.

Args:



Returns:

      None
        
         """
         pass


      def OnInitDialog(self,) -> 'typing.Any':
         """
         Calls the default MFC OnInitDialog handler.

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCDialogBar(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateWindow(self,parent:'PyCWnd',template:'PyResourceId',style:'typing.Any',_id:'typing.Any') -> 'None':
         """
         None

Args:

      parent(PyCWnd):The parent window
      template(PyResourceId):Template name or integer resource id
      style(typing.Any):The style for the window
      _id(typing.Any):The ID of the window

Returns:

      None
        
         """
         pass


class PyCDocTemplate(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def DoCreateDoc(self,fileName:'str'=None) -> 'PyCDocument':
         """
         Creates an underlying document object.

Args:

      fileName(str):The name of the file to load.

Returns:

      PyCDocument
        
         """
         pass


      def FindOpenDocument(self,fileName:'str') -> 'PyCDocument':
         """
         Returns an existing document with the specified file name.

Args:

      fileName(str):The fully qualified filename to search for.

Returns:

      PyCDocument
        
         """
         pass


      def GetDocString(self,docIndex:'typing.Any') -> 'str':
         """
         Retrieves a specific substring describing the document type.

Args:

      docIndex(typing.Any):The document index.  Must be one of the win32ui.CDocTemplate_* constants.CommentsFor more information on the doc strings, please see PyCDocTemplate::SetDocStrings

Returns:

      str
        
         """
         pass


      def GetDocumentList(self,) -> 'typing.Any':
         """
         Return a list of all open documents.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetResourceID(self,) -> 'None':
         """
         Returns the resource ID in use.

Args:



Returns:

      None
        
         """
         pass


      def GetSharedMenu(self,) -> 'PyCMenu':
         """
         Returns the shared menu object for all frames using this template.

Args:



Returns:

      PyCMenu
        
         """
         pass


      def InitialUpdateFrame(self,frame:'PyCFrameWnd'=None,doc:'PyCDocument'=None,bMakeVisible:'typing.Any'=1) -> 'None':
         """
         Calls the default OnInitialFrame handler.

Args:

      frame(PyCFrameWnd):The frame window.
      doc(PyCDocument):A document for the frame.
      bMakeVisible(typing.Any):Indicates of the frame should be shown.See Also

Returns:

      None
        
         """
         pass


      def SetContainerInfo(self,_id:'typing.Any') -> 'None':
         """
         Sets the resources to be used when an OLE 2 object is in-place activated.

Args:

      _id(typing.Any):The resource ID.

Returns:

      None
        
         """
         pass


      def SetDocStrings(self,docStrings:'str') -> 'None':
         """
         Assigns the document strings for the template.

Args:

      docStrings(str):The document strings.CommentsThe string must be a \\n seperated list of docstrings. The elements are:elementNameDescriptionwindowTitleTitle used for the window (only for SDI applications)docNameRoot for the default document name.fileNewNameName of the document type, as displayed in the "File/New" dialogfilterNameDescription of the document type and a wildcard spec for the file open dialog.filterExtExtension for documents of this file type.regFileTypeIdInternal Id of the document as registered in the registry.  Used to associate the extension with the file type.regFileTypeNameName of the document, as stored in the reigstry.  This is the name presented to the user.

Returns:

      None
        
         """
         pass


      def OpenDocumentFile(self,filename:'str',bMakeVisible:'typing.Any'=1) -> 'None':
         """
         Opens a document file, creating a view and frame.

Args:

      filename(str):Name of file to open, or None
      bMakeVisible(typing.Any):Indicates if the document should be created visible.

Returns:

      None
        
         """
         pass


class PyCDockContext(object):
      """A class which encapsulates an MFC CDockContext object"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ptLast(self)->'typing.Tuple[typing.Any, typing.Any]':
         """"""
         pass


      @property
      def rectLast(self)->'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """"""
         pass


      @property
      def sizeLast(self)->'typing.Tuple[typing.Any, typing.Any]':
         """"""
         pass


      @property
      def bDitherLast(self)->'typing.Any':
         """"""
         pass


      @property
      def rectDragHorz(self)->'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """"""
         pass


      @property
      def rectDragVert(self)->'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """"""
         pass


      @property
      def rectFrameDragHorz(self)->'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """"""
         pass


      @property
      def rectFrameDragVert(self)->'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """"""
         pass


      @property
      def dwDockStyle(self)->'typing.Any':
         """allowable dock styles for bar"""
         pass


      @property
      def dwOverDockStyle(self)->'typing.Any':
         """style of dock that rect is over"""
         pass


      @property
      def dwStyle(self)->'typing.Any':
         """style of control bar"""
         pass


      @property
      def bFlip(self)->'typing.Any':
         """if shift key is down"""
         pass


      @property
      def bForceFrame(self)->'typing.Any':
         """if ctrl key is down CDC* m_pDC;                 // where to draw during drag"""
         pass


      @property
      def bDragging(self)->'typing.Any':
         """"""
         pass


      @property
      def nHitTest(self)->'typing.Any':
         """"""
         pass


      @property
      def uMRUDockID(self)->'typing.Any':
         """"""
         pass


      @property
      def rectMRUDockPos(self)->'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """"""
         pass


      @property
      def dwMRUFloatStyle(self)->'typing.Any':
         """"""
         pass


      @property
      def ptMRUFloatPos(self)->'typing.Tuple[typing.Any, typing.Any]':
         """Sentinel"""
         pass


      def EndDrag(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def StartDrag(self,pt:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Any':
         """
         None

Args:

      pt(typing.Tuple[typing.Any, typing.Any]):

Returns:

      typing.Any
        
         """
         pass


      def EndResize(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def StartResize(self,hittest:'typing.Any',pt:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Any':
         """
         None

Args:

      hittest(typing.Any):
      pt(typing.Tuple[typing.Any, typing.Any]):

Returns:

      typing.Any
        
         """
         pass


      def ToggleDocking(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCDocument(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def DeleteContents(self,) -> 'None':
         """
         Call the MFC DeleteContents method. 

This routine is provided so a document object which overrides this method 

can call the original MFC version if required.

Args:



Returns:

      None
        
         """
         pass


      def DoSave(self,fileName:'str',bReplace:'typing.Any'=1) -> 'None':
         """
         Calls the underlying MFC DoSave method.

Args:

      fileName(str):The name of the file to save to.
      bReplace(typing.Any):Should an existing file be silently replaced?.CommentsIf invalid or no filename, will prompt for a name, else will perform the actual saving of the document.See Also

Returns:

      None
        
         """
         pass


      def DoFileSave(self,) -> 'None':
         """
         Checks the file attributes. 

If the file is read only, a new name is prompted, else the 

file is saved (by calling DoSave)

Args:



Returns:

      None
        
         """
         pass


      def GetDocTemplate(self,) -> 'PyCDocTemplate':
         """
         Returns the template for the document.

Args:



Returns:

      PyCDocTemplate
        
         """
         pass


      def GetAllViews(self,) -> 'typing.List[typing.Any]':
         """
         Returns a list of all views for the current document.

Args:



Returns:

      typing.List[typing.Any]
        
         """
         pass


      def GetFirstView(self,) -> 'PyCView':
         """
         Returns the first view object attached to this document.

Args:



Returns:

      PyCView
        
         """
         pass


      def GetPathName(self,) -> 'str':
         """
         Returns the full path name of the current document. 

The string will be empty if no path name has been set.

Args:



Returns:

      str
        
         """
         pass


      def GetTitle(self,) -> 'str':
         """
         Returns the title of the current document. 

This will often be the file name portion of the path name.

Args:



Returns:

      str
        
         """
         pass


      def IsModified(self,) -> 'typing.Any':
         """
         Return a flag indicating if the document has been modified.

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnChangedViewList(self,) -> 'None':
         """
         Informs the document when a view is added or removed.

Args:



Returns:

      None
        
         """
         pass


      def OnCloseDocument(self,) -> 'None':
         """
         Call the MFC OnCloseDocument handler. 

This routine is provided so a document object which overrides this method 

can call the original MFC version if required.

Args:



Returns:

      None
        
         """
         pass


      def OnNewDocument(self,) -> 'None':
         """
         Call the MFC OnNewDocument handler. 

This routine is provided so a document object which overrides this method 

can call the original MFC version if required.

Args:



Returns:

      None
        
         """
         pass


      def OnOpenDocument(self,pathName:'str') -> 'None':
         """
         Call the MFC OnOpenDocument handler. 

This routine is provided so a document object which overrides this method 

can call the original MFC version if required.

Args:

      pathName(str):The full path of the file to open.MFC References

Returns:

      None
        
         """
         pass


      def OnSaveDocument(self,pathName:'str') -> 'None':
         """
         Call the MFC OnSaveDocument handler. 

This routine is provided so a document object which overrides this method 

can call the original MFC version if required.

Args:

      pathName(str):The full path of the file to save.MFC References

Returns:

      None
        
         """
         pass


      def SetModifiedFlag(self,bModified:'typing.Any'=1) -> 'None':
         """
         Set the "dirty" flag for the document.

Args:

      bModified(typing.Any):Set dirty flagMFC References

Returns:

      None
        
         """
         pass


      def SaveModified(self,) -> 'typing.Any':
         """
         Call the underlying MFC method.

Args:



Returns:

      typing.Any:CDocument::SaveModified
Return ValueNonzero if it is safe to continue and close the document; 0 if the document should not be closed.

        
         """
         pass


      def SetPathName(self,path:'str') -> 'None':
         """
         Set the full path name for the document.

Args:

      path(str):The full path of the file.MFC References

Returns:

      None
        
         """
         pass


      def SetTitle(self,title:'str') -> 'None':
         """
         Set the title of the document (ie, the name 

to appear in the window caption for the document.

Args:

      title(str):The new title.MFC References

Returns:

      None
        
         """
         pass


      def UpdateAllViews(self,sender:'PyCView',hint:'typing.Any'=None) -> 'None':
         """
         Informs each view when a document changes.

Args:

      sender(PyCView):The view who initiated the update
      hint(typing.Any):A hint for the update.MFC References

Returns:

      None
        
         """
         pass


class PyCEdit(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateWindow(self,style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',parent:'PyCWnd',_id:'typing.Any') -> 'None':
         """
         Creates the window for a new Edit object.

Args:

      style(typing.Any):The style for the Edit.  Use any of the win32con.BS_* constants.
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The size and position of the Edit.
      parent(PyCWnd):The parent window of the Edit.  Usually a PyCDialog.
      _id(typing.Any):The Edits control ID.

Returns:

      None
        
         """
         pass


      def Clear(self,) -> 'typing.Any':
         """
         Clears all text in an edit control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def Copy(self,) -> 'None':
         """
         Copys the current selection to the clipboard.

Args:



Returns:

      None
        
         """
         pass


      def Cut(self,) -> 'None':
         """
         Cuts the current selection to the clipboard.

Args:



Returns:

      None
        
         """
         pass


      def FmtLines(self,bAddEOL:'typing.Any') -> 'typing.Any':
         """
         Sets the formatting options for the control.

Args:

      bAddEOL(typing.Any):Specifies whether soft line-break characters are to be inserted. A value of TRUE inserts the characters; a value of FALSE removes them.MFC References

Returns:

      typing.Any:CEdit::FmtLines
Return ValueNonzero if any formatting occurs; otherwise 0.

        
         """
         pass


      def GetFirstVisibleLine(self,) -> 'typing.Any':
         """
         Returns zero-based index of the topmost visible line.

Args:



Returns:

      typing.Any:CEdit::GetFirstVisibleLine
Return ValueThe zero-based index of the topmost visible line. For single-line edit controls, the return value is 0.

        
         """
         pass


      def GetSel(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Returns the start and end of the current selection.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]:CEdit::GetSel
Return ValueThe return tuple is (the first character in the current selection, first nonselected character past the 

end of the current selection)

        
         """
         pass


      def GetLine(self,lineNo:'typing.Any') -> 'typing.Any':
         """
         Returns the text in a specified line.

Args:

      lineNo(typing.Any):Contains the zero-based index value for the desired line.CommentsThis function is not an MFC wrapper.

Returns:

      typing.Any
        
         """
         pass


      def GetLineCount(self,) -> 'typing.Any':
         """
         Gets the number of lines in an edit control.

Args:



Returns:

      typing.Any:CEdit::GetLineCount
Return ValueThe number of lines in the buffer.  If the control is empty, the return value is 1.

        
         """
         pass


      def LimitText(self,nChars:'typing.Any'=0) -> 'None':
         """
         Sets max length of text that user can enter

Args:

      nChars(typing.Any):Specifies the length (in bytes) of the text that the user can enter. If this parameter is 0, the text length is set to UINT_MAX bytes. This is the default behavior.MFC References

Returns:

      None
        
         """
         pass


      def LineFromChar(self,charNo:'typing.Any'=-1) -> 'typing.Any':
         """
         Returns the line number of the specified character.

Args:

      charNo(typing.Any):Contains the zero-based index value for the desired character in the text of the edit control, or -1.  If -1, then it specifies the current line.MFC References

Returns:

      typing.Any:CEdit::LineFromChar
Return ValueThe zero-based line number of the line containing the character index specified by charNo. 

If charNo is -1, the number of the line that contains the first character of the selection is returned. 

If there is no selection, the current line number is returned.

        
         """
         pass


      def LineIndex(self,lineNo:'typing.Any'=-1) -> 'typing.Any':
         """
         Retrieves the character index of a line within a multiple-line edit control.

Args:

      lineNo(typing.Any):Contains the index value for the desired line in the text of the edit control, or contains -1.  If -1, then it specifies the current line.CommentsThis method only works on multi-linr edit controls.MFC References

Returns:

      typing.Any:CEdit::LineIndex
Return ValueThe character index of the line specified in lineNo, or -1 if 

the specified line number is greater then the number of lines in 

the edit control.

        
         """
         pass


      def LineScroll(self,nLines:'typing.Any',nChars:'typing.Any'=0) -> 'typing.Any':
         """
         Scroll the control vertically and horizontally

Args:

      nLines(typing.Any):Specifies the number of lines to scroll vertically.
      nChars(typing.Any):Specifies the number of character positions to scroll horizontally. This value is ignored if the edit control has either the ES_RIGHT or ES_CENTER style.CommentsThis method only works on multi-linr edit controls.MFC References

Returns:

      typing.Any
        
         """
         pass


      def Paste(self,) -> 'None':
         """
         Pastes the contents of the clipboard into the control.

Args:



Returns:

      None
        
         """
         pass


      def ReplaceSel(self,text:'str') -> 'None':
         """
         Replaces the selection with the specified text.

Args:

      text(str):The text to replace the selection with.MFC References

Returns:

      None
        
         """
         pass


      def SetReadOnly(self,bReadOnly:'typing.Any'=1) -> 'None':
         """
         Sets or clears the read-only status of the listbox.

Args:

      bReadOnly(typing.Any):The read-only state to set.MFC References

Returns:

      None
        
         """
         pass


      def SetSel(self,start:'typing.Any',end:'typing.Any',arg:'typing.Any',bNoScroll1:'typing.Any',bNoScroll:'typing.Any'=0) -> 'None':
         """
         Sets the selection in the edit control.

Args:

      start(typing.Any):Specifies the starting position. If start is 0 and end is -1, all the text in the edit control is selected. If start is -1, any current selection is removed.
      end(typing.Any):Specifies the ending position.
      arg(typing.Any):As for normal start, end args.
      bNoScroll1(typing.Any):Indicates whether the caret should be scrolled into view. If 0, the caret is scrolled into view. If 1, the caret is not scrolled into view.MFC References
      bNoScroll(typing.Any):Indicates whether the caret should be scrolled into view. If 0, the caret is scrolled into view. If 1, the caret is not scrolled into view.Alternative Parameters

Returns:

      None
        
         """
         pass


class PyCEditView(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def IsModified(self,) -> 'typing.Any':
         """
         Indicates if the view's document has the modified flag set.

Args:



Returns:

      typing.Any
        
         """
         pass


      def LoadFile(self,fileName:'str') -> 'None':
         """
         Loads a file into the view.

Args:

      fileName(str):The name of the file to be loaded.

Returns:

      None
        
         """
         pass


      def SetModifiedFlag(self,bModified:'typing.Any'=1) -> 'None':
         """
         Sets the modified flag for the view's document.

Args:

      bModified(typing.Any):The modified state to set.

Returns:

      None
        
         """
         pass


      def GetEditCtrl(self,) -> 'typing.Any':
         """
         returns the underlying edit control object.

Args:



Returns:

      typing.Any
        
         """
         pass


      def PreCreateWindow(self,createStruct:'typing.Any') -> 'typing.Any':
         """
         Calls the underlying MFC PreCreateWindow method.

Args:

      createStruct(typing.Any):A tuple representing a CREATESTRUCT structure.

Returns:

      typing.Any
        
         """
         pass


      def SaveFile(self,fileName:'str') -> 'None':
         """
         Saves the view to a file.

Args:

      fileName(str):The name of the file to be written.

Returns:

      None
        
         """
         pass


      def OnCommand(self,wparam:'typing.Any',lparam:'typing.Any') -> 'None':
         """
         Calls the standard Python framework OnCommand handler

Args:

      wparam(typing.Any):
      lparam(typing.Any):See Also

Returns:

      None
        
         """
         pass


class PyCFileDialog(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPathName(self,) -> 'str':
         """
         Retrives the path name from the file dialog.

Args:



Returns:

      str
        
         """
         pass


      def GetFileName(self,) -> 'str':
         """
         Retrives the file name from the file dialog.

Args:



Returns:

      str
        
         """
         pass


      def GetFileExt(self,) -> 'str':
         """
         Retrives the file extension from the file dialog.

Args:



Returns:

      str
        
         """
         pass


      def GetFileTitle(self,) -> 'str':
         """
         Retrives the file title from the file dialog.

Args:



Returns:

      str
        
         """
         pass


      def GetPathNames(self,) -> 'str':
         """
         Retrieves the list of path names from the file dialog.

Args:



Returns:

      str
        
         """
         pass


      def GetReadOnlyPref(self,) -> 'typing.Any':
         """
         Retrives the value of the "Read Only" checkbox on the file dialog.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetOFNTitle(self,title:'str') -> 'None':
         """
         Sets the Title for the dialog.

Args:

      title(str):The title for the dialog box.  May be None.

Returns:

      None
        
         """
         pass


      def SetOFNInitialDir(self,title:'str') -> 'None':
         """
         Sets the initial directory for the dialog.

Args:

      title(str):The initial directory for the dialog box.  May be None.

Returns:

      None
        
         """
         pass


class PyCFont(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetSafeHandle(self,) -> 'typing.Any':
         """
         Retrieves the HFONT for the font as an integer

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCFontDialog(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def DoModal(self,) -> 'typing.Any':
         """
         Displays a dialog and allows the user to make a selection.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetCurrentFont(self,) -> 'typing.Any':
         """
         Returns a dictionary describing the current font.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetCharFormat(self,) -> 'typing.Any':
         """
         Returns the font selection in a CHARFORMAT tuple.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetColor(self,) -> 'typing.Any':
         """
         Determines the color of the selected font.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetFaceName(self,) -> 'str':
         """
         Returns the face name of the selected font.

Args:



Returns:

      str
        
         """
         pass


      def GetStyleName(self,) -> 'str':
         """
         Returns the style name of the selected font.

Args:



Returns:

      str
        
         """
         pass


      def GetSize(self,) -> 'typing.Any':
         """
         Returns he font's size, in tenths of a point.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetWeight(self,) -> 'typing.Any':
         """
         Returns the font's weight.

Args:



Returns:

      typing.Any
        
         """
         pass


      def IsStrikeOut(self,) -> 'typing.Any':
         """
         Determines whether the font is displayed with strikeout.

Args:



Returns:

      typing.Any
        
         """
         pass


      def IsUnderline(self,) -> 'typing.Any':
         """
         Determines whether the font is displayed with underline.

Args:



Returns:

      typing.Any
        
         """
         pass


      def IsBold(self,) -> 'typing.Any':
         """
         Determines whether the font is displayed bold.

Args:



Returns:

      typing.Any
        
         """
         pass


      def IsItalic(self,) -> 'typing.Any':
         """
         Determines whether the font is displayed with italic.

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCFormView(object):
      """A class which implementes a CFormView (ie, a view based on a dialog resource."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def OnCommand(self,wparam:'typing.Any',lparam:'typing.Any') -> 'None':
         """
         Calls the standard Python framework OnCommand handler

Args:

      wparam(typing.Any):
      lparam(typing.Any):See Also

Returns:

      None
        
         """
         pass


class PyCFrameWnd(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def BeginModalState(self,) -> 'None':
         """
         Sets the frame window to modal.

Args:



Returns:

      None
        
         """
         pass


      def CreateWindow(self,wndClass:'str',title:'str',style:'typing.Any',PyCWnd:'typing.Any',menuId:'typing.Any',styleEx:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]'=None,createContext:'typing.Any'=None) -> 'typing.Any':
         """
         Creates the actual window for the PyCFrameWnd object.

Args:

      wndClass(str):The window class name, or None
      title(str):The window title
      style(typing.Any):The window style
      PyCWnd(typing.Any):The parent window
      menuId(typing.Any):The string or integer id for the menu.
      styleEx(typing.Any):The extended style of the window being created.MFC References
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The default rectangle
      createContext(typing.Any):A tuple representing a CREATECONTEXT structure.

Returns:

      typing.Any
        
         """
         pass


      def EndModalState(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def DockControlBar(self,controlBar:'PyCControlBar',arg:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',dockBarId:'typing.Any'=0) -> 'None':
         """
         Docks a control bar.

Args:

      controlBar(PyCControlBar):The control bar to dock.
      arg(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Determines, in screen coordinates, where the control bar will be docked in the nonclient area of the destination frame window.MFC References
      dockBarId(typing.Any):Determines which sides of the frame window to consider for docking.

Returns:

      None
        
         """
         pass


      def EnableDocking(self,style:'typing.Any') -> 'None':
         """
         Enable dockable control bars in a frame window

Args:

      style(typing.Any):Specifies which sides of the frame window can serve as docking sites for control bars.CommentsBy default, control bars will be docked to a side of the frame window in the following order: top, bottom, left, right.

Returns:

      None
        
         """
         pass


      def FloatControlBar(self,controlBar:'PyCControlBar',arg:'typing.Tuple[typing.Any, typing.Any]',style:'typing.Any') -> 'None':
         """
         Floats a control bar.

Args:

      controlBar(PyCControlBar):The control bar to dock.
      arg(typing.Tuple[typing.Any, typing.Any]):The location, in screen coordinates, where the top left corner of the control bar will be placed.
      style(typing.Any):Determines which sides of the frame window to consider for docking.MFC References

Returns:

      None
        
         """
         pass


      def GetActiveDocument(self,) -> 'PyCDocument':
         """
         Gets the currently active document, else None

Args:



Returns:

      PyCDocument
        
         """
         pass


      def GetControlBar(self,_id:'typing.Any') -> 'PyCControlBar':
         """
         Retrieves the specified control bar.

Args:

      _id(typing.Any):The ID of the toolbar to be retrieved

Returns:

      PyCControlBar
        
         """
         pass


      def GetMessageString(self,_id:'typing.Any') -> 'str':
         """
         Retrieves message corresponding to a command ID.

Args:

      _id(typing.Any):The ID to be retrievedSee Also

Returns:

      str
        
         """
         pass


      def GetMessageBar(self,) -> 'PyCWnd':
         """
         Retrieves the message bar for the frame.

Args:



Returns:

      PyCWnd
        
         """
         pass


      def IsTracking(self,) -> 'typing.Any':
         """
         Determines if splitter bar is currently being moved.

Args:



Returns:

      typing.Any
        
         """
         pass


      def InModalState(self,) -> 'typing.Any':
         """
         Returns a value indicating whether or not a frame window is in a modal state.

Args:



Returns:

      typing.Any
        
         """
         pass


      def LoadAccelTable(self,_id:'PyResourceId') -> 'None':
         """
         Loads an accelerator table.

Args:

      _id(PyResourceId):Name or id of the resource that contains the table

Returns:

      None
        
         """
         pass


      def LoadFrame(self,idResource:'typing.Any',style:'typing.Any'=-1,wndParent:'PyCWnd'=None,context:'typing.Any'=None) -> 'None':
         """
         Loads a Windows frame window and associated resources

Args:

      idResource(typing.Any):The Id of the resources (menu, icon, etc) for this window
      style(typing.Any):The window style.  Note -1 implies win32con.WS_OVERLAPPEDWINDOW|win32con.FWS_ADDTOTITLE
      wndParent(PyCWnd):The parent of the window, or None.
      context(typing.Any):An object passed to the OnCreateClient for the frame,MFC References

Returns:

      None
        
         """
         pass


      def LoadBarState(self,profileName:'str') -> 'None':
         """
         Loads a control bars settings

Args:

      profileName(str):Name of a section in the initialization file or a key in the Windows registry where state information is stored.MFC References

Returns:

      None
        
         """
         pass


      def PreCreateWindow(self,createStruct:'typing.Any') -> 'typing.Any':
         """
         Calls the underlying MFC PreCreateWindow method.

Args:

      createStruct(typing.Any):A tuple representing a CREATESTRUCT structure.See Also

Returns:

      typing.Any
        
         """
         pass


      def SaveBarState(self,profileName:'str') -> 'None':
         """
         Saves a control bars settings

Args:

      profileName(str):Name of a section in the initialization file or a key in the Windows registry where state information is stored.MFC References

Returns:

      None
        
         """
         pass


      def ShowControlBar(self,controlBar:'PyCControlBar',bShow:'typing.Any',bDelay:'typing.Any') -> 'None':
         """
         Shows a control bar.

Args:

      controlBar(PyCControlBar):The control bar to dock.
      bShow(typing.Any):Show or hide flag.
      bDelay(typing.Any):If TRUE, delay showing the control bar. If FALSE, show the control bar immediately.MFC References

Returns:

      None
        
         """
         pass


      def RecalcLayout(self,bNotify:'typing.Any'=1) -> 'None':
         """
         Called by the framework when the standard control bars are toggled on or off or 

when the frame window is resized.

Args:

      bNotify(typing.Any):Notify flagMFC References

Returns:

      None
        
         """
         pass


      def GetActiveView(self,) -> 'PyCView':
         """
         Retrieves the active view.

Args:



Returns:

      PyCView
        
         """
         pass


      def OnBarCheck(self,_id:'typing.Any') -> 'typing.Any':
         """
         Changes the state of the specified controlbar.

Args:

      _id(typing.Any):The control ID of the control bar.

Returns:

      typing.Any
        
         """
         pass


      def OnUpdateControlBarMenu(self,cmdUI:'PyCCmdUI') -> 'typing.Any':
         """
         Checks the state of a menu item

Args:

      cmdUI(PyCCmdUI):A cmdui object

Returns:

      typing.Any
        
         """
         pass


      def SetActiveView(self,view:'PyCView',bNotify:'typing.Any'=1) -> 'None':
         """
         Sets the active view for a frame.

Args:

      view(PyCView):The view to set active.
      bNotify(typing.Any):Specifies whether the view is to be notified of activation. If TRUE, OnActivateView is called for the new view; if FALSE, it is not.

Returns:

      None
        
         """
         pass


class PyCGdiObject(object):
      """A class which encapsulates an MFC CGdiObject."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCImageList(object):
      """A Python type encapsulating an MFC CImageList class."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Add(self,arg:'typing.Tuple[typing.Any, typing.Any]',bitmap:'typing.Any',color:'typing.Any',hIcon:'typing.Any') -> 'typing.Any':
         """
         Adds an image to the list.

Args:

      arg(typing.Tuple[typing.Any, typing.Any]):2 Bitmaps to use (primary and mask)Alternative Parameters
      bitmap(typing.Any):Bitmap to use
      color(typing.Any):Color to use for the mask.Alternative Parameters
      hIcon(typing.Any):Handle of an icon to add.Return ValueZero-based index of the first new image.

Returns:

      typing.Any:Handle of an icon to add.
Return ValueZero-based index of the first new image.

        
         """
         pass


      def Destroy(self,) -> 'None':
         """
         Destroys the underlying CImageList

Args:



Returns:

      None
        
         """
         pass


      def DeleteImageList(self,) -> 'None':
         """
         Deletes an image list.

Args:



Returns:

      None
        
         """
         pass


      def GetBkColor(self,) -> 'typing.Any':
         """
         Retrieves the background color of an Image List.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSafeHandle(self,) -> 'typing.Any':
         """
         Retrieves the HIMAGELIST for the object

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetImageCount(self,) -> 'typing.Any':
         """
         Retrieves the number of images in an image list.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetImageInfo(self,index:'typing.Any') -> 'typing.Any':
         """
         Retrieves information about an image.

Args:

      index(typing.Any):Index of image.Return ValueThe return info is a tuple describing an IMAGELIST structure.

Returns:

      typing.Any:Index of image.Return ValueThe return info is a tuple describing an IMAGELIST structure.

        
         """
         pass


      def SetBkColor(self,color:'typing.Any') -> 'None':
         """
         Sets the background color for an Image List.

Args:

      color(typing.Any):The new background color.

Returns:

      None
        
         """
         pass


class PyCListBox(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddString(self,_object:'typing.Any') -> 'typing.Any':
         """
         Adds a string to a listbox.

Args:

      _object(typing.Any):Any object.  If not a string, __str__, __repr__ or a default repr() will be usedMFC References

Returns:

      typing.Any:CListBox::AddString
Return ValueThe zero based index of the new string.

        
         """
         pass


      def DeleteString(self,pos:'typing.Any') -> 'typing.Any':
         """
         Deletes an item from a listbox.

Args:

      pos(typing.Any):The zero based index of the item to delete.MFC References

Returns:

      typing.Any:CListBox::DeleteString
Return ValueThe count of the items remaining in the list.

        
         """
         pass


      def Dir(self,attr:'typing.Any',wild:'str') -> 'typing.Any':
         """
         Fills a listbox with a directory listing.

Args:

      attr(typing.Any):The attributes of the files to locate
      wild(str):A file specification string - eg, *.*MFC References

Returns:

      typing.Any:CListBox::Dir
Return ValueThe index of the last file name added to the list.

        
         """
         pass


      def GetCaretIndex(self,) -> 'typing.Any':
         """
         Returns the index of the item which has focus.

Args:



Returns:

      typing.Any:PyCListBox.GetCaretIndex

int = GetCaretIndex()Returns the index of the item which has focus.
Return ValueThe zero-based index of the item that has the focus rectangle in a list box. 

If the list box is a single-selection list box, the return value is the index of the item that is selected, if 

any.

        
         """
         pass


      def GetCount(self,) -> 'typing.Any':
         """
         Returns the count of items in the listbox.

Args:



Returns:

      typing.Any:CListBox::GetCount
Return ValueReturns the number of items currently in the listbox.

        
         """
         pass


      def GetCurSel(self,) -> 'typing.Any':
         """
         Returns the index of the currently selected item.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetItemData(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the application-specific object associated with an item.

Args:

      item(typing.Any):The index of the item whose data is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def GetItemValue(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the application-specific value associated with an item.

Args:

      item(typing.Any):The index of the item whose data is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def GetSel(self,index:'typing.Any') -> 'typing.Any':
         """
         Returns the selection state of a specified item.

Args:

      index(typing.Any):The index of the item to return the state for.MFC References

Returns:

      typing.Any:CListBox::GetSel
Return ValueA +ve number if the item is selected, else zero.

        
         """
         pass


      def GetSelCount(self,) -> 'typing.Any':
         """
         Returns the number of selected items in a multiple selection listbox.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSelItems(self,) -> 'typing.Any':
         """
         Returns a list of the indexes of the currently selected items in a multiple 

selection listbox.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSelTextItems(self,) -> 'typing.Any':
         """
         Returns a list of the strings of the currently selected items in a multiple 

selection listbox.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetTopIndex(self,) -> 'typing.Any':
         """
         Returns the index of the top most visible item.

Args:



Returns:

      typing.Any:CListBox::GetTopIndex
Return ValueThe zero based index of the top most visible item.

        
         """
         pass


      def GetText(self,index:'typing.Any') -> 'str':
         """
         Returns the string for a specified item.

Args:

      index(typing.Any):The index of the item to retrieve the text of

Returns:

      str
        
         """
         pass


      def GetTextLen(self,index:'typing.Any') -> 'typing.Any':
         """
         Returns the length of the string for a specified item.

Args:

      index(typing.Any):The index of the item to retrieve the length of the text.MFC References

Returns:

      typing.Any
        
         """
         pass


      def InsertString(self,pos:'typing.Any',_object:'typing.Any') -> 'typing.Any':
         """
         Insert a string into a listbox.

Args:

      pos(typing.Any):The zero based index in the listbox to insert the new string
      _object(typing.Any):The object to be added to the listboxMFC References

Returns:

      typing.Any:CListBox::InsertString
Return ValueThe zero based index of the new string added.

        
         """
         pass


      def ResetContent(self,) -> 'None':
         """
         Clear all the items from a listbox.

Args:



Returns:

      None
        
         """
         pass


      def SetCaretIndex(self,index:'typing.Any',bScroll:'typing.Any'=1) -> 'None':
         """
         Sets the focus rectange to a specified item.

Args:

      index(typing.Any):The zero based index of the item.
      bScroll(typing.Any):Should the listbox scroll to the item?MFC References

Returns:

      None
        
         """
         pass


      def SelectString(self,after:'typing.Any',string:'str') -> 'None':
         """
         Searches for a list-box item that matches the specified string, and selects it.

Args:

      after(typing.Any):Contains the zero-based index of the item before the first item to be searched, or -1 for the entire listbox.
      string(str):The string to search for.MFC References

Returns:

      None:CListBox::SelectString
Return ValueThe return value is always None - an exception is raised if the string can not be located.

        
         """
         pass


      def SelItemRange(self,bSel:'typing.Any',start:'typing.Any',end:'typing.Any') -> 'None':
         """
         Selects an item range.

Args:

      bSel(typing.Any):Should the selection specified be set or cleared?
      start(typing.Any):The zero based index of the first item to select.
      end(typing.Any):The zero based index of the last item to select.

Returns:

      None
        
         """
         pass


      def SetCurSel(self,index:'typing.Any') -> 'None':
         """
         Selects an item in a single selection listbox.

Args:

      index(typing.Any):The zero based index of the item to select.MFC References

Returns:

      None
        
         """
         pass


      def SetItemData(self,item:'typing.Any',Data:'typing.Any') -> 'typing.Any':
         """
         Sets the item's application-specific object value.

Args:

      item(typing.Any):Index of the item whose Data is to be set.
      Data(typing.Any):New value for the data.CommentsNote that a reference count is not added to the object.  This it is your responsibility to make sure the object remains alive while in the list.

Returns:

      typing.Any
        
         """
         pass


      def SetItemValue(self,item:'typing.Any',data:'typing.Any') -> 'typing.Any':
         """
         Sets the item's application-specific value.

Args:

      item(typing.Any):Index of the item whose Data is to be set.
      data(typing.Any):New value for the data.

Returns:

      typing.Any
        
         """
         pass


      def SetSel(self,index:'typing.Any',bSel:'typing.Any'=1) -> 'None':
         """
         Selects an item in a multiple selection listbox.

Args:

      index(typing.Any):The zero based index of the item to select.
      bSel(typing.Any):Should the item be selected or deselected?MFC References

Returns:

      None
        
         """
         pass


      def SetTabStops(self,eachTabStop:'typing.Any',tabStops:'typing.Any') -> 'None':
         """
         Sets the tab stops for a listbox.

Args:

      eachTabStop(typing.Any):The position for each tab stop.Alternative Parameters
      tabStops(typing.Any):Each individual tab stop.

Returns:

      None
        
         """
         pass


      def SetTopIndex(self,index:'typing.Any') -> 'None':
         """
         Sets the top index (top most visible item) of the listbox.

Args:

      index(typing.Any):The zero based index of the item to place at the top of the list.MFC References

Returns:

      None
        
         """
         pass


class PyCListCtrl(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Arrange(self,code:'typing.Any') -> 'None':
         """
         Aligns items on a grid.

Args:

      code(typing.Any):Specifies the alignment style for the items

Returns:

      None
        
         """
         pass


      def CreateWindow(self,style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',PyCWnd:'typing.Any',_id:'typing.Any') -> 'None':
         """
         Creates the actual window for the object.

Args:

      style(typing.Any):The window style
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The default rectangle
      PyCWnd(typing.Any):The parent window
      _id(typing.Any):The control IDMFC References

Returns:

      None
        
         """
         pass


      def DeleteAllItems(self,) -> 'None':
         """
         Deletes all items from the list.

Args:



Returns:

      None
        
         """
         pass


      def DeleteItem(self,item:'typing.Any') -> 'None':
         """
         Deletes the specified item.

Args:

      item(typing.Any):The item to delete.

Returns:

      None
        
         """
         pass


      def GetTextColor(self,) -> 'typing.Any':
         """
         Retrieves the text color of a list view control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetTextColor(self,color:'typing.Any') -> 'None':
         """
         Sets the text color of a list view control.

Args:

      color(typing.Any):The new color.

Returns:

      None
        
         """
         pass


      def GetBkColor(self,) -> 'typing.Any':
         """
         Retrieves the background color of the control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetBkColor(self,color:'typing.Any') -> 'None':
         """
         Sets the background color of the control.

Args:

      color(typing.Any):The new background color.

Returns:

      None
        
         """
         pass


      def GetItem(self,item:'typing.Any',sub:'typing.Any') -> 'LV_ITEM':
         """
         Retrieves the details of an items attributes.

Args:

      item(typing.Any):The index of the item whose attributes are to be retrieved.
      sub(typing.Any):Specifies the subitem whose text is to be retrieved.

Returns:

      LV_ITEM
        
         """
         pass


      def GetItemCount(self,) -> 'typing.Any':
         """
         Retrieves the number of items in a list view control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetItemRect(self,item:'typing.Any',bTextOnly:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Retrieves the bounding rectangle of a list view item.

Args:

      item(typing.Any):Index of the item whose Data is to be set.
      bTextOnly(typing.Any):f this parameter is nonzero, the bounding rectangle includes only the text of the item. Otherwise it includes the entire line that the item occupies in the list view control.

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetEditControl(self,) -> 'PyCEdit':
         """
         Retrieves the handle of the edit control used to edit the specified 

list view item.

Args:



Returns:

      PyCEdit
        
         """
         pass


      def EditLabel(self,item:'typing.Any') -> 'PyCEdit':
         """
         Edits a specified list view item in-place.

Args:

      item(typing.Any):The index of item to edit.

Returns:

      PyCEdit
        
         """
         pass


      def EnsureVisible(self,item:'typing.Any',bPartialOK:'typing.Any') -> 'typing.Any':
         """
         Ensures that a list view item is visible in its list view control.

Args:

      item(typing.Any):The index of item to edit.
      bPartialOK(typing.Any):Specifies whether partial visibility is acceptable.

Returns:

      typing.Any
        
         """
         pass


      def CreateDragImage(self,item:'typing.Any') -> 'typing.Tuple[PyCImageList, typing.Any, typing.Any]':
         """
         Creates a dragging bitmap for the specified list view 

item.

Args:

      item(typing.Any):The index of the item to edit.

Returns:

      typing.Tuple[PyCImageList, typing.Any, typing.Any]
        
         """
         pass


      def GetImageList(self,nImageList:'typing.Any') -> 'PyCImageList':
         """
         Retrieves the current image list.

Args:

      nImageList(typing.Any):Value specifying which image list to retrieve. It can be one of: -	commctrl.LVSIL_NORMAL   Image list with large icons. -	commctrl.LVSIL_SMALL   Image list with small icons. -	commctrl.LVSIL_STATE   Image list with state images.

Returns:

      PyCImageList
        
         """
         pass


      def GetNextItem(self,item:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Searches for a list view item with specified properties and with specified 

relationship to a given item.

Args:

      item(typing.Any):Index of the item to begin the searching with, or -1 to find the first item that matches the specified flags. The specified item itself is excluded from the search.
      flags(typing.Any):Geometric relation of the requested item to the specified item, and the state of the requested item. The geometric relation can be one of these values: LVNI_ABOVELVNI_ALLLVNI_BELOWLVNI_TOLEFTLVNI_TORIGHT The state can be zero, or it can be one or more of these values: LVNI_DROPHILITEDLVNI_FOCUSEDLVNI_HIDDENLVNI_MARKEDLVNI_SELECTED If an item does not have all of the specified state flags set, the search continues with the next item.Return ValueReturns an integer index, or raises a win32ui.error exception if not item can be found.

Returns:

      typing.Any:Geometric relation of the requested item to the specified item, 

and the state of the requested item. The geometric relation can be one of these values: 

LVNI_ABOVELVNI_ALLLVNI_BELOWLVNI_TOLEFTLVNI_TORIGHT 

The state can be zero, or it can be one or more of these values: 

LVNI_DROPHILITEDLVNI_FOCUSEDLVNI_HIDDENLVNI_MARKEDLVNI_SELECTED 

If an item does not have all of the specified state flags set, the search continues with the 

next item.Return ValueReturns an integer index, or raises a win32ui.error exception if not item can be found.

        
         """
         pass


      def InsertColumn(self,colNo:'typing.Any',item:'LV_COLUMN') -> 'typing.Any':
         """
         Inserts a column into a list control when in report view.

Args:

      colNo(typing.Any):The new column number
      item(LV_COLUMN):A tuple describing the new column.

Returns:

      typing.Any
        
         """
         pass


      def InsertItem(self,item:'LV_ITEM',item1:'typing.Any',text:'typing.Any',image:'typing.Any',item2:'typing.Any',text1:'typing.Any') -> 'typing.Any':
         """
         Inserts an item into the list.

Args:

      item(LV_ITEM):A tuple describing the new item.Alternative Parameters
      item1(typing.Any):The index of the item.
      text(typing.Any):The text of the item.
      image(typing.Any):The index of the image to use.Alternative Parameters
      item2(typing.Any):The index of the item.
      text1(typing.Any):The text of the item.

Returns:

      typing.Any
        
         """
         pass


      def SetImageList(self,imageList:'PyCImageList',imageType:'typing.Any') -> 'typing.Any':
         """
         Assigns an image list to a list view control.

Args:

      imageList(PyCImageList):The Image List to use.
      imageType(typing.Any):Type of image list. It can be one of (COMMCTRL.) LVSIL_NORMAL, LVSIL_SMALL or LVSIL_STATE

Returns:

      typing.Any
        
         """
         pass


      def GetColumn(self,column:'typing.Any') -> 'LV_COLUMN':
         """
         Retrieves the details of a column in the control.

Args:

      column(typing.Any):The index of the column whose attributes are to be retrieved.

Returns:

      LV_COLUMN
        
         """
         pass


      def GetTextBkColor(self,) -> 'typing.Any':
         """
         Retrieves the text background color of a list view control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetTextBkColor(self,color:'typing.Any') -> 'None':
         """
         Sets the text background color of a list view control.

Args:

      color(typing.Any):The new background color.

Returns:

      None
        
         """
         pass


      def GetTopIndex(self,) -> 'typing.Any':
         """
         Retrieves the index of the topmost visible item.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetCountPerPage(self,) -> 'typing.Any':
         """
         Calculates the number of items that can fit vertically in a list view 

control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSelectedCount(self,) -> 'typing.Any':
         """
         Retrieves the number of selected items in the list view control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetItem(self,item:'LV_ITEM') -> 'typing.Any':
         """
         Sets some of all of an items attributes.

Args:

      item(LV_ITEM):A tuple describing the new item.

Returns:

      typing.Any
        
         """
         pass


      def SetItemState(self,item:'typing.Any',state:'typing.Any',mask:'typing.Any') -> 'typing.Any':
         """
         Changes the state of an item in a list view control.

Args:

      item(typing.Any):Index of the item whose state is to be set.
      state(typing.Any):New values for the state bits.
      mask(typing.Any):Mask specifying which state bits to change.

Returns:

      typing.Any
        
         """
         pass


      def GetItemState(self,item:'typing.Any',mask:'typing.Any') -> 'typing.Any':
         """
         Retrieves the state of a list view item.

Args:

      item(typing.Any):The index of the item whose position is to be retrieved.
      mask(typing.Any):Mask specifying which of the item's state flags to return.

Returns:

      typing.Any
        
         """
         pass


      def SetItemData(self,item:'typing.Any',Data:'typing.Any') -> 'typing.Any':
         """
         Sets the item's application-specific value.

Args:

      item(typing.Any):Index of the item whose Data is to be set.
      Data(typing.Any):New value for the data.CommentsNote that a reference count is not added to the object.  This it is your responsibility to make sure the object remains alive while in the list.

Returns:

      typing.Any
        
         """
         pass


      def GetItemData(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the application-specific value associated with an item.

Args:

      item(typing.Any):The index of the item whose data is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def SetItemCount(self,count:'typing.Any') -> 'None':
         """
         Prepares a list view control for adding a large number of items.

Args:

      count(typing.Any):Number of items that the control will ultimately contain.CommentsBy calling this function before adding a large number of items, you enable a list view control to reallocate its internal data structures only once rather than every time you add an item.

Returns:

      None
        
         """
         pass


      def SetItemText(self,item:'typing.Any',sub:'typing.Any',text:'str') -> 'typing.Any':
         """
         Changes the text of a list view item or subitem.

Args:

      item(typing.Any):Index of the item whose text is to be set.
      sub(typing.Any):Index of the subitem, or zero to set the item label.
      text(str):String that contains the new item text.

Returns:

      typing.Any
        
         """
         pass


      def GetItemText(self,item:'typing.Any',sub:'typing.Any') -> 'typing.Any':
         """
         Retrieves the text of a list view item or subitem.

Args:

      item(typing.Any):The index of the item whose text is to be retrieved.
      sub(typing.Any):Specifies the subitem whose text is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def RedrawItems(self,first:'typing.Any',first1:'typing.Any') -> 'typing.Any':
         """
         Forces a listview to repaint a range of items.

Args:

      first(typing.Any):Index of the first item to be repainted.
      first1(typing.Any):Index of the last item to be repainted.CommentsThe specified items are not actually repainted until the list view window receives a WM_PAINT message. To repaint immediately, call the Windows UpdateWindow function after using this function.

Returns:

      typing.Any
        
         """
         pass


      def Update(self,item:'typing.Any') -> 'None':
         """
         Forces the control to repaint a specified item.

Args:

      item(typing.Any):The new color.

Returns:

      None
        
         """
         pass


      def SetColumn(self,colNo:'typing.Any',item:'LV_COLUMN') -> 'typing.Any':
         """
         Changes column state in a list control when in report view.

Args:

      colNo(typing.Any):The to be modified column number
      item(LV_COLUMN):A tuple describing the modified column.

Returns:

      typing.Any
        
         """
         pass


      def DeleteColumn(self,first:'typing.Any') -> 'typing.Any':
         """
         Deletes the specified column from the list control.

Args:

      first(typing.Any):Index of the column to be removed.

Returns:

      typing.Any
        
         """
         pass


      def GetColumnWidth(self,first:'typing.Any') -> 'typing.Any':
         """
         Gets the width of the specified column in the list control.

Args:

      first(typing.Any):Index of the column whose width is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def SetColumnWidth(self,first:'typing.Any',first1:'typing.Any') -> 'typing.Any':
         """
         Sets the width of the specified column in the list control.

Args:

      first(typing.Any):Index of the column to be changed.
      first1(typing.Any):New width of the column.

Returns:

      typing.Any
        
         """
         pass


      def GetStringWidth(self,first:'typing.Any') -> 'typing.Any':
         """
         Gets the necessary column width to fully display this text in a column.

Args:

      first(typing.Any):String that contains the text whose width is to be determined.CommentsDoesn't take the size of an included Image in account, only the size of the text is determined.

Returns:

      typing.Any
        
         """
         pass


      def HitTest(self,arg:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Determines which list view item, if any, is at a specified position.

Args:

      arg(typing.Any):The point to test.Return ValueThe result is a tuple of (flags, item, subItem). flags may be a combination of the following values:ValueDescriptioncommctrl.LVHT_ABOVEThe position is above the control's client area.commctrl.LVHT_BELOWThe position is below the control's client area.commctrl.LVHT_NOWHEREThe position is inside the list view control's client window, but it is not over a list item.commctrl.LVHT_ONITEMICONThe position is over a list view item's icon.commctrl.LVHT_ONITEMLABELThe position is over a list view item's text.commctrl.LVHT_ONITEMSTATEICONThe position is over the state image of a list view item.commctrl.LVHT_TOLEFTThe position is to the left of the list view control's client area.commctrl.LVHT_TORIGHTThe position is to the right of the list view control's client area.

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]:The point to test.Return ValueThe result is a tuple of (flags, item, subItem). 

flags may be a combination of the following values:



Value


Description



commctrl.LVHT_ABOVEThe position is above the control's client area.
commctrl.LVHT_BELOWThe position is below the control's client area.
commctrl.LVHT_NOWHEREThe position is inside the list view control's client window, but it is not over a 

list item.
commctrl.LVHT_ONITEMICONThe position is over a list view item's icon.
commctrl.LVHT_ONITEMLABELThe position is over a list view item's text.
commctrl.LVHT_ONITEMSTATEICONThe position is over the state image of a list view item.
commctrl.LVHT_TOLEFTThe position is to the left of the list view control's client area.
commctrl.LVHT_TORIGHTThe position is to the right of the list view control's client area.

        
         """
         pass


      def GetItemPosition(self,item:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Determines the position of the specified item.

Args:

      item(typing.Any):The item to determine the position for.

Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


class PyCListView(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def PreCreateWindow(self,createStruct:'typing.Any') -> 'typing.Any':
         """
         Calls the underlying MFC PreCreateWindow method.

Args:

      createStruct(typing.Any):A tuple representing a CREATESTRUCT structure.

Returns:

      typing.Any
        
         """
         pass


      def GetListCtrl(self,) -> 'PyCListCtrl':
         """
         Returns the underlying list control object.

Args:



Returns:

      PyCListCtrl
        
         """
         pass


      def OnCommand(self,wparam:'typing.Any',lparam:'typing.Any') -> 'None':
         """
         Calls the standard Python framework OnCommand handler

Args:

      wparam(typing.Any):
      lparam(typing.Any):See Also

Returns:

      None
        
         """
         pass


class PyCMDIChildWnd(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ActivateFrame(self,cmdShow:'typing.Any'=-1) -> 'None':
         """
         Calls the underlying MFC ActivateFrame method.

Args:

      cmdShow(typing.Any):The status of the window.See Also

Returns:

      None
        
         """
         pass


      def CreateWindow(self,wndClass:'str',title:'str',style:'typing.Any',PyCWnd:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]'=None,createContext:'typing.Any'=None) -> 'typing.Any':
         """
         Creates the actual window for the PyCWnd object.

Args:

      wndClass(str):The window class name, or None
      title(str):The window title
      style(typing.Any):The window style
      PyCWnd(typing.Any):The parent window
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The default rectangle
      createContext(typing.Any):A tuple representing a CREATECONTEXT structure.CommentsYou do not need to call this method if you use the MFC Document/View framework.

Returns:

      typing.Any
        
         """
         pass


      def GetMDIFrame(self,) -> 'None':
         """
         Returns the MDI parent frame

Args:



Returns:

      None
        
         """
         pass


      def MDIActivate(self,cmdShow:'typing.Any'=-1) -> 'None':
         """
         Activates the MDI frame independent of the main frame.

Args:

      cmdShow(typing.Any):The status of the window.See Also

Returns:

      None
        
         """
         pass


      def PreCreateWindow(self,createStruct:'typing.Any') -> 'typing.Any':
         """
         Calls the underlying MFC PreCreateWindow method.

Args:

      createStruct(typing.Any):A tuple representing a CREATESTRUCT structure.See Also

Returns:

      typing.Any
        
         """
         pass


      def PreTranslateMessage(self,) -> 'None':
         """
         Calls the base PreTranslateMessage handler

Args:



Returns:

      None
        
         """
         pass


      def OnCommand(self,wparam:'typing.Any',lparam:'typing.Any') -> 'None':
         """
         Calls the standard Python framework OnCommand handler

Args:

      wparam(typing.Any):
      lparam(typing.Any):See Also

Returns:

      None
        
         """
         pass


      def OnClose(self,) -> 'None':
         """
         Calls the standard Python framework OnClose handler

Args:



Returns:

      None
        
         """
         pass


class PyCMDIFrameWnd(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetMDIClient(self,) -> 'PyCMDIFrameWnd':
         """
         Returns the MDI client window

Args:



Returns:

      PyCMDIFrameWnd
        
         """
         pass


      def MDIGetActive(self,) -> 'typing.Tuple[PyCMDIChildWnd, typing.Any]':
         """
         Retrieves the current active MDI child window, along 

with a flag indicating whether the child window is maximized.

Args:



Returns:

      typing.Tuple[PyCMDIChildWnd, typing.Any]
        
         """
         pass


      def MDIActivate(self,window:'PyCWnd') -> 'PyCMDIFrameWnd':
         """
         Activate an MDI child window

Args:

      window(PyCWnd):The window to activate.

Returns:

      PyCMDIFrameWnd
        
         """
         pass


      def MDINext(self,fNext:'typing.Any'=0) -> 'None':
         """
         Activates the next MDI window

Args:

      fNext(typing.Any):Indicates if the next (0) or previous (non-zero) window is requested.CommentsUnlike MFC, this version supports the fNext param in the WM_MDINEXT message.

Returns:

      None
        
         """
         pass


      def PreCreateWindow(self,createStruct:'typing.Any') -> 'typing.Any':
         """
         Calls the underlying MFC PreCreateWindow method.

Args:

      createStruct(typing.Any):A tuple representing a CREATESTRUCT structure.See Also

Returns:

      typing.Any
        
         """
         pass


      def PreTranslateMessage(self,) -> 'None':
         """
         Calls the base PreTranslateMessage handler

Args:



Returns:

      None
        
         """
         pass


      def OnCommand(self,wparam:'typing.Any',lparam:'typing.Any') -> 'None':
         """
         Calls the standard Python framework OnCommand handler

Args:

      wparam(typing.Any):
      lparam(typing.Any):See Also

Returns:

      None
        
         """
         pass


      def OnContextHelp(self,) -> 'typing.Any':
         """
         Calls the underlying MFC OnContextHelp method.

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnClose(self,) -> 'None':
         """
         Calls the standard Python framework OnClose handler

Args:



Returns:

      None
        
         """
         pass


class PyCMenu(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AppendMenu(self,flags:'typing.Any',_id:'typing.Any'=0,value:'typing.Union[str, typing.Any]'=None) -> 'None':
         """
         Appends a new item to the end of a menu. Python can specify the state of the menu item 

by setting values in nFlags.

Args:

      flags(typing.Any):Specifies information about the state of the new menu item when it is added to the menu.  May be a combination of the win32con.MF_* values.
      _id(typing.Any):Specifies either the command ID of the new menu item.
      value(typing.Union[str, typing.Any]):Specifies the content of the new menu item.  If used, flags must contain win32con.MF_STRING.

Returns:

      None
        
         """
         pass


      def DeleteMenu(self,_id:'typing.Any',flags:'typing.Any') -> 'str':
         """
         Deletes the specified menu item.

Args:

      _id(typing.Any):The id of the item being deleted.
      flags(typing.Any):Specifies how the id parameter is interpreted. It must be one of win32con.MF_BYCOMMAND or win32con.MF_BYPOSITION.

Returns:

      str
        
         """
         pass


      def EnableMenuItem(self,_id:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Enables, disables, or dims a menu item.

Args:

      _id(typing.Any):Specifies the command ID of the menu item. This parameter can specify pop-up menu items as well as standard menu items.
      flags(typing.Any):Specifies the action to take. It can be a combination of MF_DISABLED, MF_ENABLED, or MF_GRAYED, with MF_BYCOMMAND or MF_BYPOSITIONCommentsThe PyCMenu::CreateMenu, PyCMenu::InsertMenu, PyCMenu::ModifyMenu, and PyCMenu::LoadMenuIndirect member functions can also set the state (enabled, disabled, or dimmed) of a menu item.

Returns:

      typing.Any
        
         """
         pass


      def GetMenuItemCount(self,) -> 'typing.Any':
         """
         Determines the number of items in a menu.

Args:



Returns:

      typing.Any:PyCMenu.GetMenuItemCount

int = GetMenuItemCount()Determines the number of items in a menu.
Return ValueThe number of items in the menu if the function is successful; otherwise -1.

        
         """
         pass


      def GetMenuItemID(self,pos:'typing.Any') -> 'typing.Any':
         """
         Returns the item ID for the specified item in a pop-up menu.

Args:

      pos(typing.Any):The position (zero-based) of the menu item whose ID is being retrieved.CommentsIf the specified item is a pop-up menu (as opposed to an item within the pop-up menu), the return value is -1. If nPos corresponds to a SEPARATOR menu item, the return value is 0.

Returns:

      typing.Any
        
         """
         pass


      def GetMenuString(self,_id:'typing.Any',arg:'typing.Any') -> 'str':
         """
         Returns the string for a specified menu item.

Args:

      _id(typing.Any):The id of the item being requested.
      arg(typing.Any):Specifies how the id parameter is interpreted. It must be one of win32con.MF_BYCOMMAND or win32con.MF_BYPOSITION.

Returns:

      str
        
         """
         pass


      def GetSubMenu(self,pos:'typing.Any') -> 'PyCMenu':
         """
         Returns a submenu.

Args:

      pos(typing.Any):The position (zero-based) of the menu item being retrieved.

Returns:

      PyCMenu
        
         """
         pass


      def InsertMenu(self,pos:'typing.Any',flags:'typing.Any',_id:'typing.Union[PyCMenu, typing.Any]'=0,value:'typing.Union[str, typing.Any]'=None) -> 'None':
         """
         Inserts an item into a menu.

Args:

      pos(typing.Any):The position (zero-based) the item should be inserted.
      flags(typing.Any):Flags for the new item.
      _id(typing.Union[PyCMenu, typing.Any]):The ID for a new menu item, or handle to a submenu
      value(typing.Union[str, typing.Any]):A string for the menu item.

Returns:

      None
        
         """
         pass


      def ModifyMenu(self,pos:'typing.Any',flags:'typing.Any',_id:'typing.Any'=0,value:'typing.Union[str, typing.Any]'=None) -> 'None':
         """
         Modify an item in a menu.

Args:

      pos(typing.Any):The position (zero-based) the item to be changed.
      flags(typing.Any):Flags for the item.
      _id(typing.Any):The ID for the item.
      value(typing.Union[str, typing.Any]):A string for the menu item.

Returns:

      None
        
         """
         pass


      def TrackPopupMenu(self,arg:'typing.Tuple[typing.Any, typing.Any]',arg1:'typing.Any',arg2:'PyCWnd') -> 'None':
         """
         Creates a popup menu anywhere on the screen.

Args:

      arg(typing.Tuple[typing.Any, typing.Any]):The position for the menu..
      arg1(typing.Any):Flags for the menu.
      arg2(PyCWnd):The owner of the menu.CommentsThe TrackPopupMenu function displays a floating pop-up menu at the specified location and tracks the selection of items on the pop-up menu. The floating pop-up menu can appear anywhere on the screen.Return ValueIf the underlying MFC function fails, but TPM_RETURNCMD is set in the flags parameter, then None is returned instead of the normal exception.

Returns:

      None:The owner of the menu.
Comments

The TrackPopupMenu function displays a floating pop-up menu at the 

specified location and tracks the selection of items on the pop-up menu. 

The floating pop-up menu can appear anywhere on the screen.
Return ValueIf the underlying MFC function fails, but TPM_RETURNCMD is set in the flags parameter, then None is 

returned instead of the normal exception.

        
         """
         pass


class PyCOleClientItem(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateNewItem(self,) -> 'None':
         """
         Creates an embedded item.

Args:



Returns:

      None
        
         """
         pass


      def Close(self,) -> 'None':
         """
         Closes the item

Args:



Returns:

      None
        
         """
         pass


      def DoVerb(self,) -> 'None':
         """
         Executes the specified verb.

Args:



Returns:

      None
        
         """
         pass


      def Draw(self,) -> 'None':
         """
         Draws the OLE item into the specified bounding rectangle using the specified device 

context.

Args:



Returns:

      None
        
         """
         pass


      def GetActiveView(self,) -> 'PyCView':
         """
         Obtains the active view for the item

Args:



Returns:

      PyCView
        
         """
         pass


      def GetDocument(self,) -> 'PyCDocument':
         """
         Obtains the current document for the item

Args:



Returns:

      PyCDocument
        
         """
         pass


      def GetInPlaceWindow(self,) -> 'PyCWnd':
         """
         Obtains the window in which the item has been opened for 

in-place editing.

Args:



Returns:

      PyCWnd
        
         """
         pass


      def GetItemState(self,) -> 'None':
         """
         Obtains the OLE item's current state

Args:



Returns:

      None
        
         """
         pass


      def GetObject(self,) -> 'PyIUnknown':
         """
         Returns the COM object to the item.  This is the m_lpObject 

variable in MFC.

Args:



Returns:

      PyIUnknown
        
         """
         pass


      def GetStorage(self,) -> 'None':
         """
         Returns the COM object used for storage

Args:



Returns:

      None
        
         """
         pass


      def OnActivate(self,) -> 'None':
         """
         Calls the underlying MFC method.

Args:



Returns:

      None
        
         """
         pass


      def OnChange(self,) -> 'None':
         """
         Calls the underlying MFC method.

Args:



Returns:

      None
        
         """
         pass


      def OnChangeItemPosition(self,) -> 'typing.Any':
         """
         Calls the underlying MFC method.

Args:



Returns:

      typing.Any:PyCOleClientItem.OnChangeItemPosition

int = OnChangeItemPosition()Calls the underlying MFC method.
Return ValueThe result is a BOOL indicating if the function succeeded.  No exception is thrown.

        
         """
         pass


      def OnDeactivateUI(self,) -> 'typing.Any':
         """
         Calls the underlying MFC method.

Args:



Returns:

      typing.Any
        
         """
         pass


      def Run(self,) -> 'None':
         """
         Runs the application associated with this item.

Args:



Returns:

      None
        
         """
         pass


      def SetItemRects(self,) -> 'None':
         """
         Sets the bounding rectangle or the visible rectangle of the OLE item.

Args:



Returns:

      None
        
         """
         pass


class PyCOleDialog(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCOleDocument(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def EnableCompoundFile(self,bEnable:'typing.Any'=1) -> 'None':
         """
         Call this function if you want to store the document using the 

compound-file format.

Args:

      bEnable(typing.Any):Specifies whether compound file support is enabled or disabled.

Returns:

      None
        
         """
         pass


      def GetStartPosition(self,) -> 'typing.Any':
         """
         Obtains the position of the first item in the document.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetNextItem(self,pos:'typing.Any') -> 'typing.Tuple[typing.Any, PyCOleClientItem]':
         """
         Call this function repeatedly to access each of 

the items in your document.

Args:

      pos(typing.Any):The position to iterate from.

Returns:

      typing.Tuple[typing.Any, PyCOleClientItem]
        
         """
         pass


      def GetInPlaceActiveItem(self,wnd:'PyCWnd') -> 'PyCOleClientItem':
         """
         Obtains the OLE item that is currently activated 

in place in the frame window containing the view identified by obWnd.

Args:

      wnd(PyCWnd):The window.

Returns:

      PyCOleClientItem
        
         """
         pass


class PyCOleInsertDialog(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetClassID(self,) -> 'typing.Any':
         """
         Returns the CLSID associated with the selected item

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSelectionType(self,) -> 'typing.Any':
         """
         Returns the type of selection made

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetPathName(self,) -> 'typing.Any':
         """
         Returns the full path to the file selected in the dialog box

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCPrintDialog(object):
      """An object which encapsulates an MFC CPrintDialog object."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCPrintInfo(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def DocObject(self,) -> 'None':
         """
         Return true if the document being printed is a DocObject.

Args:



Returns:

      None
        
         """
         pass


      def GetDwFlags(self,) -> 'None':
         """
         A flags specifying DocObject printing operations. Valid only if data member 

m_bDocObject is TRUE.

Args:



Returns:

      None
        
         """
         pass


      def SetDwFlags(self,) -> 'None':
         """
         Set a flag specifying DocObject printing operations. Valid only if data member 

m_bDocObject is TRUE.

Args:



Returns:

      None
        
         """
         pass


      def GetDocOffsetPage(self,) -> 'None':
         """
         Get the number of pages preceding the first page of a particular DocObject 

in a combined DocObject print job.

Args:



Returns:

      None
        
         """
         pass


      def SetDocOffsetPage(self,) -> 'None':
         """
         Set the number of pages preceding the first page of a particular DocObject 

in a combined DocObject print job.

Args:



Returns:

      None
        
         """
         pass


      def SetPrintDialog(self,) -> 'None':
         """
         Set a pointer to the CPrintDialog object used to display the Print dialog box 

for the print job.

Args:



Returns:

      None
        
         """
         pass


      def GetDirect(self,) -> 'None':
         """
         TRUE if the Print dialog box will be bypassed for direct printing; FALSE otherwise.

Args:



Returns:

      None
        
         """
         pass


      def SetDirect(self,) -> 'None':
         """
         Sets to TRUE if the Print dialog box will be bypassed for direct printing; FALSE 

otherwise.

Args:



Returns:

      None
        
         """
         pass


      def GetPreview(self,) -> 'None':
         """
         A flag indicating whether the document is being previewed.

Args:



Returns:

      None
        
         """
         pass


      def SetPreview(self,) -> 'None':
         """
         Set whether the document is being previewed.

Args:



Returns:

      None
        
         """
         pass


      def GetContinuePrinting(self,) -> 'None':
         """
         A flag indicating whether the framework should continue the print loop.

Args:



Returns:

      None
        
         """
         pass


      def SetContinuePrinting(self,) -> 'None':
         """
         Set whether the framework should continue the print loop.

Args:



Returns:

      None
        
         """
         pass


      def GetCurPage(self,) -> 'None':
         """
         Get the number of the current page.

Args:



Returns:

      None
        
         """
         pass


      def SetCurPage(self,) -> 'None':
         """
         Set the number of the current page.

Args:



Returns:

      None
        
         """
         pass


      def GetNumPreviewPages(self,) -> 'None':
         """
         Get the number of pages displayed in preview mode.

Args:



Returns:

      None
        
         """
         pass


      def SetNumPreviewPages(self,) -> 'None':
         """
         Set the number of pages displayed in preview mode.

Args:



Returns:

      None
        
         """
         pass


      def GetUserData(self,) -> 'None':
         """
         Get a user-created structure.

Args:



Returns:

      None
        
         """
         pass


      def SetUserData(self,) -> 'None':
         """
         Set a user-created structure.

Args:



Returns:

      None
        
         """
         pass


      def GetDraw(self,) -> 'None':
         """
         Get the usable drawing area of the page in logical coordinates.

Args:



Returns:

      None
        
         """
         pass


      def SetDraw(self,) -> 'None':
         """
         Set the usable drawing area of the page in logical coordinates.

Args:



Returns:

      None
        
         """
         pass


      def GetPageDesc(self,) -> 'None':
         """
         Get the format string used to display the page numbers during print preview

Args:



Returns:

      None
        
         """
         pass


      def SetPageDesc(self,) -> 'None':
         """
         Set the format string used to display the page numbers during print preview

Args:



Returns:

      None
        
         """
         pass


      def GetMinPage(self,) -> 'None':
         """
         Get the number of the first page of the document.

Args:



Returns:

      None
        
         """
         pass


      def SetMinPage(self,) -> 'None':
         """
         Set the number of the first page of the document.

Args:



Returns:

      None
        
         """
         pass


      def GetMaxPage(self,) -> 'None':
         """
         Get the number of the last page of the document.

Args:



Returns:

      None
        
         """
         pass


      def SetMaxPage(self,) -> 'None':
         """
         Set the number of the last page of the document.

Args:



Returns:

      None
        
         """
         pass


      def GetOffsetPage(self,) -> 'None':
         """
         Get the number of pages preceding the first page of a DocObject item being 

printed in a combined DocObject print job.  This currently does NOT work, as, if I include the symbol 

pInfo-&gtGetOffsetPage(), the link fails to find its definition.  Allways returns 0.

Args:



Returns:

      None
        
         """
         pass


      def GetFromPage(self,) -> 'None':
         """
         The number of the first page to be printed.

Args:



Returns:

      None
        
         """
         pass


      def GetToPage(self,) -> 'None':
         """
         The number of the last page to be printed.

Args:



Returns:

      None
        
         """
         pass


      def SetHDC(self,hdc:'typing.Any') -> 'None':
         """
         Sets the printer DC compatible with the users choices, call after the print dialog 

DoModal finishes.

Args:

      hdc(typing.Any):The DC.MFC References

Returns:

      None
        
         """
         pass


      def CreatePrinterDC(self,) -> 'None':
         """
         Handle to the newly created printer device context, call only after DoModal 

finishes.

Args:



Returns:

      None
        
         """
         pass


      def DoModal(self,) -> 'None':
         """
         Call DoModal on the dialog.

Args:



Returns:

      None
        
         """
         pass


      def GetCopies(self,) -> 'None':
         """
         The number of copies requested, call only after DoModal finishes.

Args:



Returns:

      None
        
         """
         pass


      def GetDefaults(self,) -> 'None':
         """
         Nonzero if the function was successful; otherwise 0.  Call this function to 

retrieve the device defaults of the default printer without displaying a dialog box. The retrieved values are placed 

in the m_pd structure.  In some cases, a call to this function will call the constructor for CPrintDialog with 

bPrintSetupOnly set to FALSE. In these cases, a printer DC and hDevNames and hDevMode (two handles located in the 

m_pd data member) are automatically allocated.  If the constructor for CPrintDialog was called with bPrintSetupOnly 

set to FALSE, this function will not only return hDevNames and hDevMode (located in m_pd.hDevNames and m_pd.hDevMode) 

to the caller, but will also return a printer DC in m_pd.hDC. It is the responsibility of the caller to delete the 

printer DC and call the WindowsGlobalFree function on the handles when you are finished with the CPrintDialog object.

Args:



Returns:

      None
        
         """
         pass


      def FreeDefaults(self,) -> 'None':
         """
         After a call to GetDefaults, and you are through with the CPrintDialog object, 

this call deletes the printer DC and calls GlobalFree function on the handles.

Args:



Returns:

      None
        
         """
         pass


      def GetDeviceName(self,) -> 'None':
         """
         The name of the currently selected printer, call only after DoModal finishes.

Args:



Returns:

      None
        
         """
         pass


      def GetDriverName(self,) -> 'None':
         """
         The name of the currently selected printer device driver, call only after 

DoModal finishes.

Args:



Returns:

      None
        
         """
         pass


      def GetDlgFromPage(self,) -> 'None':
         """
         Retrieves the starting page of the print range.

Args:



Returns:

      None
        
         """
         pass


      def GetDlgToPage(self,) -> 'None':
         """
         Retrieves the ending page of the print range.

Args:



Returns:

      None
        
         """
         pass


      def GetPortName(self,) -> 'None':
         """
         The name of the currently selected printer port, call only after DoModal 

finishes.

Args:



Returns:

      None
        
         """
         pass


      def GetPrinterDC(self,) -> 'None':
         """
         A handle to the printer device context if successful; otherwise NULL.  If the 

bPrintSetupOnly parameter of the CPrintDialog constructor was FALSE (indicating that the Print dialog box is 

displayed), then GetPrinterDC returns a handle to the printer device context. You must call the WindowsDeleteDC 

function to delete the device context when you are done using it.

Args:



Returns:

      None
        
         """
         pass


      def PrintAll(self,) -> 'None':
         """
         Nonzero if all pages in the document are to be printed; otherwise 0, call only after 

DoModal finishes.

Args:



Returns:

      None
        
         """
         pass


      def PrintCollate(self,) -> 'None':
         """
         Nonzero if the user selects the collate check box in the dialog box; otherwise 

0, call only after DoModal finishes.

Args:



Returns:

      None
        
         """
         pass


      def PrintRange(self,) -> 'None':
         """
         Nonzero if only a range of pages in the document are to be printed; otherwise 0, 

call only after DoModal finishes.

Args:



Returns:

      None
        
         """
         pass


      def PrintSelection(self,) -> 'None':
         """
         Nonzero if only the selected items are to be printed; otherwise 0., call only 

after DoModal finishes

Args:



Returns:

      None
        
         """
         pass


      def GetHDC(self,) -> 'None':
         """
         Identifies a device context or an information context, depending on whether the Flags 

member specifies the PD_RETURNDC or PC_RETURNIC flag. If neither flag is specified, the value of this member is 

undefined. If both flags are specified, PD_RETURNDC has priority.

Args:



Returns:

      None
        
         """
         pass


      def GetFlags(self,) -> 'None':
         """
         A set of bit flags that you can use to initialize the Print common dialog box. When 

the dialog box returns, it sets these flags to indicate the user's input. This member can be a combination of the 

following flags: PD_ALLPAGES, PD_COLLATE, PD_DISABLEPRINTTOFILE, PD_ENABLEPRINTHOOK, PD_ENABLEPRINTTEMPLATE, 

PD_ENABLEPRINTTEMPLATEHANDLE, PD_ENABLESETUPHOOK, PD_ENABLESETUPTEMPLATE, PD_ENABLESETUPTEMPLATEHANDLE, 

PD_HIDEPRINTTOFILE, PD_NONETWORKBUTTON, PD_NOPAGENUMS, PD_NOSELECTION, PD_NOWARNING, PD_PAGENUMS, PD_PRINTSETUP, 

PD_PRINTTOFILE, PD_RETURNDC, PD_RETURNDEFAULT, PD_RETURNIC, PD_SELECTION, PD_SHOWHELP, PD_USEDEVMODECOPIES, 

PD_USEDEVMODECOPIESANDCOLLATE.

Args:



Returns:

      None
        
         """
         pass


      def SetFlags(self,) -> 'None':
         """
         A set of bit flags that you can use to initialize the Print common dialog box. When 

the dialog box returns, it sets these flags to indicate the user's input. This member can be a combination of the 

following flags: PD_ALLPAGES, PD_COLLATE, PD_DISABLEPRINTTOFILE, PD_ENABLEPRINTHOOK, PD_ENABLEPRINTTEMPLATE, 

PD_ENABLEPRINTTEMPLATEHANDLE, PD_ENABLESETUPHOOK, PD_ENABLESETUPTEMPLATE, PD_ENABLESETUPTEMPLATEHANDLE, 

PD_HIDEPRINTTOFILE, PD_NONETWORKBUTTON, PD_NOPAGENUMS, PD_NOSELECTION, PD_NOWARNING, PD_PAGENUMS, PD_PRINTSETUP, 

PD_PRINTTOFILE, PD_RETURNDC, PD_RETURNDEFAULT, PD_RETURNIC, PD_SELECTION, PD_SHOWHELP, PD_USEDEVMODECOPIES, 

PD_USEDEVMODECOPIESANDCOLLATE.

Args:



Returns:

      None
        
         """
         pass


      def SetFromPage(self,) -> 'None':
         """
         The number of the first page to be printed.

Args:



Returns:

      None
        
         """
         pass


      def SetToPage(self,) -> 'None':
         """
         The number of the last page to be printed.

Args:



Returns:

      None
        
         """
         pass


      def GetPRINTDLGMinPage(self,) -> 'None':
         """
         Get the minimum value for the page range specified in the From and To page 

edit controls. If nMinPage equals nMaxPage, the Pages radio button and the starting and ending page edit controls are 

disabled.

Args:



Returns:

      None
        
         """
         pass


      def SetPRINTDLGMinPage(self,) -> 'None':
         """
         Set the minimum value for the page range specified in the From and To page 

edit controls. If nMinPage equals nMaxPage, the Pages radio button and the starting and ending page edit controls are 

disabled.

Args:



Returns:

      None
        
         """
         pass


      def GetPRINTDLGCopies(self,) -> 'None':
         """
         Get the initial number of copies for the Copies edit control if hDevMode is 

NULL; otherwise, the dmCopies member of theDEVMODE structure contains the initial value. When PrintDlg returns, 

nCopies contains the actual number of copies to print. This value depends on whether the application or the printer 

driver is responsible for printing multiple copies. If the PD_USEDEVMODECOPIESANDCOLLATE flag is set in the Flags 

member, nCopies is always 1 on return, and the printer driver is responsible for printing multiple copies. If the 

flag is not set, the application is responsible for printing the number of copies specified by nCopies. For more 

information, see the description of the PD_USEDEVMODECOPIESANDCOLLATE flag.

Args:



Returns:

      None
        
         """
         pass


      def SetPRINTDLGCopies(self,) -> 'None':
         """
         Set the initial number of copies for the Copies edit control if hDevMode is 

NULL; otherwise, the dmCopies member of theDEVMODE structure contains the initial value. When PrintDlg returns, 

nCopies contains the actual number of copies to print. This value depends on whether the application or the printer 

driver is responsible for printing multiple copies. If the PD_USEDEVMODECOPIESANDCOLLATE flag is set in the Flags 

member, nCopies is always 1 on return, and the printer driver is responsible for printing multiple copies. If the 

flag is not set, the application is responsible for printing the number of copies specified by nCopies. For more 

information, see the description of the PD_USEDEVMODECOPIESANDCOLLATE flag.

Args:



Returns:

      None
        
         """
         pass


class PyCProgressCtrl(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateWindow(self,style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',parent:'PyCWnd',_id:'typing.Any') -> 'None':
         """
         Creates the actual control.

Args:

      style(typing.Any):The style for the control.
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The size and position of the control.
      parent(PyCWnd):The parent window of the control.  Usually a PyCDialog.
      _id(typing.Any):The control's ID.

Returns:

      None
        
         """
         pass


      def SetRange(self,nLower:'typing.Any'=1,nUpper:'typing.Any'=1) -> 'None':
         """
         Set the control's bounds

Args:

      nLower(typing.Any):Specifies the lower limit of the range (default is zero).
      nUpper(typing.Any):Specifies the upper limit of the range (default is 100).

Returns:

      None
        
         """
         pass


      def SetPos(self,nPos:'typing.Any'=1) -> 'typing.Any':
         """
         Set the control's position

Args:

      nPos(typing.Any):New position of the progress bar control.

Returns:

      typing.Any
        
         """
         pass


      def OffsetPos(self,nPos:'typing.Any'=1) -> 'typing.Any':
         """
         Advances the progress bar control's current position by the increment 

specified

Args:

      nPos(typing.Any):Amount to advance the position.

Returns:

      typing.Any
        
         """
         pass


      def SetStep(self,nStep:'typing.Any'=1) -> 'typing.Any':
         """
         Specifies the step increment for a progress bar control.

Args:

      nStep(typing.Any):New step increment.

Returns:

      typing.Any
        
         """
         pass


      def StepIt(self,) -> 'typing.Any':
         """
         Advances the current position for a progress bar control by the step increment. 

Returns previous position.

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCPropertyPage(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CancelToClose(self,) -> 'None':
         """
         Changes the Cancel button to Close.

Args:



Returns:

      None
        
         """
         pass


      def OnCancel(self,) -> 'None':
         """
         Calls the default MFC OnCancel handler.

Args:



Returns:

      None
        
         """
         pass


      def OnOK(self,) -> 'None':
         """
         Calls the default MFC OnOK handler.

Args:



Returns:

      None
        
         """
         pass


      def OnApply(self,) -> 'None':
         """
         Calls the default MFC OnApply handler.

Args:



Returns:

      None
        
         """
         pass


      def OnReset(self,) -> 'None':
         """
         Calls the default MFC OnReset handler.

Args:



Returns:

      None
        
         """
         pass


      def OnQueryCancel(self,) -> 'None':
         """
         Calls the default MFC OnQueryCancel handler.

Args:



Returns:

      None
        
         """
         pass


      def OnWizardBack(self,) -> 'None':
         """
         Calls the default MFC OnWizardBack handler.

Args:



Returns:

      None
        
         """
         pass


      def OnWizardNext(self,) -> 'None':
         """
         Calls the default MFC OnWizardNext handler.

Args:



Returns:

      None
        
         """
         pass


      def OnWizardFinish(self,) -> 'None':
         """
         Calls the default MFC OnWizardFinish handler.

Args:



Returns:

      None
        
         """
         pass


      def OnSetActive(self,) -> 'typing.Any':
         """
         Calls the default MFC OnSetActive handler.

Args:



Returns:

      typing.Any:PyCPropertyPage.OnSetActive virtual method
Return ValueThe result is true if the page should be made active. 

Typically this result should be passed to the original OnSetActive handler.

        
         """
         pass


      def OnKillActive(self,) -> 'typing.Any':
         """
         Calls the default MFC OnKillActive handler.

Args:



Returns:

      typing.Any:PyCPropertyPage.OnKillActive virtual method
Return ValueThe result is true if the page should be deselected. 

Typically this result should be passed to the original OnSetActive handler.

        
         """
         pass


      def SetModified(self,bChanged:'typing.Any'=1) -> 'None':
         """
         Sets the modified flag.

Args:

      bChanged(typing.Any):A flag to indicate the new modified state.

Returns:

      None
        
         """
         pass


      def SetPSPBit(self,bitMask:'typing.Any',bitValue:'typing.Any') -> 'None':
         """
         Sets or clears a bit in m_psp.dwFlags

Args:

      bitMask(typing.Any):The PSP_* bit mask constant
      bitValue(typing.Any):1 to set, 0 to clear

Returns:

      None
        
         """
         pass


class PyCPropertySheet(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddPage(self,page:'PyCPropertyPage') -> 'None':
         """
         Adds the supplied page with the rightmost tab in the property sheet.

Args:

      page(PyCPropertyPage):The page to be added.CommentsAdd pages to the property sheet in the left-to-right order you want them to appear.MFC References

Returns:

      None
        
         """
         pass


      def CreateWindow(self,style:'typing.Any',exStyle:'typing.Any',parent:'PyCWnd'=None) -> 'None':
         """
         Displays the property sheet as a modeless dialog.

Args:

      style(typing.Any):The style for the window.
      exStyle(typing.Any):The extended style for the window.
      parent(PyCWnd):The parent of the dialog.

Returns:

      None
        
         """
         pass


      def DoModal(self,) -> 'typing.Any':
         """
         Displays the property sheet as a modal dialog.

Args:



Returns:

      typing.Any
        
         """
         pass


      def EnableStackedTabs(self,stacked:'typing.Any') -> 'PyCPropertyPage':
         """
         Enables or disables stacked tabs.

Args:

      stacked(typing.Any):A boolean flag

Returns:

      PyCPropertyPage
        
         """
         pass


      def EndDialog(self,result:'typing.Any') -> 'None':
         """
         Closes the dialog, with the specified result.

Args:

      result(typing.Any):The result to be returned by DoModal.

Returns:

      None
        
         """
         pass


      def GetActiveIndex(self,) -> 'typing.Any':
         """
         Retrieves the index of the active page of the property sheet.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetActivePage(self,) -> 'PyCPropertyPage':
         """
         Returns the currently active property page.

Args:



Returns:

      PyCPropertyPage
        
         """
         pass


      def GetPage(self,pageNo:'typing.Any') -> 'PyCPropertyPage':
         """
         Returns the specified property page.

Args:

      pageNo(typing.Any):The index of the page toretrieve.MFC References

Returns:

      PyCPropertyPage
        
         """
         pass


      def GetPageIndex(self,page:'PyCPropertyPage') -> 'typing.Any':
         """
         Retrieves the index of the specified page of the property sheet.

Args:

      page(PyCPropertyPage):The page.

Returns:

      typing.Any
        
         """
         pass


      def GetPageCount(self,) -> 'typing.Any':
         """
         Returns the number of pages.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetTabCtrl(self,) -> 'PyCTabCtrl':
         """
         Returns the tab control used by the sheet.

Args:



Returns:

      PyCTabCtrl
        
         """
         pass


      def OnInitDialog(self,) -> 'typing.Any':
         """
         Calls the default MFC OnInitDialog handler.

Args:



Returns:

      typing.Any
        
         """
         pass


      def PressButton(self,button:'typing.Any') -> 'None':
         """
         Simulates the choice of the specified button in a property sheet.

Args:

      button(typing.Any):The button to press

Returns:

      None
        
         """
         pass


      def RemovePage(self,offset:'typing.Any',page:'typing.Any') -> 'None':
         """
         Removes the specified page from the sheet.

Args:

      offset(typing.Any):The page number to removeAlternative Parameters
      page(typing.Any):The page to remove

Returns:

      None
        
         """
         pass


      def SetActivePage(self,page:'PyCPropertyPage') -> 'None':
         """
         Programmatically sets the active page object.

Args:

      page(PyCPropertyPage):The page.

Returns:

      None
        
         """
         pass


      def SetTitle(self,title:'str') -> 'None':
         """
         Sets the caption for the property sheet.

Args:

      title(str):The new caption

Returns:

      None
        
         """
         pass


      def SetFinishText(self,text:'str') -> 'None':
         """
         Sets the text for the Finish button

Args:

      text(str):The next for the button

Returns:

      None
        
         """
         pass


      def SetWizardMode(self,) -> 'None':
         """
         Enables the wizard mode

Args:



Returns:

      None
        
         """
         pass


      def SetWizardButtons(self,flags:'typing.Any') -> 'None':
         """
         Enables the wizard buttons

Args:

      flags(typing.Any):The wizard flags

Returns:

      None
        
         """
         pass


      def SetPSHBit(self,bitMask:'typing.Any',bitValue:'typing.Any') -> 'None':
         """
         Sets or clears a bit in m_psh.dwFlags

Args:

      bitMask(typing.Any):The PSH_* bit mask constant
      bitValue(typing.Any):1 to set, 0 to clear

Returns:

      None
        
         """
         pass


class PyCRect(object):
      """A Python interface the the MFC CRect class."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCRgn(object):
      """An object encapsulating an MFC PyCRgn class."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class PyCRichEditCtrl(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def Clear(self,) -> 'typing.Any':
         """
         Clears all text in an edit control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def Copy(self,) -> 'None':
         """
         Copys the current selection to the clipboard.

Args:



Returns:

      None
        
         """
         pass


      def CreateWindow(self,style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',parent:'PyCWnd',_id:'typing.Any') -> 'None':
         """
         Creates a rich edit control window.

Args:

      style(typing.Any):The control style
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The position of the control
      parent(PyCWnd):The parent window.  Must not be None
      _id(typing.Any):The control ID

Returns:

      None
        
         """
         pass


      def Cut(self,) -> 'None':
         """
         Cuts the current selection to the clipboard.

Args:



Returns:

      None
        
         """
         pass


      def FindText(self,charPos:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Finds text in the control

Args:

      charPos(typing.Any):The character position

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetCharPos(self,charPos:'typing.Any') -> 'typing.Any':
         """
         Returns the location of the top-left corner of the character specified 

by charPos.

Args:

      charPos(typing.Any):The character positionReturn ValueThe return value is a win32ui::CHARFORMAT tuple

Returns:

      typing.Any:The character positionReturn ValueThe return value is a win32ui::CHARFORMAT tuple


        
         """
         pass


      def GetDefaultCharFormat(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any:CRichEditCtrl::GetDefaultCharFormat
Return ValueThe return value is a win32ui::CHARFORMAT tuple


        
         """
         pass


      def GetEventMask(self,) -> 'typing.Any':
         """
         Returns the current event mask.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSelectionCharFormat(self,) -> 'typing.Any':
         """
         Returns the character formatting of the selection.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetFirstVisibleLine(self,) -> 'typing.Any':
         """
         Returns zero-based index of the topmost visible line.

Args:



Returns:

      typing.Any:CRichEditCtrl::GetFirstVisibleLine
Return ValueThe zero-based index of the topmost visible line. For single-line edit controls, the return value is 0.

        
         """
         pass


      def GetParaFormat(self,) -> 'typing.Any':
         """
         Returns the current paragraph formatting attributes.

Args:



Returns:

      typing.Any:CRichEditCtrl::GetParaFormat
Return ValueThe return value is a win32ui::PARAFORMAT tuple


        
         """
         pass


      def GetSel(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Returns the start and end of the current selection.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]:CRichEditCtrl::GetSel
Return ValueThe return tuple is (the first character in the current selection, first nonselected character past the 

end of the current selection)

        
         """
         pass


      def GetSelText(self,) -> 'str':
         """
         Returns the currently selected text

Args:



Returns:

      str
        
         """
         pass


      def GetTextLength(self,) -> 'typing.Any':
         """
         Returns the length of the text in the control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetLine(self,lineNo:'typing.Any') -> 'typing.Any':
         """
         Returns the text in a specified line.

Args:

      lineNo(typing.Any):Contains the zero-based index value for the desired line.CommentsThis function is not an MFC wrapper.

Returns:

      typing.Any
        
         """
         pass


      def GetModify(self,) -> 'typing.Any':
         """
         Nonzero if the text in this control has been modified; otherwise 0.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetLineCount(self,) -> 'typing.Any':
         """
         Gets the number of lines in an edit control.

Args:



Returns:

      typing.Any:CRichEditCtrl::GetLineCount
Return ValueThe number of lines in the buffer.  If the control is empty, the return value is 1.

        
         """
         pass


      def LimitText(self,nChars:'typing.Any'=0) -> 'None':
         """
         Sets max length of text that user can enter

Args:

      nChars(typing.Any):Specifies the length (in bytes) of the text that the user can enter. If this parameter is 0, the text length is set to UINT_MAX bytes. This is the default behavior.MFC References

Returns:

      None
        
         """
         pass


      def LineFromChar(self,charNo:'typing.Any'=-1) -> 'typing.Any':
         """
         Returns the line number of the specified character.

Args:

      charNo(typing.Any):Contains the zero-based index value for the desired character in the text of the edit control, or -1.  If -1, then it specifies the current line.MFC References

Returns:

      typing.Any:CRichEditCtrl::LineFromChar
Return ValueThe zero-based line number of the line containing the character index specified by charNo. 

If charNo is -1, the number of the line that contains the first character of the selection is returned. 

If there is no selection, the current line number is returned.

        
         """
         pass


      def LineIndex(self,lineNo:'typing.Any'=-1) -> 'typing.Any':
         """
         Retrieves the character index of a line within a multiple-line edit control.

Args:

      lineNo(typing.Any):Contains the index value for the desired line in the text of the edit control, or contains -1.  If -1, then it specifies the current line.CommentsThis method only works on multi-linr edit controls.MFC References

Returns:

      typing.Any:CRichEditCtrl::LineIndex
Return ValueThe character index of the line specified in lineNo, or -1 if 

the specified line number is greater then the number of lines in 

the edit control.

        
         """
         pass


      def LineScroll(self,nLines:'typing.Any',nChars:'typing.Any'=0) -> 'typing.Any':
         """
         Scroll the control vertically and horizontally

Args:

      nLines(typing.Any):Specifies the number of lines to scroll vertically.
      nChars(typing.Any):Specifies the number of character positions to scroll horizontally. This value is ignored if the edit control has either the ES_RIGHT or ES_CENTER style.CommentsThis method only works on multi-linr edit controls.MFC References

Returns:

      typing.Any
        
         """
         pass


      def Paste(self,) -> 'None':
         """
         Pastes the contents of the clipboard into the control.

Args:



Returns:

      None
        
         """
         pass


      def ReplaceSel(self,text:'str') -> 'None':
         """
         Replaces the selection with the specified text.

Args:

      text(str):The text to replace the selection with.MFC References

Returns:

      None
        
         """
         pass


      def SetBackgroundColor(self,bSysColor:'typing.Any',cr:'typing.Any'=0) -> 'typing.Any':
         """
         Sets the background color for the control.

Args:

      bSysColor(typing.Any):Indicates if the background color should be set to the system value. If this value is TRUE, cr is ignored.
      cr(typing.Any):The requested background color. Used only if bSysColor is FALSE.MFC References

Returns:

      typing.Any:CRichEditCtrl::SetEventMask
Return ValueThe return value is the previous background color.

        
         """
         pass


      def SetDefaultCharFormat(self,charFormat:'typing.Any') -> 'None':
         """
         None

Args:

      charFormat(typing.Any):A charformat tuple.  See win32ui::CHARFORMAT tuple for details.MFC References

Returns:

      None
        
         """
         pass


      def SetEventMask(self,eventMask:'typing.Any') -> 'typing.Any':
         """
         Sets the event motification mask.

Args:

      eventMask(typing.Any):The new event mask.  Must be one of the win32con.ENM_* flags.MFC References

Returns:

      typing.Any:CRichEditCtrl::SetEventMask
Return ValueThe return value is the previous event mask.

        
         """
         pass


      def SetSelectionCharFormat(self,charFormat:'typing.Any') -> 'None':
         """
         Sets the current selections character formatting attributes.

Args:

      charFormat(typing.Any):A charformat tuple.  See win32ui::CHARFORMAT tuple for details.MFC References

Returns:

      None
        
         """
         pass


      def SetModify(self,modified:'typing.Any'=1) -> 'None':
         """
         Sets the modified flag for this control

Args:

      modified(typing.Any):Indicates the new value for the modified flag.MFC References

Returns:

      None
        
         """
         pass


      def SetOptions(self,op:'typing.Any',flags:'typing.Any') -> 'None':
         """
         Sets options for the control.

Args:

      op(typing.Any):Indicates the operation.  Must be one of the win32con.ECOOP_* flags.
      flags(typing.Any):Indicates the options.  Must be one a combination of win32con.ECO_* flags.MFC References

Returns:

      None
        
         """
         pass


      def SetParaFormat(self,paraFormat:'typing.Any') -> 'typing.Any':
         """
         Sets the paragraph formatting

Args:

      paraFormat(typing.Any):A charformat tuple.  See win32ui::PARAFORMAT tuple for details.MFC References

Returns:

      typing.Any:CRichEditCtrl::SetParaFormat
Return ValueThis function seems to return occasionally return failure, but 

the formatting is applied.  Therefore an exception is not raised on failure, 

but the BOOL return code is passed back.

        
         """
         pass


      def SetReadOnly(self,bReadOnly:'typing.Any'=1) -> 'None':
         """
         Sets or clears the read-only status of the listbox.

Args:

      bReadOnly(typing.Any):The read-only state to set.MFC References

Returns:

      None
        
         """
         pass


      def SetSel(self,start:'typing.Any',end:'typing.Any',arg:'typing.Any') -> 'None':
         """
         Sets the selection in the edit control.

Args:

      start(typing.Any):Specifies the starting position. If start is 0 and end is -1, all the text in the edit control is selected. If start is -1, any current selection is removed.
      end(typing.Any):Specifies the ending position.Alternative Parameters
      arg(typing.Any):As for normal start, end args.MFC References

Returns:

      None
        
         """
         pass


      def SetSelAndCharFormat(self,charFormat:'typing.Any') -> 'None':
         """
         Sets the selection and char format.

Args:

      charFormat(typing.Any):A charformat tuple.  See win32ui::CHARFORMAT tuple for details.CommentsHighly optimised for speed for color editors.MFC References

Returns:

      None
        
         """
         pass


      def SetTargetDevice(self,dc:'PyCDC',lineWidth:'typing.Any') -> 'None':
         """
         Sets the target device for the control

Args:

      dc(PyCDC):The new DC - may be None
      lineWidth(typing.Any):Line width to use for formatting.MFC References

Returns:

      None
        
         """
         pass


      def StreamIn(self,_format:'typing.Any',method:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Invokes a callback to stream data into the control.

Args:

      _format(typing.Any):The format.  One of the win32con.SF_* flags (SF_TEXT,SF_RTF)
      method(typing.Any):A callable object (eg, a method or function) This method is called with a single integer param, which is the maximum number of bytes to fetch.  The method should return a zero length string, or None to finish the operation, and a string otherwise.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any]:CRichEditCtrl::StreamIn
Return ValueThe return value is a tuple of (no bytes written, error code)

        
         """
         pass


      def StreamOut(self,_format:'typing.Any',method:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Invokes a callback to stream data into the control.

Args:

      _format(typing.Any):The format.  One of the win32con.SF_* flags (SF_TEXT,SF_RTF) and may also combine SFF_SELECTION.
      method(typing.Any):A callable object (eg, a method or function) This method is called with a string parameter.  It should return an integer, zero to abort, non zero otherwise.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any]:CRichEditCtrl::StreamOut
Return ValueThe return value is a tuple of (no bytes written, error code)

        
         """
         pass


class PyCRichEditDoc(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def OnCloseDocument(self,) -> 'None':
         """
         Call the MFC OnCloseDocument handler. 

This routine is provided so a document object which overrides this method 

can call the original MFC version if required.

Args:



Returns:

      None
        
         """
         pass


class PyCRichEditDocTemplate(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def DoCreateRichEditDoc(self,fileName:'str'=None) -> 'PyCRichEditDoc':
         """
         Creates an underlying document object.

Args:

      fileName(str):The name of the file to load.

Returns:

      PyCRichEditDoc
        
         """
         pass


class PyCRichEditView(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetRichEditCtrl(self,) -> 'PyCRichEditCtrl':
         """
         Returns the underlying rich edit control object.

Args:



Returns:

      PyCRichEditCtrl
        
         """
         pass


      def SetWordWrap(self,wordWrap:'typing.Any') -> 'typing.Any':
         """
         Sets the wordwrap state for the control.

Args:

      wordWrap(typing.Any):The new word-wrap state.MFC References

Returns:

      typing.Any
        
         """
         pass


      def WrapChanged(self,) -> 'typing.Any':
         """
         Calls the underlying WrapChanged method.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SaveTextFile(self,FileName:'typing.Any') -> 'typing.Any':
         """
         Saves the contents of the control as a test file

Args:

      FileName(typing.Any):Name of file to saveCommentsTheere is no equivilent MFC method.  This is implemented in this module for performance reasons.

Returns:

      typing.Any
        
         """
         pass


class PyCScrollView(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetDeviceScrollPosition(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Returns the positon of the scroll bars in device units.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def GetDC(self,) -> 'PyCDC':
         """
         Gets the view's current DC.

Args:



Returns:

      PyCDC
        
         """
         pass


      def GetScrollPosition(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Returns the current position of the scroll bars (in logical units).

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def GetTotalSize(self,) -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Returns the total size of the view in logical units.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def OnCommand(self,wparam:'typing.Any',lparam:'typing.Any') -> 'None':
         """
         Calls the standard Python framework OnCommand handler

Args:

      wparam(typing.Any):
      lparam(typing.Any):See Also

Returns:

      None
        
         """
         pass


      def ResizeParentToFit(self,bShrinkOnly:'typing.Any'=1) -> 'typing.Any':
         """
         Lets the size of a view dictate the size of its frame window.

Args:

      bShrinkOnly(typing.Any):The kind of resizing to perform. The default value, TRUE, shrinks the frame window if appropriate.CommentsThis is recommended only for views in MDI child frame windows. Use ResizeParentToFit in the OnInitialUpdate handler function of your View class. You must ensure the parent's PyCFrameWnd::RecalcLayout is called before using this method.

Returns:

      typing.Any
        
         """
         pass


      def SetScaleToFitSize(self,size:'typing.Tuple[typing.Any, typing.Any]') -> 'None':
         """
         Scales the viewport size to the current window size automatically.

Args:

      size(typing.Tuple[typing.Any, typing.Any]):The horizontal and vertical sizes to which the view is to be scaled. The scroll view's size is measured in logical units.

Returns:

      None
        
         """
         pass


      def ScrollToPosition(self,position:'typing.Tuple[typing.Any, typing.Any]') -> 'None':
         """
         Scrolls to a given point in the view.

Args:

      position(typing.Tuple[typing.Any, typing.Any]):The position to scroll to.

Returns:

      None
        
         """
         pass


      def SetScrollSizes(self,mapMode:'typing.Any',sizeTotal:'typing.Tuple[typing.Any, typing.Any]',arg:'typing.Tuple[typing.Any, typing.Any]',arg1:'typing.Tuple[typing.Any, typing.Any]') -> 'None':
         """
         Sets the sizes of the scroll bars

Args:

      mapMode(typing.Any):The mapping mode for this view.
      sizeTotal(typing.Tuple[typing.Any, typing.Any]):The total size of the view.  Sizes are in logical units.  Both x and y must be greater than zero.
      arg(typing.Tuple[typing.Any, typing.Any]):The number of untils to scroll in response to a page-down command.
      arg1(typing.Tuple[typing.Any, typing.Any]):The number of untils to scroll in response to a line-down command.

Returns:

      None
        
         """
         pass


      def UpdateBars(self,) -> 'None':
         """
         Update the scroll bars state

Args:



Returns:

      None
        
         """
         pass


class PyCSliderCtrl(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateWindow(self,style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',parent:'PyCWnd',_id:'typing.Any') -> 'None':
         """
         Creates the actual control.

Args:

      style(typing.Any):The style for the control.
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The size and position of the control.
      parent(PyCWnd):The parent window of the control.  Usually a PyCDialog.
      _id(typing.Any):The control's ID.

Returns:

      None
        
         """
         pass


      def GetLineSize(self,) -> 'typing.Any':
         """
         Get the control's position

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetLineSize(self,nLineSize:'typing.Any'=1) -> 'typing.Any':
         """
         Set the control's line size.  Returns the previous line size.

Args:

      nLineSize(typing.Any):New line size of the Slider bar control

Returns:

      typing.Any
        
         """
         pass


      def GetPageSize(self,) -> 'typing.Any':
         """
         Get the control's position

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetPageSize(self,nPageSize:'typing.Any'=1) -> 'typing.Any':
         """
         Set the control's page size  Returns the previous page size.

Args:

      nPageSize(typing.Any):New page size of the Slider bar control.

Returns:

      typing.Any
        
         """
         pass


      def GetRangeMax(self,) -> 'typing.Any':
         """
         Get the control's Maximum

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetRangeMin(self,) -> 'typing.Any':
         """
         Get the control's Minimum

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetRange(self,) -> 'typing.Any':
         """
         Get the control's min and max

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetRange(self,nRangeMin:'typing.Any'=1,nRangeMax:'typing.Any'=1,bRedraw:'typing.Any'=1) -> 'typing.Any':
         """
         Set the control's min and max

Args:

      nRangeMin(typing.Any):New minimum of the Slider bar control.
      nRangeMax(typing.Any):New maximum of the Slider bar control.
      bRedraw(typing.Any):Should slider be redrawn?

Returns:

      typing.Any
        
         """
         pass


      def GetSelection(self,) -> 'typing.Any':
         """
         Get the control's selection start and end positions

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetSelection(self,nRangeMin:'typing.Any'=1,nRangeMax:'typing.Any'=1) -> 'typing.Any':
         """
         Set the control's selection start and end positions

Args:

      nRangeMin(typing.Any):New start of the Slider's selection.
      nRangeMax(typing.Any):New end of the Slider's selection.

Returns:

      typing.Any
        
         """
         pass


      def GetChannelRect(self,) -> 'typing.Any':
         """
         Get the control's channel rectangle

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetThumbRect(self,) -> 'typing.Any':
         """
         Get the control's thumb rectangle

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetPos(self,) -> 'typing.Any':
         """
         Get the control's position

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetPos(self,nPos:'typing.Any'=1) -> 'typing.Any':
         """
         Set the control's position

Args:

      nPos(typing.Any):New position of the Slider bar control.

Returns:

      typing.Any
        
         """
         pass


      def GetNumTics(self,) -> 'typing.Any':
         """
         Get number of tics in the slider

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetTicArray(self,) -> 'typing.Any':
         """
         Get a tuple of slider tic positions

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetTic(self,nTic:'typing.Any'=1) -> 'typing.Any':
         """
         Get the position of the specified tic number

Args:

      nTic(typing.Any):Zero based index of the tic mark

Returns:

      typing.Any
        
         """
         pass


      def GetTicPos(self,nTic:'typing.Any'=1) -> 'typing.Any':
         """
         Get the position of the specified tic number in client coordinates

Args:

      nTic(typing.Any):Zero based index of the tic mark

Returns:

      typing.Any
        
         """
         pass


      def SetTic(self,nTic:'typing.Any'=1) -> 'typing.Any':
         """
         Set a tic at the specified position

Args:

      nTic(typing.Any):Position of the desired tic mark

Returns:

      typing.Any
        
         """
         pass


      def SetTicFreq(self,nFreq:'typing.Any'=1) -> 'typing.Any':
         """
         Set the tic frequency

Args:

      nFreq(typing.Any):Frequency of tic marks

Returns:

      typing.Any
        
         """
         pass


      def ClearSel(self,bRedraw:'typing.Any'=1) -> 'typing.Any':
         """
         Clear the selection

Args:

      bRedraw(typing.Any):Redraw the control?

Returns:

      typing.Any
        
         """
         pass


      def VerifyPos(self,) -> 'typing.Any':
         """
         Verify the position is between configured min and max

Args:



Returns:

      typing.Any
        
         """
         pass


      def ClearTics(self,bRedraw:'typing.Any'=1) -> 'typing.Any':
         """
         Clear the control's tic marks

Args:

      bRedraw(typing.Any):Redraw the control?

Returns:

      typing.Any
        
         """
         pass


class PyCSpinButtonCtrl(object):
      """A windows spin button control.  Encapsulates an MFC CSpinButtonCtrl object."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPos(self,) -> 'typing.Any':
         """
         Obtains the current position for a spin button control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetPos(self,pos:'typing.Any') -> 'typing.Any':
         """
         Sets the current position for a spin button control.

Args:

      pos(typing.Any):The new position.Return ValueThe result is the previous position.

Returns:

      typing.Any:The new position.Return ValueThe result is the previous position.

        
         """
         pass


      def SetRange(self,) -> 'typing.Any':
         """
         Sets the upper and lower limits (range) for a spin button control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetRange32(self,) -> 'typing.Any':
         """
         Sets the 32 bit upper and lower limits (range) for a spin button control.

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCSplitterWnd(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPane(self,row:'typing.Any',col:'typing.Any') -> 'PyCWnd':
         """
         None

Args:

      row(typing.Any):The row in the splitter.
      col(typing.Any):The column in the splitter.CommentsTheoretically the return value can be a PyCWnd object, but currently it will always be a PyCView or derived object.

Returns:

      PyCWnd
        
         """
         pass


      def CreateView(self,view:'PyCView',row:'typing.Any',col:'typing.Any',arg:'typing.Tuple[typing.Any, typing.Any]') -> 'None':
         """
         Creates a view in a splitter window

Args:

      view(PyCView):The view to place in the splitter pane.
      row(typing.Any):The row in the splitter to place the view.
      col(typing.Any):The column in the splitter to place the view.
      arg(typing.Tuple[typing.Any, typing.Any]):The initial size of the new view.MFC References

Returns:

      None
        
         """
         pass


      def CreateStatic(self,parent:'typing.Any',rows:'typing.Any',cols:'typing.Any',style:'typing.Any',_id:'typing.Any') -> 'None':
         """
         Creates a static splitter window.

Args:

      parent(typing.Any):The parent window.
      rows(typing.Any):The number of rows in the splitter.
      cols(typing.Any):The number of columns in the splitter.
      style(typing.Any):Specifies the window style
      _id(typing.Any):The child window ID of the window. The ID can be AFX_IDW_PANE_FIRST unless the splitter window is nested inside another splitter window.CommentsA static splitter window is a splitter where the number of panes are fixed at window creation time.  Currently this is the only splitter window supported by win32ui.MFC References

Returns:

      None
        
         """
         pass


      def SetColumnInfo(self,column:'typing.Any',ideal:'typing.Any',_min:'typing.Any') -> 'None':
         """
         Sets a new minimum height and ideal height for a column

Args:

      column(typing.Any):The column in the splitter.
      ideal(typing.Any):Specifies an ideal height for the splitter window column in pixels.
      _min(typing.Any):Specifies a minimum height for the splitter window column in pixels.

Returns:

      None
        
         """
         pass


      def SetRowInfo(self,row:'typing.Any',ideal:'typing.Any',_min:'typing.Any') -> 'None':
         """
         Sets a new minimum height and ideal height for a row.

Args:

      row(typing.Any):The row in the splitter.
      ideal(typing.Any):Specifies an ideal height for the splitter window row in pixels.
      _min(typing.Any):Specifies a minimum height for the splitter window row in pixels.

Returns:

      None
        
         """
         pass


      def IdFromRowCol(self,row:'typing.Any',col:'typing.Any') -> 'None':
         """
         Gets the child window ID for the specified child.

Args:

      row(typing.Any):The row in the splitter.
      col(typing.Any):The col in the splitter

Returns:

      None
        
         """
         pass


      def DoKeyboardSplit(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCStatusBar(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetPaneInfo(self,index:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Returns the id, style, and width of the indicator pane at the 

location specified by index.

Args:

      index(typing.Any):Index of the pane whose information is to be retrieved.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetStatusBarCtrl(self,) -> 'PyCStatusBarCtrl':
         """
         Gets the statusbar control object for the statusbar.

Args:



Returns:

      PyCStatusBarCtrl
        
         """
         pass


      def SetIndicators(self,indicators:'typing.Any') -> 'None':
         """
         Sets each indicator's ID.

Args:

      indicators(typing.Any):A tuple containing the ID's of the indicators.

Returns:

      None
        
         """
         pass


      def SetPaneInfo(self,index:'typing.Any',_id:'typing.Any',style:'typing.Any',width:'typing.Any') -> 'None':
         """
         Sets the specified indicator pane to a new ID, style, and width.

Args:

      index(typing.Any):Index of the indicator pane whose style is to be set.
      _id(typing.Any):New ID for the indicator pane.
      style(typing.Any):New style for the indicator pane.The following indicator styles are supported:afxres.SBPS_NOBORDERS - No 3-D border around the pane.afxres.SBPS_POPOUT - Reverse border so that text "pops out."afxres.SBPS_DISABLED - Do not draw text.afxres.SBPS_STRETCH - Stretch pane to fill unused space. Only one pane per status bar can have this style.afxres.SBPS_NORMAL - No stretch, borders, or pop-out.
      width(typing.Any):New width for the indicator pane.MFC References

Returns:

      None
        
         """
         pass


class PyCStatusBarCtrl(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateWindow(self,style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',parent:'PyCWnd',_id:'typing.Any') -> 'None':
         """
         Creates the actual control.

Args:

      style(typing.Any):The style for the control.
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The size and position of the control.
      parent(PyCWnd):The parent window of the control.  Usually a PyCDialog.
      _id(typing.Any):The control's ID.

Returns:

      None
        
         """
         pass


      def GetBorders(self,) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any]':
         """
         Retrieve the status bar control's current widths of 

the horizontal and vertical borders and of the space between rectangles.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetParts(self,nParts:'typing.Any') -> 'typing.Any':
         """
         Retrieve coordinates of the parts in a status bar control.

Args:

      nParts(typing.Any):The number of coordinates to retrieveCommentsThis function, as designed in MFC, returns both the *number* of parts, and, through an OUT parameter, an array of ints giving the coordinates of the parts.  There is also an IN parameter saying how many coordinates to give back.  Here, we're explicitly changing the semantics a bit.GetParts() -&gt Tuple of all coordinates GetParts(n) -&gt Tuple of the first n coordinates (or all coordinates, if fewer than n)So, in Python, you can't simultaneously find out how many coordinates there are, and retrieve a subset of them.  In a reasonable universe, there would have been GetParts() -&gt int, and GetCoords() -&gt List.  This means that I need to call the MFC method twice; once to find out how many there are, and another time to get them.

Returns:

      typing.Any
        
         """
         pass


      def GetRect(self,nPane:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Retrieves the bounding rectangle of a part in a status 

bar control.

Args:

      nPane(typing.Any):Zero-based index of the part whose bounding rectangle is to be retrieved.

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetText(self,nPane:'typing.Any') -> 'typing.Any':
         """
         Retrieve the text from the given part of a status bar control.

Args:

      nPane(typing.Any):Zero-based index of the part whose text is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def GetTextAttr(self,nPane:'typing.Any') -> 'typing.Any':
         """
         Retrieve the attributes of the text in the given part of a status bar 

control.

Args:

      nPane(typing.Any):Zero-based index of the part whose text is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def GetTextLength(self,nPane:'typing.Any') -> 'typing.Any':
         """
         Retrieve the length the text in the given part of a status bar control.

Args:

      nPane(typing.Any):Zero-based index of the part whose text is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def SetMinHeight(self,nHeight:'typing.Any') -> 'None':
         """
         Set the minimum height of a status bar control's drawing area.

Args:

      nHeight(typing.Any):Minimum height

Returns:

      None
        
         """
         pass


      def SetParts(self,coord:'typing.Any') -> 'None':
         """
         Sets the number of parts in a status bar control and the coordinate of the right 

edge of each part.

Args:

      coord(typing.Any):Coordinates of each part

Returns:

      None
        
         """
         pass


      def SetText(self,text:'str',nPane:'typing.Any',nType:'typing.Any') -> 'None':
         """
         Set the text in the given part of a status bar control.

Args:

      text(str):The text to display
      nPane(typing.Any):Zero-based index of the part to set.
      nType(typing.Any):Type of drawing operation.CommentsThe drawing type can be set to one of:~ 0 - The text is drawn with a border to appear lower than the plane of the status bar.~ win32con.SBT_NOBORDERS - The text is drawn without borders.~ win32con.SBT_OWNERDRAW - The text is drawn by the parent window.~ win32con.SBT_POPOUT - The text is drawn with a border to appear higher than the plane of the status bar.

Returns:

      None
        
         """
         pass


      def SetTipText(self,nPane:'typing.Any',text:'str') -> 'None':
         """
         Sets the tooltip text for a pane in a status bar. The status bar must have 

been created with the afxres.SBT_TOOLTIPS control style to enable ToolTips.

Args:

      nPane(typing.Any):The zero-based index of status bar pane to receive the tooltip text.
      text(str):The string containing the tooltip text.CommentsPay attention, this tooltip text is ONLY displayed in two situations: 1. When the corresponding pane in the status bar contains only an icon. 2. When the corresponding pane in the status bar contains text that is truncated due to the size of the pane. To make the tooltip appear even if the text is not truncated, you could add additional spaces to the end of the pane text.MFC References

Returns:

      None
        
         """
         pass


class PyCTabCtrl(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetCurSel(self,) -> 'typing.Any':
         """
         Gets the current selection of a tab control.

Args:



Returns:

      typing.Any:PyCTabCtrl.GetCurSel

int = GetCurSel()Gets the current selection of a tab control.
Return ValueThe zero-based index of the currently selected item, or -1 if no selection.

        
         """
         pass


      def GetItemCountl(self,) -> 'typing.Any':
         """
         Returns the number of tabs in the control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetCurSel(self,index:'typing.Any') -> 'typing.Any':
         """
         Sets the current selection of a tab control.

Args:

      index(typing.Any):The index of the tab to set current.Return ValueThe zero-based index of the previously selected item.

Returns:

      typing.Any:The index of the tab to set current.Return ValueThe zero-based index of the previously selected item.

        
         """
         pass


class PyCToolBar(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetButtonStyle(self,index:'typing.Any') -> 'None':
         """
         Retrieves the style for a button.

Args:

      index(typing.Any):Index of the item whose style is to be retrieved.

Returns:

      None
        
         """
         pass


      def GetButtonText(self,index:'typing.Any') -> 'str':
         """
         Gets the text for a button.

Args:

      index(typing.Any):Index of the item whose text is to be retrieved.

Returns:

      str
        
         """
         pass


      def GetItemID(self,index:'typing.Any') -> 'None':
         """
         Returns the command ID of a button or separator at the given index.

Args:

      index(typing.Any):Index of the item whose ID is to be retrieved.

Returns:

      None
        
         """
         pass


      def SetButtonInfo(self,index:'typing.Any',ID:'typing.Any',style:'typing.Any',imageIx:'typing.Any') -> 'None':
         """
         Sets the button's command ID, style, and image number.

Args:

      index(typing.Any):Index of the button or separator whose information is to be set.
      ID(typing.Any):The value to which the button's command ID is set.
      style(typing.Any):The new button style
      imageIx(typing.Any):New index for the button's image within the bitmap

Returns:

      None
        
         """
         pass


      def GetToolBarCtrl(self,) -> 'PyCToolBarCtrl':
         """
         Gets the toolbar control object for the toolbar

Args:



Returns:

      PyCToolBarCtrl
        
         """
         pass


      def LoadBitmap(self,_id:'PyResourceId') -> 'None':
         """
         Loads the bitmap containing bitmap-button images.

Args:

      _id(PyResourceId):Name or id of the resource that contains the bitmap.CommentsThe bitmap should contain one image for each toolbar button. If the images are not of the standard size (16 pixels wide and 15 pixels high), call PyCToolBar::SetSizes to set the button sizes and their images.

Returns:

      None
        
         """
         pass


      def LoadToolBar(self,_id:'PyResourceId') -> 'None':
         """
         Loads a toolbar from a toolbar resource.

Args:

      _id(PyResourceId):Name or resource id of the resourceCommentsThe bitmap should contain one image for each toolbar button. If the images are not of the standard size (16 pixels wide and 15 pixels high), call PyCToolBar::SetSizes to set the button sizes and their images.

Returns:

      None
        
         """
         pass


      def SetBarStyle(self,style:'typing.Any') -> 'None':
         """
         Sets the toolbar part of style

Args:

      style(typing.Any):The toolbar style to set.

Returns:

      None
        
         """
         pass


      def SetBitmap(self,hBitmap:'typing.Any') -> 'None':
         """
         Sets a bitmapped image.

Args:

      hBitmap(typing.Any):The handle to a bitmap resource.CommentsCall this method to set the bitmap image for the toolbar. For example, call SetBitmap to change the bitmapped image after the user takes an action on a document that changes the action of a button.

Returns:

      None
        
         """
         pass


      def SetButtons(self,buttons:'typing.Any',numButtons:'typing.Any') -> 'None':
         """
         Sets button styles and an index of button images within the bitmap.

Args:

      buttons(typing.Any):A tuple containing the ID's of the buttons.Alternative Parameters
      numButtons(typing.Any):The number of buttons to pre-allocate.  If this option is used, then PyCToolBar::PySetButtonInfo must be used.

Returns:

      None
        
         """
         pass


      def SetButtonStyle(self,index:'typing.Any',style:'typing.Any') -> 'None':
         """
         Sets the style for a button.

Args:

      index(typing.Any):Index of the item whose style is to be set
      style(typing.Any):The new style

Returns:

      None
        
         """
         pass


      def SetHeight(self,height:'typing.Any') -> 'None':
         """
         Sets the height of the toolbar.

Args:

      height(typing.Any):The height in pixels of the toolbar.

Returns:

      None
        
         """
         pass


      def SetSizes(self,sizeButton:'typing.Tuple[typing.Any, typing.Any]',sizeButton1:'typing.Tuple[typing.Any, typing.Any]') -> 'None':
         """
         Sets the size of each button.

Args:

      sizeButton(typing.Tuple[typing.Any, typing.Any]):The size of each button.
      sizeButton1(typing.Tuple[typing.Any, typing.Any]):The size of each bitmap.

Returns:

      None
        
         """
         pass


class PyCToolBarCtrl(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddBitmap(self,numButtons:'typing.Any',bitmap:'typing.Any') -> 'typing.Any':
         """
         Add one or more button images to the list of button images

Args:

      numButtons(typing.Any):Number of button images in the bitmap.
      bitmap(typing.Any):Bitmap containing button or buttons to be addedMFC References

Returns:

      typing.Any
        
         """
         pass


      def AddButtons(self,) -> 'typing.Any':
         """
         Add one or more buttons to the toolbar

Args:



Returns:

      typing.Any
        
         """
         pass


      def AddStrings(self,strings:'typing.Any') -> 'typing.Any':
         """
         Add one or more strings to the toolbar

Args:

      strings(typing.Any):Strings to add. Can give more than one string.

Returns:

      typing.Any
        
         """
         pass


      def AutoSize(self,) -> 'None':
         """
         Resize the entire toolbar control

Args:



Returns:

      None
        
         """
         pass


      def CheckButton(self,nID:'typing.Any',bCheck:'typing.Any'=1) -> 'typing.Any':
         """
         Check or clear a given button in a toolbar control

Args:

      nID(typing.Any):Command identifier of the button to check or clear.
      bCheck(typing.Any):1 to check, 0 to clear the buttonMFC References

Returns:

      typing.Any
        
         """
         pass


      def CommandToIndex(self,nID:'typing.Any') -> 'typing.Any':
         """
         Retrieve the zero-based index for the button associated with the 

specified command identifier.

Args:

      nID(typing.Any):Command identifier of the button you want to find.MFC References

Returns:

      typing.Any
        
         """
         pass


      def CreateWindow(self,style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',parent:'PyCWnd',_id:'typing.Any') -> 'None':
         """
         Creates the window for a new toolbar object

Args:

      style(typing.Any):The style for the button.  Use any of the win32con.BS_* constants.
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The size and position of the button.
      parent(PyCWnd):The parent window of the button.  Usually a PyCDialog.
      _id(typing.Any):The buttons control ID.MFC References

Returns:

      None
        
         """
         pass


      def Customize(self,) -> 'None':
         """
         Display the Customize Toolbar dialog box.

Args:



Returns:

      None
        
         """
         pass


      def DeleteButton(self,nID:'typing.Any') -> 'None':
         """
         Delete a button from the toolbar control.

Args:

      nID(typing.Any):ID of the button to delete.MFC References

Returns:

      None
        
         """
         pass


      def EnableButton(self,nID:'typing.Any',bEnable:'typing.Any'=1) -> 'None':
         """
         Enable or disable a toolbar control button.

Args:

      nID(typing.Any):ID of the button to enable or disable.
      bEnable(typing.Any):1 to enable, 0 to disableMFC References

Returns:

      None
        
         """
         pass


      def GetBitmapFlags(self,) -> 'typing.Any':
         """
         retrieve the bitmap flags from the toolbar.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetButton(self,nID:'typing.Any') -> 'typing.Any':
         """
         Retrieve information about the specified button in a 

toolbar control.

Args:

      nID(typing.Any):ID of the button to retrieve.MFC References

Returns:

      typing.Any
        
         """
         pass


      def GetButtonCount(self,) -> 'typing.Any':
         """
         Retrieve a count of the buttons currently in the toolbar control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetItemRect(self,nID:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Retrieve the bounding rectangle of a button in a 

toolbar control.

Args:

      nID(typing.Any):ID of the button.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetRows(self,) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Retrieve the number of rows of buttons currently displayed

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def HideButton(self,nID:'typing.Any',bEnable:'typing.Any'=1) -> 'None':
         """
         Hide or show the specified button in a toolbar control.

Args:

      nID(typing.Any):ID of the button to hide.
      bEnable(typing.Any):1 to hide, 0 to show.MFC References

Returns:

      None
        
         """
         pass


      def Indeterminate(self,nID:'typing.Any',bEnable:'typing.Any'=1) -> 'None':
         """
         Mark or unmark the specified button as indeterminate

Args:

      nID(typing.Any):ID of the button to mark.
      bEnable(typing.Any):1 to hide, 0 to show.MFC References

Returns:

      None
        
         """
         pass


      def InsertButton(self,nID:'typing.Any',button:'PyCToolBarCtrl') -> 'typing.Any':
         """
         Insert a button in a toolbar control.

Args:

      nID(typing.Any):Zero-based index of a button. This function inserts the new button to the left of this button.
      button(PyCToolBarCtrl):Bitmap containing button to be insertedCommentsThe image and/or string whose index you provide must have previously been added to the toolbar control's list using PyCToolBarCtrl::AddBitmap, PyCToolBarCtrl::AddString, and/or PyCToolBarCtrl::AddStrings.MFC References

Returns:

      typing.Any
        
         """
         pass


      def IsButtonChecked(self,nID:'typing.Any') -> 'typing.Any':
         """
         Determine whether the specified button in a toolbar control is checked.

Args:

      nID(typing.Any):ID of the button to check.MFC References

Returns:

      typing.Any
        
         """
         pass


      def IsButtonEnabled(self,nID:'typing.Any') -> 'typing.Any':
         """
         Determine whether the specified button in a toolbar control is enabled.

Args:

      nID(typing.Any):ID of the button to check.MFC References

Returns:

      typing.Any
        
         """
         pass


      def IsButtonHidden(self,nID:'typing.Any') -> 'typing.Any':
         """
         Determine whether the specified button in a toolbar control is hidden.

Args:

      nID(typing.Any):ID of the button to check.MFC References

Returns:

      typing.Any
        
         """
         pass


      def IsButtonIndeterminate(self,nID:'typing.Any') -> 'typing.Any':
         """
         Determine whether the specified button in a toolbar control is 

indeterminate.

Args:

      nID(typing.Any):ID of the button to check.MFC References

Returns:

      typing.Any
        
         """
         pass


      def IsButtonPressed(self,nID:'typing.Any') -> 'typing.Any':
         """
         Determine whether the specified button in a toolbar control is pressed.

Args:

      nID(typing.Any):ID of the button to check.MFC References

Returns:

      typing.Any
        
         """
         pass


      def PressButton(self,nID:'typing.Any',bEnable:'typing.Any'=1) -> 'None':
         """
         Mark or unmark the specified button as pressed.

Args:

      nID(typing.Any):ID of the button to mark.
      bEnable(typing.Any):1 to mark, 0 to unmark.MFC References

Returns:

      None
        
         """
         pass


      def SetBitmapSize(self,width1:'typing.Any',height1:'typing.Any',width:'typing.Any'=16,height:'typing.Any'=15) -> 'None':
         """
         Set the size of the actual bitmapped images to be added to a toolbar control.

Args:

      width1(typing.Any):Width of bitmap images.
      height1(typing.Any):Height of bitmap images.MFC References
      width(typing.Any):Width of bitmap images.
      height(typing.Any):Height of bitmap images.Alternative Parameters

Returns:

      None
        
         """
         pass


      def SetButtonSize(self,width1:'typing.Any',height1:'typing.Any',width:'typing.Any'=16,height:'typing.Any'=15) -> 'None':
         """
         Set the size of the buttons to be added to a toolbar control.

Args:

      width1(typing.Any):Width of bitmap images.
      height1(typing.Any):Height of bitmap images.MFC References
      width(typing.Any):Width of buttons
      height(typing.Any):Height of buttonsAlternative Parameters

Returns:

      None
        
         """
         pass


      def SetCmdID(self,nIndex:'typing.Any',nID:'typing.Any') -> 'None':
         """
         Set the command identifier which will be sent to the owner window when the 

specified button is pressed.

Args:

      nIndex(typing.Any):The zero-based index of the button whose command ID is to be set.
      nID(typing.Any):The command ID to set the selected button to.MFC References

Returns:

      None
        
         """
         pass


      def SetRows(self,nRows:'typing.Any',bLarger:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Ask the toolbar control to resize itself to the requested 

number of rows.

Args:

      nRows(typing.Any):Requested number of rows.
      bLarger(typing.Any):Tells whether to use more rows or fewer rows if the toolbar cannot be resized to the requested number of rows.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


class PyCToolTipCtrl(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateWindow(self,parent:'PyCWnd',style:'typing.Any') -> 'None':
         """
         Creates the actual control.

Args:

      parent(PyCWnd):The parent window of the control.
      style(typing.Any):The style for the control.

Returns:

      None
        
         """
         pass


      def UpdateTipText(self,text:'str',wnd:'PyCWnd',_id:'typing.Any') -> 'None':
         """
         Update the tool tip text for a control's tools

Args:

      text(str):The text for the tool.
      wnd(PyCWnd):The window of the tool.
      _id(typing.Any):The id of the tool

Returns:

      None
        
         """
         pass


      def AddTool(self,wnd:'PyCWnd',text:'str',_id:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]'=None) -> 'None':
         """
         Adds a tool to tooltip control.

Args:

      wnd(PyCWnd):The window of the tool.
      text(str):The text for the tool.
      _id(typing.Any):The id of the tool
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The default rectangle

Returns:

      None
        
         """
         pass


      def SetMaxTipWidth(self,width:'typing.Any') -> 'typing.Any':
         """
         None

Args:

      width(typing.Any):The new width

Returns:

      typing.Any
        
         """
         pass


class PyCTreeCtrl(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateWindow(self,style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',PyCWnd:'typing.Any',_id:'typing.Any') -> 'None':
         """
         Creates the actual window for the object.

Args:

      style(typing.Any):The window style
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The default rectangle
      PyCWnd(typing.Any):The parent window
      _id(typing.Any):The control IDMFC References

Returns:

      None
        
         """
         pass


      def GetCount(self,) -> 'typing.Any':
         """
         Retrieves the number of tree items associated with a tree view control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetIndent(self,) -> 'typing.Any':
         """
         Retrieves the offset (in pixels) of a tree view item from its parent.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetIndent(self,indent:'typing.Any') -> 'None':
         """
         Sets the offset (in pixels) of a tree view item from its parent.

Args:

      indent(typing.Any):The new indent.

Returns:

      None
        
         """
         pass


      def GetImageList(self,nImageList:'typing.Any') -> 'PyCImageList':
         """
         Retrieves the current image list.

Args:

      nImageList(typing.Any):Value specifying which image list to retrieve. It can be one of: -	commctrl.LVSIL_NORMAL   Image list with large icons. -	commctrl.LVSIL_SMALL   Image list with small icons. -	commctrl.LVSIL_STATE   Image list with state images.

Returns:

      PyCImageList
        
         """
         pass


      def SetImageList(self,imageList:'PyCImageList',imageType:'typing.Any') -> 'typing.Any':
         """
         Assigns an image list to a list view control.

Args:

      imageList(PyCImageList):The Image List to use.
      imageType(typing.Any):Type of image list. It can be one of (COMMCTRL.) LVSIL_NORMAL, LVSIL_SMALL or LVSIL_STATE

Returns:

      typing.Any
        
         """
         pass


      def GetNextItem(self,item:'typing.Any',code:'typing.Any') -> 'typing.Any':
         """
         Retrieves the next item.

Args:

      item(typing.Any):The specified item
      code(typing.Any):Specifies the relationship of the item to fetch.

Returns:

      typing.Any
        
         """
         pass


      def ItemHasChildren(self,item:'typing.Any') -> 'typing.Any':
         """
         Returns nonzero if the specified item has child items.

Args:

      item(typing.Any):The specified item

Returns:

      typing.Any
        
         """
         pass


      def GetChildItem(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the first child item.

Args:

      item(typing.Any):The specified item

Returns:

      typing.Any
        
         """
         pass


      def GetNextSiblingItem(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the next sibling of the specified tree view item.

Args:

      item(typing.Any):The specified item

Returns:

      typing.Any
        
         """
         pass


      def GetPrevSiblingItem(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the previous sibling of the specified tree view item.

Args:

      item(typing.Any):The specified item

Returns:

      typing.Any
        
         """
         pass


      def GetParentItem(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the parent item of the specified tree view item.

Args:

      item(typing.Any):The specified item

Returns:

      typing.Any
        
         """
         pass


      def GetFirstVisibleItem(self,) -> 'typing.Any':
         """
         Retrieves the first visible item of the tree view control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetNextVisibleItem(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the next visible item of the specified tree view item.

Args:

      item(typing.Any):The specified item

Returns:

      typing.Any
        
         """
         pass


      def GetSelectedItem(self,) -> 'typing.Any':
         """
         Retrieves the currently selected tree view item.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetDropHilightItem(self,) -> 'typing.Any':
         """
         Retrieves the target of a drag-and-drop operation.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetRootItem(self,) -> 'typing.Any':
         """
         Retrieves the root of the specified tree view item.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetToolTips(self,) -> 'typing.Any':
         """
         Returns the tooltip control

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetItem(self,item:'typing.Any',arg:'typing.Any') -> 'TV_ITEM':
         """
         Retrieves the details of an items attributes.

Args:

      item(typing.Any):The item whose attributes are to be retrieved.
      arg(typing.Any):The requested attributes.

Returns:

      TV_ITEM
        
         """
         pass


      def SetItem(self,item:'TV_ITEM') -> 'typing.Any':
         """
         Sets some of all of an items attributes.

Args:

      item(TV_ITEM):A tuple describing the new item.

Returns:

      typing.Any
        
         """
         pass


      def GetItemState(self,item:'typing.Any',stateMask:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Retrieves the state and mask of an item.

Args:

      item(typing.Any):The specified item
      stateMask(typing.Any):The mask for the result.

Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def SetItemState(self,item:'typing.Any',state:'typing.Any',stateMask:'typing.Any') -> 'None':
         """
         Sets the state of item.

Args:

      item(typing.Any):The specified item
      state(typing.Any):The new state
      stateMask(typing.Any):The mask for the new state

Returns:

      None
        
         """
         pass


      def GetItemImage(self,item:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Retrieves the index of an items images.

Args:

      item(typing.Any):The specified item

Returns:

      typing.Tuple[typing.Any, typing.Any]
        
         """
         pass


      def SetItemImage(self,item:'typing.Any',iImage:'typing.Any',iSelectedImage:'typing.Any') -> 'None':
         """
         Sets the index of an items images.

Args:

      item(typing.Any):The specified item
      iImage(typing.Any):The offset of the image.
      iSelectedImage(typing.Any):The offset of the selected image.

Returns:

      None
        
         """
         pass


      def SetItemText(self,item:'typing.Any',text:'str') -> 'typing.Any':
         """
         Changes the text of a list view item or subitem.

Args:

      item(typing.Any):The item whose text is to be retrieved.
      text(str):String that contains the new item text.

Returns:

      typing.Any
        
         """
         pass


      def GetItemText(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the text of a list view item or subitem.

Args:

      item(typing.Any):The item whose text is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def GetItemData(self,item:'typing.Any') -> 'typing.Any':
         """
         Retrieves the application-specific value associated with an item.

Args:

      item(typing.Any):The index of the item whose data is to be retrieved.

Returns:

      typing.Any
        
         """
         pass


      def SetItemData(self,item:'typing.Any',Data:'typing.Any') -> 'typing.Any':
         """
         Sets the item's application-specific value.

Args:

      item(typing.Any):The item whose Data is to be set.
      Data(typing.Any):New value for the data.CommentsNote that a reference count is not added to the object.  This it is your responsibility to make sure the object remains alive while in the list.

Returns:

      typing.Any
        
         """
         pass


      def GetItemRect(self,item:'typing.Any',bTextOnly:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Retrieves the bounding rectangle of a tree view item.

Args:

      item(typing.Any):The item whose Data is to be set.
      bTextOnly(typing.Any):f this parameter is nonzero, the bounding rectangle includes only the text of the item. Otherwise it includes the entire line that the item occupies in the tree view control.

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetEditControl(self,) -> 'PyCEdit':
         """
         Retrieves the handle of the edit control used to edit the specified 

tree view item.

Args:



Returns:

      PyCEdit
        
         """
         pass


      def GetVisibleCount(self,) -> 'typing.Any':
         """
         Retrieves the number of visible tree items associated with a tree view 

control.

Args:



Returns:

      typing.Any
        
         """
         pass


      def InsertItem(self,hParent:'typing.Any',hInsertAfter:'typing.Any',item:'TV_ITEM',mask:'typing.Any',text:'typing.Any',image:'typing.Any',selectedImage:'typing.Any',state:'typing.Any',stateMask:'typing.Any',lParam:'typing.Any',parent:'typing.Any',parent1:'typing.Any',text1:'typing.Any',image1:'typing.Any',selectedImage1:'typing.Any',parent2:'typing.Any',insertAfter:'typing.Any',text2:'typing.Any',parent3:'typing.Any',parent4:'typing.Any') -> 'typing.Any':
         """
         Inserts an item into the list.

Args:

      hParent(typing.Any):The parent item.  If commctrl.TVI_ROOT or 0, it is added to the root.
      hInsertAfter(typing.Any):The item to insert after.  Can be an item or TVI_FIRST, TVI_LAST or TVI_SORT
      item(TV_ITEM):A tuple describing the new item.Alternative Parameters
      mask(typing.Any):Integer specifying which attributes to set
      text(typing.Any):The text of the item.
      image(typing.Any):The index of the image to use.
      selectedImage(typing.Any):The index of the items selected image.
      state(typing.Any):The initial state of the item.
      stateMask(typing.Any):Specifies which bits of the state are valid.
      lParam(typing.Any):A user defined object for the item.
      parent(typing.Any):The parent of the item.
      parent1(typing.Any):The parent of the item.Alternative Parameters
      text1(typing.Any):The text for the item.
      image1(typing.Any):The index of the image to use.
      selectedImage1(typing.Any):The index of the items selected image.
      parent2(typing.Any):The parent of the item.
      insertAfter(typing.Any):The item to insert the new item after, or TVI_FIRST, TVI_LAST or TVI_SORTAlternative Parameters
      text2(typing.Any):The text for the item.
      parent3(typing.Any):The parent of the item.
      parent4(typing.Any):The parent of the item.

Returns:

      typing.Any
        
         """
         pass


      def DeleteItem(self,item:'typing.Any') -> 'None':
         """
         Deletes the specified item.

Args:

      item(typing.Any):The specified item

Returns:

      None
        
         """
         pass


      def DeleteAllItems(self,) -> 'typing.Any':
         """
         Deletes all items in the control

Args:



Returns:

      typing.Any
        
         """
         pass


      def Expand(self,item:'typing.Any',code:'typing.Any') -> 'None':
         """
         Expands, or collapses, the child items of the specified tree view item.

Args:

      item(typing.Any):The specified item
      code(typing.Any):The action to take

Returns:

      None
        
         """
         pass


      def Select(self,item:'typing.Any',code:'typing.Any') -> 'None':
         """
         Selects, scrolls into view, or redraws a specified tree view item.

Args:

      item(typing.Any):The specified item
      code(typing.Any):The action to take

Returns:

      None
        
         """
         pass


      def SelectItem(self,item:'typing.Any') -> 'None':
         """
         Selects a specified tree view item.

Args:

      item(typing.Any):The specified item

Returns:

      None
        
         """
         pass


      def SelectDropTarget(self,item:'typing.Any') -> 'None':
         """
         Redraws the tree item as the target of a drag-and-drop operation.

Args:

      item(typing.Any):The specified item

Returns:

      None
        
         """
         pass


      def SelectSetFirstVisible(self,item:'typing.Any') -> 'None':
         """
         Selects a specified tree view item as the first visible item.

Args:

      item(typing.Any):The specified item

Returns:

      None
        
         """
         pass


      def EditLabel(self,item:'typing.Any') -> 'PyCEdit':
         """
         Edits a specified tree view item in-place.

Args:

      item(typing.Any):The item to edit.

Returns:

      PyCEdit
        
         """
         pass


      def CreateDragImage(self,item:'typing.Any') -> 'PyCImageList':
         """
         Creates a dragging bitmap for the specified tree view item.

Args:

      item(typing.Any):The item to edit.

Returns:

      PyCImageList
        
         """
         pass


      def SortChildren(self,item:'typing.Any') -> 'None':
         """
         Sorts the children of a given parent item.

Args:

      item(typing.Any):The specified parent item

Returns:

      None
        
         """
         pass


      def EnsureVisible(self,item:'typing.Any') -> 'typing.Any':
         """
         Ensures that a tree view item is visible in its tree view control.

Args:

      item(typing.Any):The item to edit.

Returns:

      typing.Any
        
         """
         pass


      def HitTest(self,arg:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Determines which tree view item, if any, is at a specified position.

Args:

      arg(typing.Any):The point to test.Return ValueThe result is a tuple of (flags, hItem). flags may be a combination of the following values:ValueDescriptioncommctrl.TVHT_ABOVEAbove the client area.commctrl.TVHT_BELOWBelow the client area.commctrl.TVHT_NOWHEREIn the client area, but below the last item.commctrl.TVHT_ONITEMOn the bitmap or label associated with an item.commctrl.TVHT_ONITEMBUTTONOn the button associated with an item.commctrl.TVHT_ONITEMICONOn the bitmap associated with an item.commctrl.TVHT_ONITEMINDENTIn the indentation associated with an item.commctrl.TVHT_ONITEMLABELOn the label (string) associated with an item.commctrl.TVHT_ONITEMRIGHTIn the area to the right of an item.commctrl.TVHT_ONITEMSTATEICONOn the state icon for a tree view item that is in a user-defined state.commctrl.TVHT_TOLEFTTo the left of the client area.commctrl.TVHT_TORIGHTTo the right of the client area.

Returns:

      typing.Tuple[typing.Any, typing.Any]:The point to test.Return ValueThe result is a tuple of (flags, hItem). 

flags may be a combination of the following values:



Value


Description



commctrl.TVHT_ABOVEAbove the client area.
commctrl.TVHT_BELOWBelow the client area.
commctrl.TVHT_NOWHEREIn the client area, but below the last item.
commctrl.TVHT_ONITEMOn the bitmap or label associated with an item.
commctrl.TVHT_ONITEMBUTTONOn the button associated with an item.
commctrl.TVHT_ONITEMICONOn the bitmap associated with an item.
commctrl.TVHT_ONITEMINDENTIn the indentation associated with an item.
commctrl.TVHT_ONITEMLABELOn the label (string) associated with an item.
commctrl.TVHT_ONITEMRIGHTIn the area to the right of an item.
commctrl.TVHT_ONITEMSTATEICONOn the state icon for a tree view item that is in a user-defined state.
commctrl.TVHT_TOLEFTTo the left of the client area.
commctrl.TVHT_TORIGHTTo the right of the client area.

        
         """
         pass


class PyCTreeView(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def PreCreateWindow(self,createStruct:'typing.Any') -> 'typing.Any':
         """
         Calls the underlying MFC PreCreateWindow method.

Args:

      createStruct(typing.Any):A tuple representing a CREATESTRUCT structure.

Returns:

      typing.Any
        
         """
         pass


      def GetTreeCtrl(self,) -> 'PyCTreeCtrl':
         """
         Returns the underlying tree control object.

Args:



Returns:

      PyCTreeCtrl
        
         """
         pass


      def OnCommand(self,wparam:'typing.Any',lparam:'typing.Any') -> 'None':
         """
         Calls the standard Python framework OnCommand handler

Args:

      wparam(typing.Any):
      lparam(typing.Any):See Also

Returns:

      None
        
         """
         pass


class PyCView(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateWindow(self,parent:'PyCWnd',arg:'typing.Any',arg1:'typing.Any',arg2:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]') -> 'None':
         """
         Creates the window for a view.

Args:

      parent(PyCWnd):The parent window (usually a frame)
      arg(typing.Any):The child ID for the view
      arg1(typing.Any):The style for the view
      arg2(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The default position of the window.

Returns:

      None
        
         """
         pass


      def GetDocument(self,) -> 'PyCDocument':
         """
         Returns the document for a view.

Args:



Returns:

      PyCDocument
        
         """
         pass


      def OnActivateView(self,activate:'typing.Any',activateView:'PyCView',DeactivateView:'PyCView') -> 'typing.Any':
         """
         Calls the underlying MFC OnActivateView method.

Args:

      activate(typing.Any):Indicates whether the view is being activated or deactivated.
      activateView(PyCView):The view object that is being activated.
      DeactivateView(PyCView):The view object that is being deactivated.See Also

Returns:

      typing.Any
        
         """
         pass


      def OnInitialUpdate(self,) -> 'None':
         """
         Calls the underlying MFC OnInitialUpdate method.

Args:



Returns:

      None
        
         """
         pass


      def OnMouseActivate(self,wnd:'PyCWnd',hittest:'typing.Any',message:'typing.Any') -> 'typing.Any':
         """
         Calls the base MFC OnMouseActivate function.

Args:

      wnd(PyCWnd):
      hittest(typing.Any):
      message(typing.Any):See Also

Returns:

      typing.Any
        
         """
         pass


      def PreCreateWindow(self,createStruct:'typing.Any') -> 'typing.Any':
         """
         Calls the underlying MFC PreCreateWindow method.

Args:

      createStruct(typing.Any):A tuple representing a CREATESTRUCT structure.See Also

Returns:

      typing.Any
        
         """
         pass


      def OnFilePrint(self,) -> 'None':
         """
         Calls the underlying MFC OnFilePrint method.

Args:



Returns:

      None
        
         """
         pass


      def DoPreparePrinting(self,) -> 'typing.Any':
         """
         Invoke the Print dialog box and create a printer device context.

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnBeginPrinting(self,) -> 'None':
         """
         Calls the underlying MFC OnBeginPrinting method.

Args:



Returns:

      None
        
         """
         pass


      def OnEndPrinting(self,) -> 'None':
         """
         Calls the underlying MFC OnEndPrinting method.

Args:



Returns:

      None
        
         """
         pass


class PyCWinApp(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddDocTemplate(self,template:'PyCDocTemplate') -> 'None':
         """
         Adds a template to the application list.

Args:

      template(PyCDocTemplate):The template to be added.

Returns:

      None
        
         """
         pass


      def FindOpenDocument(self,fileName:'str') -> 'PyCDocument':
         """
         Returns an existing document with the specified file name.

Args:

      fileName(str):The fully qualified filename to search for.

Returns:

      PyCDocument
        
         """
         pass


      def GetDocTemplateList(self,) -> 'typing.List[typing.Any]':
         """
         Returns a list of all document templates.

Args:



Returns:

      typing.List[typing.Any]
        
         """
         pass


      def InitDlgInstance(self,dialog:'PyCDialog') -> 'None':
         """
         Calls critical InitInstance processing for a dialog based application.

Args:

      dialog(PyCDialog):The dialog object to be used as the main window for the application.

Returns:

      None
        
         """
         pass


      def LoadCursor(self,cursorId:'PyResourceId') -> 'typing.Any':
         """
         Loads a cursor.

Args:

      cursorId(PyResourceId):The resource id or name of the cursor to load.

Returns:

      typing.Any
        
         """
         pass


      def LoadStandardCursor(self,cursorId:'PyResourceId') -> 'typing.Any':
         """
         Loads a standard cursor.

Args:

      cursorId(PyResourceId):The resource ID or name of the cursor to load.

Returns:

      typing.Any
        
         """
         pass


      def LoadOEMCursor(self,cursorId:'typing.Any') -> 'typing.Any':
         """
         Loads an OEM cursor.

Args:

      cursorId(typing.Any):The ID of the cursor to load.

Returns:

      typing.Any
        
         """
         pass


      def LoadIcon(self,idResource:'typing.Any') -> 'typing.Any':
         """
         Loads an icon resource.

Args:

      idResource(typing.Any):The ID of the icon to load.

Returns:

      typing.Any
        
         """
         pass


      def LoadStandardIcon(self,resourceName:'PyResourceId') -> 'typing.Any':
         """
         Loads an icon resource.

Args:

      resourceName(PyResourceId):The resource name or id of the standard icon to load.

Returns:

      typing.Any
        
         """
         pass


      def OpenDocumentFile(self,fileName:'str') -> 'None':
         """
         Opens a document file by name.

Args:

      fileName(str):The name of the document to open.

Returns:

      None
        
         """
         pass


      def OnFileNew(self,) -> 'None':
         """
         Calls the underlying OnFileNew MFC method.

Args:



Returns:

      None
        
         """
         pass


      def OnFileOpen(self,) -> 'None':
         """
         Calls the underlying OnFileOpen MFC method.

Args:



Returns:

      None
        
         """
         pass


      def RemoveDocTemplate(self,template:'PyCDocTemplate') -> 'None':
         """
         Removes a template to the application list.

Args:

      template(PyCDocTemplate):The template to be removed.  Must have previously been added by PyCWinApp::AddDocTemplate.CommentsNote that MFC does not provide an equivilent function.

Returns:

      None
        
         """
         pass


      def Run(self,) -> 'typing.Any':
         """
         Starts the message pump.  Advanced users only

Args:



Returns:

      typing.Any
        
         """
         pass


      def IsInproc(self,) -> 'typing.Any':
         """
         Returns a flag to indicate if the created CWinApp was in the DLL, or an external 

EXE.

Args:



Returns:

      typing.Any
        
         """
         pass


class PyCWinThread(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def CreateThread(self,) -> 'None':
         """
         Creates the actual thread behind the thread object.

Args:



Returns:

      None
        
         """
         pass


      def PumpIdle(self,) -> 'None':
         """
         Pumps all idle messages.

Args:



Returns:

      None
        
         """
         pass


      def PumpMessages(self,) -> 'None':
         """
         Pumps all messages to the application until a WM_QUIT message is received.

Args:



Returns:

      None
        
         """
         pass


      def Run(self,) -> 'typing.Any':
         """
         Starts the message pump.  Advanced users only

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetMainFrame(self,mainFrame:'PyCWnd') -> 'None':
         """
         Sets the threads main frame

Args:

      mainFrame(PyCWnd):The applications main frame.CommentsYou can pass None to this function to reset the main frame. Should I free this?  I dont think so!

Returns:

      None
        
         """
         pass


      def SetThreadPriority(self,priority:'PyCWnd') -> 'None':
         """
         Sets the threads priority.  Returns TRUE if successful.

Args:

      priority(PyCWnd):The threads priority.

Returns:

      None
        
         """
         pass


class PyCWnd(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ActivateFrame(self,cmdShow:'typing.Any') -> 'None':
         """
         Searches upwards for a parent window which has 

a frame, and activates it.

Args:

      cmdShow(typing.Any):The param passed to CFrameWnd::ShowWindow.  See also PyCWnd::ShowWindow.MFC References

Returns:

      None
        
         """
         pass


      def BringWindowToTop(self,) -> 'None':
         """
         Brings the window to the top of a stack of overlapping windows.

Args:



Returns:

      None
        
         """
         pass


      def BeginPaint(self,) -> 'typing.Tuple[PyCDC, typing.Any]':
         """
         Prepares a window for painting

Args:



Returns:

      typing.Tuple[PyCDC, typing.Any]:PyCWnd.BeginPaint
PyCDC, PAINTSTRUCT

 = BeginPaint()Prepares a window for painting
Return ValueYou must pass the PAINTSTRUCT param to the PyCWnd::EndPaint method.

        
         """
         pass


      def CalcWindowRect(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',nAdjustType:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Computes the size of the window rectangle based on the desired client 

rectangle size.  The resulting size can then be used as the initial 

size for the window object.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The size to calculate from
      nAdjustType(typing.Any):An enumerated type used for in-place editing. It can have the following values: CWnd::adjustBorder = 0, which means that scrollbar sizes are ignored in calculation; and CWnd::adjustOutside = 1, which means that they are added into the final measurements of the rectangle.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def CenterWindow(self,altwin:'PyCWnd'=None) -> 'None':
         """
         Centers a window relative to its parent.

Args:

      altwin(PyCWnd):alternate window relative to which it will be centered (other than the parent window).MFC References

Returns:

      None
        
         """
         pass


      def CheckRadioButton(self,idFirst:'typing.Any',idLast:'typing.Any',idCheck:'typing.Any') -> 'None':
         """
         Selects the specified radio button, and clears 

all others in the group.

Args:

      idFirst(typing.Any):The identifier of the first radio button in the group.
      idLast(typing.Any):The identifier of the last radio button in the group.
      idCheck(typing.Any):The identifier of the radio button to be checked.MFC References

Returns:

      None
        
         """
         pass


      def ChildWindowFromPoint(self,x:'typing.Any',y:'typing.Any',flag:'typing.Any'=0) -> 'PyCWnd':
         """
         Returns the child window that contains the point

Args:

      x(typing.Any):x coordinate of point
      y(typing.Any):y coordinate of point
      flag(typing.Any):Specifies which child windows to skipMFC References

Returns:

      PyCWnd
        
         """
         pass


      def ClientToScreen(self,point:'typing.Tuple[typing.Any, typing.Any]',rect:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Converts the client coordinates of a given point on the display 

to screen coordinates.

Args:

      point(typing.Tuple[typing.Any, typing.Any]):The client coordinates.Alternative Parameters
      rect(typing.Any):The client coordinates.CommentsThe new screen coordinates are relative to the upper-left corner of the system display. This function assumes that the given pointis in client coordinates.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def CreateWindow(self,classId:'str',windowName:'str',style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',parent:'PyCWnd',_id:'typing.Any',context:'typing.Any'=None) -> 'None':
         """
         Creates the actual window

Args:

      classId(str):The class ID for the window, or None
      windowName(str):The title for the window, or None
      style(typing.Any):The style for the window.
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The size and position of the window.
      parent(PyCWnd):The parent window of the new window..
      _id(typing.Any):The control's ID.
      context(typing.Any):A CreateContext object.MFC References

Returns:

      None
        
         """
         pass


      def CreateWindowEx(self,styleEx:'typing.Any',classId:'str',windowName:'str',style:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',parent:'PyCWnd',_id:'typing.Any',createStruct1:'typing.Any',createStruct:'CREATESTRUCT'=None) -> 'None':
         """
         Creates the actual window using extended capabilities.

Args:

      styleEx(typing.Any):The extended style of the window being created.
      classId(str):The class ID for the window.  May not be None.
      windowName(str):The title for the window, or None
      style(typing.Any):The style for the window.
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The size and position of the window.
      parent(PyCWnd):The parent window of the new window..
      _id(typing.Any):The control's ID.
      createStruct1(typing.Any):A tuple representing a CREATESTRUCT structure.MFC References
      createStruct(CREATESTRUCT):A CreateStruct object (ie, a tuple)

Returns:

      None
        
         """
         pass


      def DefWindowProc(self,message:'typing.Any',idLast:'typing.Any',idCheck:'typing.Any') -> 'typing.Any':
         """
         Calls the default message handler.

Args:

      message(typing.Any):The Windows message.
      idLast(typing.Any):The lParam for the message.
      idCheck(typing.Any):The wParam for the message.MFC References

Returns:

      typing.Any
        
         """
         pass


      def DestroyWindow(self,) -> 'None':
         """
         Destroy the window attached to the object.

Args:



Returns:

      None
        
         """
         pass


      def DlgDirList(self,defPath:'str',idListbox:'typing.Any',idStaticPath:'typing.Any',fileType:'typing.Any') -> 'None':
         """
         Fill a list box with a file or directory listing.

Args:

      defPath(str):The file spec to fill the list box with
      idListbox(typing.Any):The Id of the listbox control to fill.
      idStaticPath(typing.Any):The Id of the static control used to display the current drive and directory. If idStaticPath is 0, it is assumed that no such control exists.
      fileType(typing.Any):Specifies the attributes of the files to be displayed. It can be any combination of DDL_READWRITE, DDL_READONLY, DDL_HIDDEN, DDL_SYSTEM, DDL_DIRECTORY, DDL_ARCHIVE, DDL_POSTMSGS, DDL_DRIVES or DDL_EXCLUSIVEMFC References

Returns:

      None
        
         """
         pass


      def DlgDirListComboBox(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def DlgDirSelect(self,idListbox:'typing.Any') -> 'str':
         """
         None

Args:

      idListbox(typing.Any):The Id of the listbox.MFC References

Returns:

      str
        
         """
         pass


      def DlgDirSelectComboBox(self,idListbox:'typing.Any') -> 'str':
         """
         None

Args:

      idListbox(typing.Any):The Id of the combobox.MFC References

Returns:

      str
        
         """
         pass


      def DragAcceptFiles(self,bAccept:'typing.Any'=1) -> 'None':
         """
         Indicates that the window and children supports files dropped from file manager

Args:

      bAccept(typing.Any):A flag indicating if files are accepted.MFC References

Returns:

      None
        
         """
         pass


      def DrawMenuBar(self,) -> 'None':
         """
         Redraws the menu bar.  Can be called if the menu changes.

Args:



Returns:

      None
        
         """
         pass


      def EnableWindow(self,bEnable:'typing.Any'=1) -> 'typing.Any':
         """
         Enables or disables the window.  Typically used for dialog controls.

Args:

      bEnable(typing.Any):A flag indicating if the window is to be enabled or disabled.MFC References

Returns:

      typing.Any:CWnd::EnableWindow
Return ValueReturns the state before the EnableWindow member function was called

        
         """
         pass


      def EndModalLoop(self,result:'typing.Any') -> 'None':
         """
         Ends a modal loop.

Args:

      result(typing.Any):The result as returned to RunModalLoop

Returns:

      None
        
         """
         pass


      def EndPaint(self,paintStruct:'typing.Any') -> 'None':
         """
         Ends painting

Args:

      paintStruct(typing.Any):The object returned from PyCWnd::BeginPaint

Returns:

      None
        
         """
         pass


      def GetCheckedRadioButton(self,idFirst:'typing.Any',idLast:'typing.Any') -> 'typing.Any':
         """
         Returns the ID of the checked radio button, or 0 if none is selected.

Args:

      idFirst(typing.Any):The Id of the first radio button in the group.
      idLast(typing.Any):The Id of the last radio button in the group.MFC References

Returns:

      typing.Any
        
         """
         pass


      def GetClientRect(self,) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Returns the client coordinates of the window.  left and top 

will be zero.

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetDC(self,) -> 'PyCDC':
         """
         Gets the windows current DC object.

Args:



Returns:

      PyCDC:PyCWnd.GetDC
PyCDC = GetDC()Gets the windows current DC object.
Return ValueThe result is a PyCDC, or a win32ui.error exception is raised.

        
         """
         pass


      def GetDCEx(self,) -> 'PyCDC':
         """
         Gets the windows current DC object with extended caps.

Args:



Returns:

      PyCDC
        
         """
         pass


      def GetDlgCtrlID(self,) -> 'typing.Any':
         """
         Returns the ID of this child window.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetDlgItem(self,idControl:'typing.Any') -> 'PyCWnd':
         """
         None

Args:

      idControl(typing.Any):The Id of the control to be retrieved.MFC References

Returns:

      PyCWnd:CWnd::GetDlgItem
Return ValueThe result is a PyCWnd (or derived) object, or a win32ui.error exception is raised.

        
         """
         pass


      def GetDlgItemInt(self,idControl:'typing.Any',bUnsigned:'typing.Any'=1) -> 'typing.Any':
         """
         Returns the integer value of a child window or control with the specified ID.

Args:

      idControl(typing.Any):The Id of the control to be retrieved.
      bUnsigned(typing.Any):Should the function check for a minus signMFC References

Returns:

      typing.Any:CWnd::GetDlgItemInt
Return ValueIf the value can not be converted, a ValueError is raised.

        
         """
         pass


      def GetDlgItemText(self,idControl:'typing.Any') -> 'str':
         """
         Returns the text of child window or control with the specified ID.

Args:

      idControl(typing.Any):The Id of the control to be retrieved.MFC References

Returns:

      str
        
         """
         pass


      def GetLastActivePopup(self,) -> 'PyCWnd':
         """
         Returns the last active popup Window, or the Window itself.

Args:



Returns:

      PyCWnd:CWnd::GetLastActivePopup
Return ValueThe result is a PyCWnd object, or None if no Window can be found.

        
         """
         pass


      def GetMenu(self,) -> 'PyCMenu':
         """
         Returns the menu object for the window's menu.

Args:



Returns:

      PyCMenu:CWnd::GetMenu
Return ValueThe result is a PyMenu

 object, or an exception is thrown.

        
         """
         pass


      def GetParent(self,) -> 'PyCWnd':
         """
         Returns the window's parent.

Args:



Returns:

      PyCWnd:CWnd::GetParent
Return ValueThe result is a PyCWnd object, or None if no Window can be found.

        
         """
         pass


      def GetParentFrame(self,) -> 'PyCWnd':
         """
         Returns the window's frame.

Args:



Returns:

      PyCWnd:CWnd::GetParentFrame
Return ValueThe result is a PyCWnd object, or None if no Window can be found.

        
         """
         pass


      def GetSafeHwnd(self,) -> 'typing.Any':
         """
         Returns the HWnd of this window.

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetScrollInfo(self,nBar:'typing.Any',mask:'typing.Any') -> 'typing.Any':
         """
         Returns information about a scroll bar

Args:

      nBar(typing.Any):The scroll bar to examine.  Can be one of win32con.SB_BOTH, win32con.SB_VERT or win32con.SB_HORZ
      mask(typing.Any):The mask for attributes to retrieve.

Returns:

      typing.Any
        
         """
         pass


      def GetScrollPos(self,nBar:'typing.Any') -> 'typing.Any':
         """
         Retrieves the current position of the scroll box of a scroll bar.

Args:

      nBar(typing.Any):The scroll bar to examine.  Can be one of win32con.SB_VERT or win32con.SB_HORZ

Returns:

      typing.Any
        
         """
         pass


      def GetStyle(self,) -> 'typing.Any':
         """
         Retrieves the window style

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetExStyle(self,) -> 'typing.Any':
         """
         Retrieves the window's extended style

Args:



Returns:

      typing.Any
        
         """
         pass


      def GetSystemMenu(self,) -> 'PyCMenu':
         """
         Returns the menu object for the window's system menu.

Args:



Returns:

      PyCMenu
        
         """
         pass


      def GetTopLevelFrame(self,) -> 'PyCWnd':
         """
         Returns the top-level frame of the window.

Args:



Returns:

      PyCWnd:CWnd::GetTopLevelFrame
Return ValueThe result is a PyCWnd object, or None if no Window can be found.

        
         """
         pass


      def GetTopLevelOwner(self,) -> 'PyCWnd':
         """
         Returns the top-level owner of the window.

Args:



Returns:

      PyCWnd:CWnd::GetTopLevelOwner
Return ValueThe result is a PyCWnd object, or None if no Window can be found.

        
         """
         pass


      def GetTopLevelParent(self,) -> 'PyCWnd':
         """
         Returns the top-level parent of the window.

Args:



Returns:

      PyCWnd:CWnd::GetTopLevelParent
Return ValueThe result is a PyCWnd object, or None if no Window can be found.

        
         """
         pass


      def GetTopWindow(self,) -> 'PyCWnd':
         """
         Identifies the top-level child window in a linked list of child windows.

Args:



Returns:

      PyCWnd:CWnd::GetTopWindow
Return ValueIf no child windows exist, the value is None.

        
         """
         pass


      def GetWindow(self,_type:'typing.Any') -> 'PyCWnd':
         """
         Returns a window, with the specified relationship to this window.

Args:

      _type(typing.Any):Specifies the relationship between the current and the returned window. It can take one of the following values: GW_CHILD, GW_HWNDFIRST, GW_HWNDLAST, GW_HWNDNEXT, GW_HWNDPREV or GW_OWNERMFC References

Returns:

      PyCWnd:CWnd::GetWindow
Return ValueThe result is a PyCWnd or None if no Window can be found.

        
         """
         pass


      def GetWindowDC(self,) -> 'PyCDC':
         """
         Gets the windows current DC object.

Args:



Returns:

      PyCDC
        
         """
         pass


      def GetWindowPlacement(self,) -> 'typing.Any':
         """
         Returns placement information about the current window.

Args:



Returns:

      typing.Any:CWnd::GetWindowPlacement
Return ValueThe result is a tuple of 

(flags, showCmd, (minposX, minposY), (maxposX, maxposY), (normalposX, normalposY))



Item


Description



flagsOne of the WPF_* constants
showCmdCurrent state - one of the SW_* constants.
minposSpecifies the coordinates of the window's upper-left corner when the window is minimized.
maxposSpecifies the coordinates of the window's upper-left corner when the window is maximized.
normalposSpecifies the window's coordinates when the window is in the restored position.

        
         """
         pass


      def GetWindowRect(self,) -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Returns the screen coordinates of the windows upper left 

corner

Args:



Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]
        
         """
         pass


      def GetWindowText(self,) -> 'str':
         """
         Returns the windows text.

Args:



Returns:

      str
        
         """
         pass


      def HideCaret(self,) -> 'None':
         """
         Hides the caret

Args:



Returns:

      None
        
         """
         pass


      def HookAllKeyStrokes(self,obHandler:'typing.Any') -> 'None':
         """
         Hook a key stroke handler for all key strokes.

Args:

      obHandler(typing.Any):The handler for the keystrokes.  This must be a callable object.CommentsThe handler object passed will be called as the application receives WM_CHAR messages. The handler will be called with 2 arguments The handler object (as per all hook functions). The keystroke being handled. If the handler returns TRUE, then the keystroke will be passed on to the default handler, otherwise it will be consumed. Note: This handler will prevent any PyCWnd::HookKeyStroke hooks from being called.

Returns:

      None
        
         """
         pass


      def HookKeyStroke(self,obHandler:'typing.Any',ch:'typing.Any') -> 'typing.Any':
         """
         Hook a key stroke handler

Args:

      obHandler(typing.Any):The handler of the keystroke.  This must be a callable object.
      ch(typing.Any):The ID for the keystroke to be handled. This may be an ascii code, or a virtual key code.CommentsThe handler object passed will be called as the application receives WM_CHAR message for the specified character code. The handler will be called with 2 arguments The handler object (as per all hook functions) The keystroke being handled. If the handler returns TRUE, then the keystroke will be passed on to the default handler, otherwise the keystroke will be consumed. Note: This handler will not be called if a PyCWnd::HookAllKeyStrokes hook is in place.Return ValueThe return value is the previous handler, or None.

Returns:

      typing.Any:The ID for the keystroke to be handled. 

This may be an ascii code, or a virtual key code.Comments

The handler object passed will be called as the application receives WM_CHAR message for the specified 

character code. The handler will be called with 2 arguments 

The handler object (as per all hook functions) 

The keystroke being handled. 

If the handler returns TRUE, then the keystroke will be passed on to the 

default handler, otherwise the keystroke will be consumed. 

Note: This handler will not be called if a PyCWnd::HookAllKeyStrokes hook is in place.
Return ValueThe return value is the previous handler, or None.

        
         """
         pass


      def HookMessage(self,obHandler:'typing.Any',message:'typing.Any') -> 'typing.Any':
         """
         Hook a message notification handler

Args:

      obHandler(typing.Any):The handler for the message notification.  This must be a callable object.
      message(typing.Any):The ID of the message to be handled.CommentsThe handler object passed will be called as the application receives messages with the specified ID. Note that it is not possible for PythonWin to consume a message - it is always passed on to the default handler. The handler will be called with 2 arguments The handler object (as per all hook functions). A tuple representing the message. The message tuple is in the following format:Items[0] int : hwndThe hwnd of the window.[1] int : messageThe message.[2] int : wParamThe wParam sent with the message.[3] int : lParamThe lParam sent with the message.[4] int : timeThe time the message was posted.[5] int, int : pointThe point where the mouse was when the message was posted.Return ValueThe return value is the previous handler, or None.

Returns:

      typing.Any:The ID of the message to be handled.Comments

The handler object passed will be called as the application receives messages with the specified ID. 

Note that it is not possible for PythonWin to consume a message - it is always passed on to the default handler. 

The handler will be called with 2 arguments 

The handler object (as per all hook functions). 

A tuple representing the message. 

The message tuple is in the following format:
Items[0] int : hwnd
The hwnd of the window.
[1] int : message
The message.
[2] int : wParam
The wParam sent with the message.
[3] int : lParam
The lParam sent with the message.
[4] int : time
The time the message was posted.
[5] int, int : point
The point where the mouse was when the message was posted.
Return ValueThe return value is the previous handler, or None.

        
         """
         pass


      def InvalidateRect(self,arg:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',bErase:'typing.Any'=1) -> 'None':
         """
         Invalidates an area of a window.

Args:

      arg(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):Rectangle to be updated.  If default param is used, the entire window is invalidated.
      bErase(typing.Any):Specifies whether the background within the update region is to be erased.MFC References

Returns:

      None
        
         """
         pass


      def InvalidateRgn(self,region:'PyCRgn',bErase:'typing.Any'=1) -> 'None':
         """
         Invalidates a region of the window

Args:

      region(PyCRgn):The region to erase.
      bErase(typing.Any):Indicates if the region should be erased.

Returns:

      None
        
         """
         pass


      def IsChild(self,obWnd:'PyCWnd') -> 'typing.Any':
         """
         Determines if a given window is a child of this window.

Args:

      obWnd(PyCWnd):The window to be checkedMFC References

Returns:

      typing.Any
        
         """
         pass


      def IsDlgButtonChecked(self,idCtl:'typing.Any') -> 'typing.Any':
         """
         Determines if a dialog button is checked.

Args:

      idCtl(typing.Any):The ID of the button to check.MFC References

Returns:

      typing.Any
        
         """
         pass


      def IsIconic(self,) -> 'typing.Any':
         """
         Determines if the window is currently displayed as an icon.

Args:



Returns:

      typing.Any
        
         """
         pass


      def IsZoomed(self,) -> 'typing.Any':
         """
         Determines if the window is currently maximised.

Args:



Returns:

      typing.Any
        
         """
         pass


      def IsWindow(self,) -> 'typing.Any':
         """
         determines whether the specified window handle identifies an existing window

Args:



Returns:

      typing.Any
        
         """
         pass


      def IsWindowVisible(self,) -> 'typing.Any':
         """
         Determines if the window is currently visible.

Args:



Returns:

      typing.Any
        
         """
         pass


      def KillTimer(self,) -> 'typing.Any':
         """
         Kills a system timer

Args:



Returns:

      typing.Any
        
         """
         pass


      def LockWindowUpdate(self,) -> 'None':
         """
         Disables drawing in the given window

Args:



Returns:

      None
        
         """
         pass


      def MapWindowPoints(self,wnd:'PyCWnd',points:'typing.List[typing.Tuple[typing.Any, typing.Any]]') -> 'None':
         """
         Converts (maps) a set of points from the coordinate space of a window to the 

coordinate space of another window.

Args:

      wnd(PyCWnd):
      points(typing.List[typing.Tuple[typing.Any, typing.Any]]):The points to mapReturn ValueA list of the mapped points from the coordinate space of the CWnd to the coordinate space of another window.

Returns:

      None:The points to mapReturn ValueA list of the mapped points from the coordinate space of the CWnd to the coordinate space of another 

window.

        
         """
         pass


      def MouseCaptured(self,) -> 'typing.Any':
         """
         Returns 1 if the window has the mouse capture, else 0

Args:



Returns:

      typing.Any
        
         """
         pass


      def MessageBox(self,message:'str',arg:'typing.Any',title:'typing.Union[str, typing.Any]'=None) -> 'None':
         """
         Display a message box.

Args:

      message(str):The message to be displayed in the message box.
      arg(typing.Any):The style of the message box.MFC References
      title(typing.Union[str, typing.Any]):The title for the message box.  If None, the applications title will be used.

Returns:

      None:CWnd::MessageBox
Return ValueAn integer identifying the button pressed to dismiss the dialog.

        
         """
         pass


      def ModifyStyle(self,remove:'typing.Any',add:'typing.Any',flags:'typing.Any'=0) -> 'typing.Any':
         """
         Modifies the style of a window.

Args:

      remove(typing.Any):Specifies window styles to be removed during style modification.
      add(typing.Any):Specifies window styles to be added during style modification.
      flags(typing.Any):Flags to be passed to SetWindowPos, or zero if SetWindowPos should not be called. The default is zero.CommentsIf nFlags is nonzero, ModifyStyle calls the Windows API function ::SetWindowPos and redraws the window by combining nFlags with the following four preset flags: * SWP_NOSIZE	Retains the current size. * SWP_NOMOVE	Retains the current position. * SWP_NOZORDER	Retains the current Z order. * SWP_NOACTIVATE	Does not activate the window. See also PyCWnd::ModifyStyleExMFC References

Returns:

      typing.Any:CWnd::ModifyStyle
Return ValueThe result is true if the style was changed, or false if the style 

is already the same as requested and no change was made.

        
         """
         pass


      def ModifyStyleEx(self,remove:'typing.Any',add:'typing.Any',flags:'typing.Any'=0) -> 'typing.Any':
         """
         Modifies the extended style of a window.

Args:

      remove(typing.Any):Specifies extended window styles to be removed during style modification.
      add(typing.Any):Specifies extended extended window styles to be added during style modification.
      flags(typing.Any):Flags to be passed to SetWindowPos, or zero if SetWindowPos should not be called. The default is zero.CommentsIf nFlags is nonzero, ModifyStyleEx calls the Windows API function ::SetWindowPos and redraws the window by combining nFlags with the following four preset flags: * SWP_NOSIZE	Retains the current size. * SWP_NOMOVE	Retains the current position. * SWP_NOZORDER	Retains the current Z order. * SWP_NOACTIVATE	Does not activate the window. See also PyCWnd::ModifyStyleMFC References

Returns:

      typing.Any:CWnd::ModifyStyleEx
Return ValueThe result is true if the style was changed, or false if the style 

is already the same as requested and no change was made.

        
         """
         pass


      def MoveWindow(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',bRepaint:'typing.Any'=1) -> 'None':
         """
         Move a window to a new location.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The new location of the window, relative to the parent.
      bRepaint(typing.Any):Indicates if the window should be repainted after the move.MFC References

Returns:

      None
        
         """
         pass


      def OnClose(self,) -> 'typing.Any':
         """
         Calls the default MFC OnClose handler.

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnCtlColor(self,dc:'PyCDC',control:'typing.Any',_type:'typing.Any') -> 'typing.Any':
         """
         Calls the default MFC OnCtlColor handler.

Args:

      dc(PyCDC):The dc
      control(typing.Any):The control that want's it's color changed
      _type(typing.Any):Type of controlSee Also

Returns:

      typing.Any
        
         """
         pass


      def OnEraseBkgnd(self,dc:'PyCDC') -> 'typing.Any':
         """
         Calls the default MFC OnEraseBkgnd handler.

Args:

      dc(PyCDC):The dcSee Also

Returns:

      typing.Any
        
         """
         pass


      def OnNcHitTest(self,arg:'typing.Tuple[typing.Any, typing.Any]') -> 'typing.Any':
         """
         Calls the base MFC OnNcHitTest function.

Args:

      arg(typing.Tuple[typing.Any, typing.Any]):The pointSee Also

Returns:

      typing.Any
        
         """
         pass


      def OnPaint(self,) -> 'typing.Any':
         """
         Calls the default MFC OnPaint handler.

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnQueryDragIcon(self,) -> 'typing.Any':
         """
         Calls the default MFC OnQueryDragIcon handler.

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnQueryNewPalette(self,) -> 'typing.Any':
         """
         Calls the underlying MFC OnQueryNewPalette method.

Args:



Returns:

      typing.Any
        
         """
         pass


      def OnSetCursor(self,wnd:'PyCWnd',hittest:'typing.Any',message:'typing.Any') -> 'typing.Any':
         """
         Calls the base MFC OnSetCursor function.

Args:

      wnd(PyCWnd):
      hittest(typing.Any):
      message(typing.Any):See Also

Returns:

      typing.Any
        
         """
         pass


      def OnMouseActivate(self,wnd:'PyCWnd',hittest:'typing.Any',message:'typing.Any') -> 'typing.Any':
         """
         Calls the base MFC OnMouseActivate function.

Args:

      wnd(PyCWnd):
      hittest(typing.Any):
      message(typing.Any):See Also

Returns:

      typing.Any
        
         """
         pass


      def OnWndMsg(self,msg:'typing.Any',wParam:'typing.Any',lParam:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any]':
         """
         Calls the default MFC Window Message handler.

Args:

      msg(typing.Any):The message
      wParam(typing.Any):The wParam for the message
      lParam(typing.Any):The lParam for the messageMFC References

Returns:

      typing.Tuple[typing.Any, typing.Any]:CWnd::OnWndMsg
Return ValueThe return value is a tuple of (int, int), being the 

return value from the MFC function call, and the value of the 

lResult param.  Please see the MFC documentation for more details.

        
         """
         pass


      def PreCreateWindow(self,createStruct:'typing.Any') -> 'typing.Any':
         """
         Calls the underlying MFC PreCreateWindow method.

Args:

      createStruct(typing.Any):A tuple representing a CREATESTRUCT structure.See Also

Returns:

      typing.Any
        
         """
         pass


      def PumpWaitingMessages(self,firstMsg:'typing.Any',lastMsg:'typing.Any') -> 'None':
         """
         Pump messages associate with a window.

Args:

      firstMsg(typing.Any):First message ID to process
      lastMsg(typing.Any):First message ID to processMFC References

Returns:

      None
        
         """
         pass


      def RedrawWindow(self,_object:'PyCRgn',flags:'typing.Any',rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]'=None) -> 'None':
         """
         Updates the specified rectangle or region in the given window's client area.

Args:

      _object(PyCRgn):A region
      flags(typing.Any):MFC References
      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):A rect, or None

Returns:

      None
        
         """
         pass


      def ReleaseCapture(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def ReleaseDC(self,dc:'PyCDC') -> 'None':
         """
         Releases a device context, freeing it for use by other applications.

Args:

      dc(PyCDC):The DC to be released.

Returns:

      None
        
         """
         pass


      def RepositionBars(self,idFirst:'typing.Any',idLast:'typing.Any',idLeftOver:'typing.Any') -> 'None':
         """
         Repositions the windows control bars.( UINT nIDFirst, UINT nIDLast, UINT 

nIDLeftOver, UINT nFlag = CWnd::reposDefault, LPRECT lpRectParam = NULL, LPCRECT lpRectClient = NULL, BOOL bStretch = 

TRUE );

Args:

      idFirst(typing.Any):The ID of the first control to reposition.
      idLast(typing.Any):The ID of the last control to reposition.
      idLeftOver(typing.Any):

Returns:

      None
        
         """
         pass


      def RunModalLoop(self,flags:'typing.Any') -> 'typing.Any':
         """
         Begins a modal loop for the window.

Args:

      flags(typing.Any):

Returns:

      typing.Any
        
         """
         pass


      def PostMessage(self,idMessage:'typing.Any',wParam:'typing.Any'=0,lParam:'typing.Any'=0) -> 'None':
         """
         Post a message to the window.

Args:

      idMessage(typing.Any):The ID of the message to post.
      wParam(typing.Any):The wParam for the message
      lParam(typing.Any):The lParam for the messageMFC References

Returns:

      None
        
         """
         pass


      def SendMessageToDescendants(self,idMessage:'typing.Any',wParam:'typing.Any'=0,lParam:'typing.Any'=0,bDeep:'typing.Any'=1) -> 'None':
         """
         Send a message to all descendant windows.

Args:

      idMessage(typing.Any):The ID of the message to send.
      wParam(typing.Any):The wParam for the message
      lParam(typing.Any):The lParam for the message
      bDeep(typing.Any):Indicates if the message should be recursively sent to all childrenMFC References

Returns:

      None
        
         """
         pass


      def SendMessage(self,idMessage:'typing.Any',idMessage1:'typing.Any',ob:'typing.Any',wParam:'typing.Any'=0,lParam:'typing.Any'=0) -> 'None':
         """
         Send a message to the window.

Args:

      idMessage(typing.Any):The ID of the message to send.
      idMessage1(typing.Any):The ID of the message to send.
      ob(typing.Any):A buffer whose size is passed in wParam, and address is passed in lParamMFC References
      wParam(typing.Any):The wParam for the message
      lParam(typing.Any):The lParam for the messageAlternative Parameters

Returns:

      None
        
         """
         pass


      def SetActiveWindow(self,) -> 'PyCWnd':
         """
         Sets the window active.  Returns the previously active window, or None.

Args:



Returns:

      PyCWnd:PyCWnd.SetActiveWindow
PyCWnd = SetActiveWindow()Sets the window active.  Returns the previously active window, or None.
Return ValueThe result is the previous window with focus, or None.

        
         """
         pass


      def SetForegroundWindow(self,) -> 'None':
         """
         Puts the window into the foreground and activates the window.

Args:



Returns:

      None
        
         """
         pass


      def SetWindowPos(self,hWndInsertAfter:'typing.Any',position:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]',flags:'typing.Any') -> 'None':
         """
         Sets the windows position information

Args:

      hWndInsertAfter(typing.Any):A hwnd, else one of the win32con.HWND_* constants.
      position(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any]):The new position of the window.
      flags(typing.Any):Window positioning flags.MFC References

Returns:

      None
        
         """
         pass


      def ScreenToClient(self,rect:'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any, typing.Any]',pnt:'typing.Any') -> 'typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any, typing.Any]':
         """
         Converts the screen coordinates of a given point 

or rectangle on the display to client coordinates.

Args:

      rect(typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any, typing.Any]):The coordinates to convert.Alternative Parameters
      pnt(typing.Any):The coordinates to convert.MFC References

Returns:

      typing.Tuple[typing.Any, typing.Any, typing.Any, typing.Any, typing.Any]:CWnd::ScreenToClient
Return ValueThe result is the same size as the input argument.

        
         """
         pass


      def SetCapture(self,) -> 'None':
         """
         Causes all subsequent mouse input to be sent to the window object regardless of the 

position of the cursor.

Args:



Returns:

      None
        
         """
         pass


      def SetDlgItemText(self,idControl:'typing.Any',text:'str') -> 'None':
         """
         Sets the text for the child window or control with the specified ID.

Args:

      idControl(typing.Any):The Id of the control
      text(str):The new textMFC References

Returns:

      None
        
         """
         pass


      def SetFocus(self,) -> 'None':
         """
         Claims the input focus.  The object that previously had the focus loses it.

Args:



Returns:

      None
        
         """
         pass


      def SetFont(self,font:'PyCFont',bRedraw:'typing.Any'=1) -> 'None':
         """
         Sets the window's current font to the specified font.

Args:

      font(PyCFont):The new font to use.
      bRedraw(typing.Any):If TRUE, redraw the window.

Returns:

      None
        
         """
         pass


      def SetIcon(self,) -> 'typing.Any':
         """
         Calls the underlying MFC SetIcon method.

Args:



Returns:

      typing.Any
        
         """
         pass


      def SetMenu(self,menuObj:'PyCMenu') -> 'None':
         """
         Sets the menu for a window.

Args:

      menuObj(PyCMenu):The menu object to set, or None to remove the window.

Returns:

      None
        
         """
         pass


      def SetRedraw(self,bState:'typing.Any'=1) -> 'None':
         """
         Allows changes to be redrawn or to prevent changes from being redrawn.

Args:

      bState(typing.Any):Specifies the state of the redraw flag.MFC References

Returns:

      None
        
         """
         pass


      def SetScrollPos(self,nBar:'typing.Any',nPos:'typing.Any',redraw:'typing.Any'=1) -> 'typing.Any':
         """
         Sets the current position of the scroll box of a scroll bar.

Args:

      nBar(typing.Any):The scroll bar to set.  Can be one of win32con.SB_VERT or win32con.SB_HORZ
      nPos(typing.Any):The new position
      redraw(typing.Any):A flag indicating if the scrollbar should be redrawn.

Returns:

      typing.Any
        
         """
         pass


      def SetScrollInfo(self,nBar:'typing.Any',ScrollInfo:'typing.Any',redraw:'typing.Any'=1) -> 'typing.Any':
         """
         Set information about a scroll bar

Args:

      nBar(typing.Any):The scroll bar to examine.  Can be one of win32con.SB_BOTH, win32con.SB_VERT or win32con.SB_HORZ
      ScrollInfo(typing.Any):The information to set
      redraw(typing.Any):A flag indicating if the scrollbar should be re-drawn.

Returns:

      typing.Any
        
         """
         pass


      def SetTimer(self,idEvent:'typing.Any',elapse:'typing.Any') -> 'typing.Any':
         """
         Installs a system timer

Args:

      idEvent(typing.Any):The ID of the event
      elapse(typing.Any):How often the timer should fire.MFC References

Returns:

      typing.Any
        
         """
         pass


      def SetWindowPlacement(self,placement:'typing.Any') -> 'None':
         """
         Sets the windows placement

Args:

      placement(typing.Any):A tuple representing the WINDOWPLACEMENT structure.MFC References

Returns:

      None
        
         """
         pass


      def SetWindowText(self,text:'str') -> 'None':
         """
         Sets the window's text.

Args:

      text(str):The windows text.MFC References

Returns:

      None
        
         """
         pass


      def ShowCaret(self,) -> 'None':
         """
         Shows the caret

Args:



Returns:

      None
        
         """
         pass


      def ShowScrollBar(self,nBar:'typing.Any',bShow:'typing.Any'=1) -> 'None':
         """
         Shows or hides a scroll bar. 

An application should not call ShowScrollBar to hide a scroll bar while processing a scroll-bar notification message.

Args:

      nBar(typing.Any):Specifies whether the scroll bar is a control or part of a window's nonclient area. If it is part of the nonclient area, nBar also indicates whether the scroll bar is positioned horizontally, vertically, or both. It must be one of win32con.SB_BOTH, win32con.SB_HORZ or win32con.SB_VERT.
      bShow(typing.Any):Indicates if the scroll bar should be shown or hidden.MFC References

Returns:

      None
        
         """
         pass


      def ShowWindow(self,arg:'typing.Any') -> 'typing.Any':
         """
         Sets the visibility state of the window.

Args:

      arg(typing.Any):Specifies how the window is to be shown. It must be one of win32con.SW_HIDE, win32con.SW_MINIMIZE, win32con.SW_RESTORE, win32con.SW_SHOW, win32con.SW_SHOWMAXIMIZED win32con.SW_SHOWMINIMIZED, win32con.SW_SHOWMINNOACTIVE, win32con.SW_SHOWNA, win32con.SW_SHOWNOACTIVATE,  or win32con.SW_SHOWNORMALMFC References

Returns:

      typing.Any:CWnd::ShowWindow
Return ValueReturns TRUE is the window was previously visible.

        
         """
         pass


      def UnLockWindowUpdate(self,) -> 'None':
         """
         Unlocks a window that was locked with LockWindowUpdate

Args:



Returns:

      None
        
         """
         pass


      def UpdateData(self,bSaveAndValidate:'typing.Any'=1) -> 'typing.Any':
         """
         Initialises data in a dialog box, or to retrieves and validates dialog data. 

Returns nonzero if the operation is successful; otherwise 0. If bSaveAndValidate is TRUE, then a return value of 

nonzero means that the data is successfully validated.

Args:

      bSaveAndValidate(typing.Any):Flag that indicates whether dialog box is being initialized (FALSE) or data is being retrieved (TRUE).MFC References

Returns:

      typing.Any
        
         """
         pass


      def UpdateDialogControls(self,pTarget:'PyCCmdTarget',disableIfNoHandler:'typing.Any') -> 'typing.Any':
         """
         None

Args:

      pTarget(PyCCmdTarget):The main frame window of the application, and is used for routing update messages.
      disableIfNoHandler(typing.Any):Flag that indicates whether a control that has no update handler should be automatically displayed as disabled.

Returns:

      typing.Any
        
         """
         pass


      def UpdateWindow(self,) -> 'None':
         """
         Updates a window.  This forces a paint message to be sent to the window, if any part 

of the window is marked as invalid.

Args:



Returns:

      None
        
         """
         pass


class PyDDEConv(object):
      """A DDE topic."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def ConnectTo(self,service:'str',topic:'str') -> 'None':
         """
         Connects to a server

Args:

      service(str):The service to connect to
      topic(str):The topic to connect to

Returns:

      None
        
         """
         pass


      def Connected(self,) -> 'None':
         """
         Determines if the conversation is connected.

Args:



Returns:

      None
        
         """
         pass


      def Exec(self,Cmd:'str') -> 'None':
         """
         Executes a command.

Args:

      Cmd(str):The Python statement to execute

Returns:

      None
        
         """
         pass


      def Request(self,) -> 'None':
         """
         Sends a request.

Args:



Returns:

      None
        
         """
         pass


      def Poke(self,) -> 'None':
         """
         Sends a poke.

Args:



Returns:

      None
        
         """
         pass


class PyDDEServer(object):
      """A DDE server."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddTopic(self,topic:'PyDDETopic') -> 'None':
         """
         None

Args:

      topic(PyDDETopic):The topic to add.

Returns:

      None
        
         """
         pass


      def Create(self,name:'str',filterFlags:'typing.Any'=0) -> 'None':
         """
         Create a server

Args:

      name(str):Name of the server to start.
      filterFlags(typing.Any):Filter flags.CommentsNote there can only be one server per application.

Returns:

      None
        
         """
         pass


      def Destroy(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def GetLastError(self,) -> 'typing.Any':
         """
         None

Args:



Returns:

      typing.Any
        
         """
         pass


      def Shutdown(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


class PyDDEStringItem(object):
      """A DDE string item."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def SetData(self,data:'str') -> 'None':
         """
         Sets an items data, and causes any underlying notification.

Args:

      data(str):The data to set.

Returns:

      None
        
         """
         pass


class PyDDETopic(object):
      """A DDE topic."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def AddItem(self,item:'typing.Any') -> 'None':
         """
         Add an item to the topic.

Args:

      item(typing.Any):The item to add

Returns:

      None
        
         """
         pass


      def Destroy(self,) -> 'None':
         """
         Destroys an item

Args:



Returns:

      None
        
         """
         pass


class PyDLL(object):
      """A DLL object.  A general utility object, and not associated with an MFC object."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetFileName(self,) -> 'str':
         """
         Returns the name of the module associated with the DLL.

Args:



Returns:

      str
        
         """
         pass


      def AttachToMFC(self,) -> 'None':
         """
         Attaches the DLL object to the MFC list of DLL's.

Args:



Returns:

      None
        
         """
         pass


class SCROLLINFO(object):
      """Tuple representing a SCROLLINFO struct"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class TV_ITEM(object):
      """"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


class EXTENSION_CONTROL_BLOCK(object):
      """A python representation of an ISAPI 

EXTENSION_CONTROL_BLOCK."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Version(self)->'int':
         """Version info of this spec (read-only)"""
         pass


      @property
      def TotalBytes(self)->'typing.Any':
         """Total bytes indicated from client"""
         pass


      @property
      def AvailableBytes(self)->'typing.Any':
         """Available number of bytes"""
         pass


      @property
      def HttpStatusCode(self)->'typing.Any':
         """The status of the current transaction when the request is completed."""
         pass


      @property
      def Method(self)->'typing.Any':
         """REQUEST_METHOD"""
         pass


      @property
      def ConnID(self)->'typing.Any':
         """Context number (read-only)"""
         pass


      @property
      def QueryString(self)->'typing.Any':
         """QUERY_STRING"""
         pass


      @property
      def PathInfo(self)->'typing.Any':
         """PATH_INFO"""
         pass


      @property
      def PathTranslated(self)->'typing.Any':
         """PATH_TRANSLATED"""
         pass


      @property
      def AvailableData(self)->'typing.Any':
         """Pointer to cbAvailable bytes"""
         pass


      @property
      def ContentType(self)->'typing.Any':
         """Content type of client data"""
         pass


      @property
      def LogData(self)->'typing.Any':
         """log data string"""
         pass


      def WriteClient(self,data:'typing.Union[str, typing.Any]',reserved:'typing.Any'=0) -> 'typing.Any':
         """
         None

Args:

      data(typing.Union[str, typing.Any]):The data to write
      reserved(typing.Any):Return Valuethe result is the number of bytes written.

Returns:

      typing.Any:
Return Valuethe result is the number of bytes written.

        
         """
         pass


      def GetServerVariable(self,variable:'str',default:'typing.Any') -> 'str':
         """
         None

Args:

      variable(str):
      default(typing.Any):If specified, the function will return this value instead of raising an error if the variable could not be fetched.Return ValueThe result is a string object, unless the server variable name begins with 'UNICODE_', in which case it is a unicode object - see the ISAPI docs for more details.

Returns:

      str:If specified, the function will return this 

value instead of raising an error if the variable could not be fetched.Return ValueThe result is a string object, unless the server variable name 

begins with 'UNICODE_', in which case it is a unicode object - see the 

ISAPI docs for more details.

        
         """
         pass


      def ReadClient(self,nbytes:'typing.Any') -> 'str':
         """
         None

Args:

      nbytes(typing.Any):Default is to read all available data.

Returns:

      str
        
         """
         pass


      def SendResponseHeaders(self,reply:'str',headers:'str',keepAlive:'typing.Any'=False) -> 'None':
         """
         Calls ServerSupportFunction with 

HSE_REQ_SEND_RESPONSE_HEADER_EX

Args:

      reply(str):
      headers(str):
      keepAlive(typing.Any):

Returns:

      None
        
         """
         pass


      def SetFlushFlag(self,flag:'typing.Any') -> 'None':
         """
         Calls ServerSupportFunction with HSE_REQ_SET_FLUSH_FLAG.

Args:

      flag(typing.Any):

Returns:

      None
        
         """
         pass


      def TransmitFile(self,callback:'typing.Any',param:'typing.Any',hFile:'typing.Any',statusCode:'str',BytesToWrite:'typing.Any',Offset:'typing.Any',head:'str',tail:'str',flags:'typing.Any') -> 'typing.Any':
         """
         Calls ServerSupportFunction with HSE_REQ_TRANSMIT_FILE

Args:

      callback(typing.Any):
      param(typing.Any):Any object - passed as 2nd arg to callback.
      hFile(typing.Any):
      statusCode(str):
      BytesToWrite(typing.Any):
      Offset(typing.Any):
      head(str):
      tail(str):
      flags(typing.Any):CommentsThe callback is called with 4 args - (PyECB, param, cbIO, dwErrCode)

Returns:

      typing.Any
        
         """
         pass


      def MapURLToPath(self,) -> 'None':
         """
         Calls ServerSupportFunction with HSE_REQ_MAP_URL_TO_PATH

Args:



Returns:

      None
        
         """
         pass


      def DoneWithSession(self,status:'typing.Any') -> 'None':
         """
         Calls ServerSupportFunction with HSE_REQ_DONE_WITH_SESSION

Args:

      status(typing.Any):An optional status. HSE_STATUS_SUCCESS_AND_KEEP_CONN is supported by IIS to keep the connection alive.

Returns:

      None
        
         """
         pass


      def Redirect(self,url:'str') -> 'None':
         """
         Calls ServerSupportFunction with HSE_REQ_SEND_URL_REDIRECT_RESP

Args:

      url(str):The URL to redirect to

Returns:

      None
        
         """
         pass


      def IsKeepAlive(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


      def GetAnonymousToken(self,metabase_path:'typing.Union[str, typing.Any]') -> 'typing.Any':
         """
         Calls ServerSupportFunction with HSE_REQ_GET_ANONYMOUS_TOKEN 

or HSE_REQ_GET_UNICODE_ANONYMOUS_TOKEN

Args:

      metabase_path(typing.Union[str, typing.Any]):

Returns:

      typing.Any
        
         """
         pass


      def GetImpersonationToken(self,) -> 'typing.Any':
         """
         Calls ServerSupportFunction with 

HSE_REQ_GET_IMPERSONATION_TOKEN

Args:



Returns:

      typing.Any
        
         """
         pass


      def IsKeepConn(self,) -> 'typing.Any':
         """
         Calls ServerSupportFunction with HSE_REQ_IS_KEEP_CONN

Args:



Returns:

      typing.Any
        
         """
         pass


      def ExecURL(self,url:'str',method:'str',clientHeaders:'str',info:'typing.Any',entity:'typing.Any',flags:'typing.Any') -> 'typing.Any':
         """
         Calls ServerSupportFunction with HSE_REQ_EXEC_URL

Args:

      url(str):
      method(str):
      clientHeaders(str):
      info(typing.Any):Must be None
      entity(typing.Any):Must be None
      flags(typing.Any):CommentsThis function is only available in IIS6 and later.

Returns:

      typing.Any
        
         """
         pass


      def GetExecURLStatus(self,) -> 'typing.Any':
         """
         Calls ServerSupportFunction with HSE_REQ_GET_EXEC_URL_STATUS

Args:



Returns:

      typing.Any:Search for HSE_EXEC_URL_STATUS at msdn, google or google groups.
Return ValueThe result of a tuple of 3 integers - (uHttpStatusCode, uHttpSubStatus, dwWin32Error)

        
         """
         pass


      def IOCompletion(self,func:'typing.Any',arg:'typing.Any'=None) -> 'typing.Any':
         """
         Set a callback that will be used for handling asynchronous I/O 

operations.

Args:

      func(typing.Any):The function to call, as described by the EXTENSION_CONTROL_BLOCK::IOCallback method.
      arg(typing.Any):Any object which will be supplied as an argument to the callback function.CommentsIf you call this multiple times, the previous callback will be discarded.A reference to the callback and args are held until EXTENSION_CONTROL_BLOCK::DoneWithSession is called. If the callback function fails, DoneWithSession(HSE_STATUS_ERROR) will automatically be called and no further callbacks for the ECB will be made.

Returns:

      typing.Any
        
         """
         pass


      def ReportUnhealthy(self,reason:'str'=None) -> 'typing.Any':
         """
         Calls ServerSupportFunction with HSE_REQ_REPORT_UNHEALTHY

Args:

      reason(str):An optional reason to be written to the log.

Returns:

      typing.Any
        
         """
         pass


      def IOCallback(self,ecb:'EXTENSION_CONTROL_BLOCK',arg:'typing.Any',cbIO:'typing.Any',dwError:'typing.Any') -> 'typing.Any':
         """
         A placeholder for a user-supplied callback function.

Args:

      ecb(EXTENSION_CONTROL_BLOCK):The extension control block that is associated with the current, active request.
      arg(typing.Any):The user-supplied argument supplied to the EXTENSION_CONTROL_BLOCK::IOCompletion function.
      cbIO(typing.Any):An integer that contains the number of bytes of I/O in the last call.
      dwError(typing.Any):The error code returned.CommentsThis is not a function you can call, it describes the signature of the callback function supplied to the EXTENSION_CONTROL_BLOCK::IOCompletion function.Return ValueThe result of this function is ignored.

Returns:

      typing.Any:The error code returned.Comments

This is not a function you can call, it describes the signature of 

the callback function supplied to the EXTENSION_CONTROL_BLOCK::IOCompletion 

function.
Return ValueThe result of this function is ignored.

        
         """
         pass


class HSE_VERSION_INFO(object):
      """An object used by ISAPI GetExtensionVersion"""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ExtensionDesc(self)->'str':
         """The description of the extension."""
         pass


class HTTP_FILTER_AUTHENT(object):
      """A Python representation of an ISAPI 

HTTP_FILTER_AUTHENT structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def User(self)->'str':
         """"""
         pass


      @property
      def Password(self)->'str':
         """"""
         pass


class HTTP_FILTER_CONTEXT(object):
      """A Python representation of an ISAPI 

HTTP_FILTER_CONTEXT structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def Revision(self)->'typing.Any':
         """(read-only)"""
         pass


      @property
      def fIsSecurePort(self)->'typing.Any':
         """(read-only)"""
         pass


      @property
      def NotificationType(self)->'typing.Any':
         """(read-only)"""
         pass


      @property
      def FilterContext(self)->'typing.Any':
         """Any object you wish to associate with the request."""
         pass


      def GetData(self,) -> 'typing.Any':
         """
         Obtains the data passed to 

The HttpFilterProc function.  This is not techinally part of the 

HTTP_FILTER_CONTEXT structure, but packaged here for convenience.

Args:



Returns:

      typing.Any:HTTP_FILTER_CONTEXT.GetData

object = GetData()Obtains the data passed to 

The HttpFilterProc function.  This is not techinally part of the 

HTTP_FILTER_CONTEXT structure, but packaged here for convenience.
Return ValueThe result depends on the value of HTTP_FILTER_CONTEXT::NotificationType




NotificationType


Result type



SF_NOTIFY_URL_MAPHTTP_FILTER_URL_MAP
SF_NOTIFY_PREPROC_HEADERSHTTP_FILTER_PREPROC_HEADERS
SF_NOTIFY_LOGHTTP_FILTER_LOG
SF_NOTIFY_SEND_RAW_DATAHTTP_FILTER_RAW_DATA
SF_NOTIFY_READ_RAW_DATAHTTP_FILTER_RAW_DATA
SF_NOTIFY_AUTHENTICATIONHTTP_FILTER_AUTHENT

        
         """
         pass


      def GetServerVariable(self,variable:'str',default:'typing.Any') -> 'str':
         """
         None

Args:

      variable(str):
      default(typing.Any):If specified, the function will return this value instead of raising an error if the variable could not be fetched.Return ValueThe result is a string object, unless the server variable name begins with 'UNICODE_', in which case it is a unicode object - see the ISAPI docs for more details.

Returns:

      str:If specified, the function will return this 

value instead of raising an error if the variable could not be fetched.Return ValueThe result is a string object, unless the server variable name 

begins with 'UNICODE_', in which case it is a unicode object - see the 

ISAPI docs for more details.

        
         """
         pass


      def WriteClient(self,data:'str',reserverd:'typing.Any'=0) -> 'None':
         """
         None

Args:

      data(str):
      reserverd(typing.Any):

Returns:

      None
        
         """
         pass


      def AddResponseHeaders(self,data:'str',reserverd:'typing.Any'=0) -> 'None':
         """
         None

Args:

      data(str):
      reserverd(typing.Any):

Returns:

      None
        
         """
         pass


      def SendResponseHeader(self,status:'str',header:'str') -> 'None':
         """
         None

Args:

      status(str):
      header(str):

Returns:

      None
        
         """
         pass


      def DisableNotifications(self,flags:'typing.Any') -> 'None':
         """
         None

Args:

      flags(typing.Any):

Returns:

      None
        
         """
         pass


class HTTP_FILTER_LOG(object):
      """A Python representation of an ISAPI 

HTTP_FILTER_LOG structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ClientHostName(self)->'str':
         """"""
         pass


      @property
      def ClientUserName(self)->'str':
         """"""
         pass


      @property
      def ServerName(self)->'str':
         """"""
         pass


      @property
      def Operation(self)->'str':
         """"""
         pass


      @property
      def Target(self)->'str':
         """"""
         pass


      @property
      def Parameters(self)->'str':
         """"""
         pass


      @property
      def HttpStatus(self)->'typing.Any':
         """"""
         pass


class HTTP_FILTER_PREPROC_HEADERS(object):
      """A Python representation of an ISAPI 

HTTP_FILTER_PREPROC_HEADERS structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      def GetHeader(self,header:'str',default:'typing.Any') -> 'str':
         """
         None

Args:

      header(str):
      default(typing.Any):If specified, this will be returned on error.

Returns:

      str
        
         """
         pass


      def SetHeader(self,name:'str',val:'str') -> 'None':
         """
         None

Args:

      name(str):
      val(str):

Returns:

      None
        
         """
         pass


      def AddHeader(self,) -> 'None':
         """
         None

Args:



Returns:

      None
        
         """
         pass


class HTTP_FILTER_RAW_DATA(object):
      """A Python representation of an ISAPI 

HTTP_FILTER_RAW_DATA structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def InData(self)->'str':
         """"""
         pass


class HTTP_FILTER_URL_MAP(object):
      """A Python representation of an ISAPI 

HTTP_FILTER_URL_MAP structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def URL(self)->'str':
         """"""
         pass


      @property
      def PhysicalPath(self)->'str':
         """"""
         pass


class HTTP_FILTER_VERSION(object):
      """A Python interface to the ISAPI HTTP_FILTER_VERSION 

structure."""

      def __new__(cls):
         raise Exception('This class just for typing, can not be instanced!')


      @property
      def ServerFilterVersion(self)->'typing.Any':
         """(read-only)"""
         pass


      @property
      def FilterVersion(self)->'typing.Any':
         """"""
         pass


      @property
      def Flags(self)->'typing.Any':
         """"""
         pass


      @property
      def FilterDesc(self)->'str':
         """"""
         pass
